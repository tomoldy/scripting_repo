(*
# TPointArray
TPointArray related methods
*)

{$DEFINE SRL_TPOINTARRAY_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL-T/utils.simba}
{$ENDIF}

{$loadlib ../../plugins/libslacktree/libslacktree}
{$loadlib ../../plugins/libtpaex/libtpaex}

procedure TPointArray.Append(const Value: TPoint);
var top:Int32;
begin
  top := Length(Self);
  SetLength(self, top+1);
  Self[top] := Value;
end;

procedure TPointArray.Insert(const Value: TPoint; Index: Integer);
var
  l: UInt32;
begin
  l := Length(Self);
  if (l <= Index) then
  begin
    Self.Append(Value);
    Exit();
  end;

  SetLength(Self, l + 1);
  MemMove(Self[Index], self[Index + 1], (L - Index) * SizeOf(self[0]));
  Self[Index] := Value;
end;

procedure TPointArray.Del(const Index: Integer; const Count: Integer = 1);
begin
  Delete(Self, Index, Count);
end;

function TPointArray.Len(): Integer;
begin
  Result := Length(Self);
end;

procedure TPointArray.Remove(const value: TPoint; const all: Boolean = False);
var
  arr: TIntegerArray;
  i: Integer;
begin
  if all then
    arr := Self.FindAll(value)
  else begin
    i := Self.Find(value);
    if i > -1 then
    begin
      SetLength(arr, 1);
      arr[0] := i;
    end;
  end;

  for i := 0 to High(arr) do
    Self.Del(arr[i]);
end;

function TPointArray.Pop(): TPoint;
var
  h: Integer;
begin
  h := High(Self);
  Result := Self[h];
  SetLength(Self, h);
end;

procedure TPointArray.Extend(Arr:TPointArray);
var L:Int32;
begin
  if Length(arr) > 0 then
  begin
    L := Length(Self);
    SetLength(Self, Length(Arr) + L);
    MemMove(Arr[0],Self[L],Length(Arr)*SizeOf(TPoint));
  end;
end;

function TPointArray.Find(const value: TPoint): Integer; constref;
begin
  for Result := 0 to High(Self) do
    if value = Self[Result] then
      Exit;

  Result := -1;
end;

function TPointArray.Contains(const value: TPoint): Boolean; constref;
var
  temp: TPointArray;
begin
  temp := [value];
  Result := Length(temp.Intersection(self)) = 1;
end;

function TPointArray.ContainsAll(values: TPointArray): Boolean;
begin
  Result := Length(Self.Intersection(values)) = Length(values);
end;


function TPointArray.FindAll(const Value: TPoint): TIntegerArray; constref;
var
  i,top: UInt32;
begin
  for i := 0 to High(Self) do
    if Self[i] = Value then
    begin
      SetLength(Result, top+1);
      Result[Inc(top)-1] := i;
    end;
end;



function TPointArray.Reversed(): TPointArray;
var
  lo:PtrUInt;
  r, p:^TPoint;
begin
  if (Length(Self) = 0) then
    Exit();

  SetLength(Result,length(self));
  p := @Self[high(self)];
  r := @Result[0];

  lo := PtrUInt(@Self[0]);
  while (lo<=PtrUInt(p)) do
  begin
    r^ := p^;
    dec(p);
    inc(r);
  end;
end;

procedure TPointArray.Reverse();
var
  tmp:TPoint;
  lo,hi:^TPoint;
begin
  if (Length(Self) = 0) then
    Exit();

  lo := @Self[0];
  hi := @Self[High(self)];
  while (PtrUInt(lo)<PtrUInt(hi)) do
  begin
    tmp := hi^;
    hi^ := lo^;
    lo^ := tmp;
    dec(hi);
    inc(lo);
  end;
end;

function TPointArray.Combine(Other: TPointArray): TPointArray; constref;
begin
  SetLength(Result, Length(Self) + Length(Other));
  if Length(self) > 0 then
    MemMove(self[0], result[0], Length(self)*SizeOf(self[0]));
  if Length(Other) > 0 then
    MemMove(Other[0], result[Length(Self)], Length(Other)*SizeOf(Other[0]));
end;


function TPointArray.Equals(Other:TPointArray): Boolean; constref;
begin
  if (Length(Self) <> Length(Other)) then Exit(False);
  if (Length(Self) = 0) then Exit(True);
  Result := CompareMem(Self[0], Other[0], length(self)*SizeOf(self[0]));
end;


function TPointArray.First(): TPoint; constref;
begin
  if Length(Self) > 0 then
    Result := Self[0];
end;

function TPointArray.Last(): TPoint; constref;
begin
  if Length(Self) > 0 then
    Result := Self[High(Self)];
end;


function TPointArray.Matrix(): T2DBoolArray; constref;
begin
  Result := TPAMatrix(Self);
end;

function TPointArray.Intersection(other: TPointArray): TPointArray; constref;
begin
  try
    GetSamePointsATPA([Self, Other], Result)
  except
    Result := [];
  end;
end;

function TPointArray.Difference(other: TPointArray): TPointArray; constref;
begin
  Result := ClearTPAFromTPA(Self, other);
end;

function TPointArray.SymmetricDifference(other: TPointArray): TPointArray; constref;
begin
  Result := ClearTPAFromTPA(Self, other) + ClearTPAFromTPA(other, Self);
end;


function TPointArray.TotalDistance(): Double;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if i < High(Self) then
      Result += Self[i].DistanceTo(Self[i+1]);
end;


function TPointArray.AStarDebug(start, goal: TPoint; diagonalTravel: Boolean = True; colorMapID: Int32 = 0): TPointArray;
var
  matrix: TSingleMatrix;
  bmp: TMufasaBitmap;
begin
  Result := AStarTPAEx(Self, matrix, start, goal, diagonalTravel);
  bmp.Init();
  bmp.DrawMatrix(matrix, colorMapID);
  ShowBitmap(bmp);
  bmp.Free();
end;

function TPointArray.AStar(start, goal: TPoint; diagonalTravel: Boolean = True): TPointArray;
begin
  Result := AStarTPA(Self, start, goal, diagonalTravel);
end;


//--| Type helpers (extended) |------------------------------------------------>
//----------------------------------------------------------------------------->
(*
## TPointArray.Mean
```pascal
function TPointArray.Mean(): TPoint; constref;
```
Wraps Simba's TPAMiddle
*)
function TPointArray.Mean(): TPoint; constref;
begin
  Result := MiddleTPA(self);
end;


(*
## TPointArray.MeanEx
```pascal
function TPointArray.MeanEx(): Vector2; constref;
```
Middle as a Vector.
*)
function TPointArray.MeanEx(): Vector2; constref;
var
  i,x,y: Int64;
begin
  for i:=0 to High(Self) do
  begin
    Inc(x, Self[i].x);
    Inc(y, Self[i].y);
  end;
  Result.x := x / Length(Self);
  Result.y := y / Length(Self);
end;

function TPointArray.Median: TPoint; constref;
begin
  Result := MedianTPA(Self);
end;

(*
## TPointArray.Sort
```pascal
procedure TPointArray.Sort(From:TPoint=[0,0]);
```
Wraps Simba's `SortTPAFrom`
*)
procedure TPointArray.Sort(From:TPoint=[0,0]);
begin
  SortTPAFrom(self, From);
end;

(*
## TPointArray.SortFrom
```pascal
function TPointArray.Sorted(from: TPoint = [0,0]): TPointArray;
function TPointArray.SortFrom(from: TPoint = [0,0]): TPointArray; constref;
```
Wraps Simba's `SortTPAFrom`, produces a sorted copy.
*)
function TPointArray.Sorted(from: TPoint = [0,0]): TPointArray; constref;
begin
  Result := Copy(Self);
  SortTPAFrom(Result, from);
end;

function TPointArray.SortFrom(from:TPoint = [0,0]): TPointArray; constref;
begin
  Result := Copy(Self);
  SortTPAFrom(Result, from);
end;

//Credits to someone from SRL. IDK who sorry.
procedure TPointArray.WeightedSort(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean);
var
  lo, hi, mid: Int32;
begin
  if (Length(weights) <> Length(Self)) then Exit;
  lo := iLo;
  hi := iHi;
  mid := weights[(lo + hi) shr 1];
  repeat
    if sortUp then
    begin
      while (weights[lo] < mid) do Inc(lo);
      while (weights[hi] > mid) do Dec(hi);
    end
    else
    begin
      while (weights[lo] > mid) do Inc(lo);
      while (weights[hi] < mid) do Dec(hi);
    end;

    if (lo <= hi) then
    begin
      Swap(weights[lo], weights[hi]);
      Swap(Self[lo], Self[hi]);
      Inc(lo);
      Dec(hi);
    end;
  until lo > hi;

  if (hi > iLo) then Self.WeightedSort(weights, iLo, hi, sortUp);
  if (lo < iHi) then Self.WeightedSort(weights, lo, iHi, sortUp);
end;

function TPointArray.WeightSorted(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean): TPointArray; constref;
begin
  Result := Copy(Self);
  Result.WeightedSort(weights, iLo, iHi, sortUp);
end;


(*
## TPointArray.SortByX
```pascal
procedure TPointArray.SortByX(LowToHi:Boolean=True);
```
Wraps Simba's `SortTPAByX`
*)
procedure TPointArray.SortByX(LowToHi:Boolean=True);
begin
  SortTPAByX(self, LowToHi);
end;

(*
## TPointArray.SortByY
```pascal
procedure TPointArray.SortByY(LowToHi:Boolean=True);
```
Wraps Simba's `SortTPAByY`
*)
procedure TPointArray.SortByY(LowToHi:Boolean=True);
begin
  SortTPAByY(self, LowToHi);
end;


(*
## TPointArray.SortByRow
```pascal
procedure TPointArray.SortByRow(reverse:Boolean=False);
```
Sorts a given TPointArray TPA row-by-row, starting from the smallest Y coordinate to the largest Y coordinate, and for every row from the smallest X coordinate to the largest X coordinate.
*)
procedure TPointArray.SortByRow(reverse:Boolean=False);
var
  i,hi,w: Int32;
  weight: TIntegerArray;
  area : TBox;
begin
  Hi := High(self);
  if Hi <= 1 then Exit;
  area := GetTPABounds(self);
  w := Area.X2 - Area.X1 + 1;
  SetLength(weight, hi+1);
  for i:=0 to Hi do
    weight[i] := self[i].y * W + self[i].x;
  QuickTPASort(Weight, self, 0, Hi, not reverse);
end;


(*
## TPointArray.SortByColumn
```pascal
procedure TPointArray.SortByColumn(reverse:Boolean=False);
```
Much like SortByRow, but the order of the column comes first
*)
procedure TPointArray.SortByColumn(reverse:Boolean=False);
var
  i,Hi,H: Int32;
  weight: TIntegerArray;
  area: TBox;
begin
  Hi := High(self);
  if Hi <= 1 then Exit;
  Area := GetTPABounds(self);
  H := Area.Y2 - Area.Y1 + 1;
  SetLength(Weight, Hi+1);
  for i := 0 to Hi do
    Weight[i] := self[i].x * H + self[i].y;
  QuickTPASort(Weight, self, 0, Hi, not reverse);
end;

(*
## TPointArray.SortFromLine
```pascal
procedure TPointArray.SortFromLine(p,q:TPoint; reverse:Boolean=False);
```
The name tells the story
*)
procedure TPointArray.SortFromLine(p,q:TPoint; reverse:Boolean=False);
var
  i,hi: Int32;
  weight: TIntegerArray;
begin
  Hi := High(self);
  if Hi <= 1 then Exit;
  SetLength(weight, hi+1);
  for i:=0 to Hi do
    weight[i] := Ceil(srl.DistToLine(self[i],p,q));
  QuickTPASort(Weight, self, 0, Hi, not reverse);
end;

procedure TPointArray.SortCircle(Center: TPoint; StartDegree: Int32; ClockWise: Boolean);
begin
  SortCircleWise(Self, Center.X, Center.Y, StartDegree, True, ClockWise);
end;

(*
## TPointArray.Bounds
```pascal
function TPointArray.Bounds(): TBox; constref;
```
Wraps Simba's GetTPABounds
*)
function TPointArray.Bounds(): TBox; constref;
begin
  if Length(Self) = 1 then
    Exit(TBox([Self[0].x, Self[0].y, Self[0].x, Self[0].y]));

  Result := GetTPABounds(Self);
end;

(*
## TPointArray.Edges
```pascal
function TPointArray.Edges(): TPointArray; constref;
```
Filters all points out of the given TPointArray which aren't edge-points.
Edge-points are points that are on the edge of the TPA, not completely surrounded by other points.
Same as Simba's `FindTPAEdges`
*)
function TPointArray.Edges(): TPointArray; constref;
begin
  Result := FindTPAEdges(Self);
end;

(*
## TPointArray.Cluster
```pascal
function TPointArray.Cluster(dist: Int32): T2DPointArray; constref;
function TPointArray.Cluster(distX,distY: Int32): T2DPointArray; constref; overload;
```
Smart wrapper of Simba's `ClusterTPA` and `ClusterTPAEx` (fall backs to `SplitTPA` when it's better suited)
*)
function TPointArray.Cluster(dist: Int32): T2DPointArray; constref;
begin
  if (Length(Self) < 700) then
    Result := SplitTPA(Self, dist)
  else
    Result := ClusterTPA(Self, dist);
end;

function TPointArray.Cluster(distX,distY: Int32): T2DPointArray; constref; overload;
begin
  if (Length(Self) < 1200) then
    Result := SplitTPAEx(Self, distX, distY)
  else
    Result := ClusterTPAEx(Self, distX, distY);
end;


//Non rounding TPA.Cluster
function TPointArray.NRCluster(dist: Single): T2DPointArray; constref;
begin
  if (Length(Self) < 700) then
    Exit(NRSplitTPA(Self, dist, dist));
  Result := NRClusterTPA(Self, dist);
end;


(*
## TPointArray.Split
```pascal
function TPointArray.Split(dist: Int32): T2DPointArray; constref;
function TPointArray.Split(distX,distY: Int32): T2DPointArray; constref; overload;
```
Wraps Simba's `SplitTPA` and `SplitTPAEx`
*)
function TPointArray.Split(dist: Int32): T2DPointArray; constref;
begin
  Result := SplitTPA(Self, dist);
end;

function TPointArray.Split(distX,distY: Int32): T2DPointArray; constref; overload;
begin
  Result := SplitTPAEx(Self, distX, distY);
end;


(*
## TPointArray.ToATPA
```pascal
function TPointArray.ToATPA(WH:Int32): T2DPointArray; constref;
function TPointArray.ToATPA(W,H:Int32): T2DPointArray; constref; overload;
```
Wraps Simba's `TPAToATPA` and `TPAToATPAEx`
*)
function TPointArray.ToATPA(WH:Int32): T2DPointArray; constref;
begin
  Result := TPAToATPA(Self, WH);
end;

function TPointArray.ToATPA(W,H:Int32): T2DPointArray; constref; overload;
begin
  Result := TPAToATPAEx(Self, W,H);
end;

(*
## TPointArray.Offset
```pascal
function TPointArray.Offset(X, Y: Int32): TPointArray; constref;
function TPointArray.Offset(off: TPoint): TPointArray; constref; overload;
```
Wraps Simba's `OffsetTPA`
*)
function TPointArray.Offset(X, Y: Int32): TPointArray; constref;
begin
  Result := Copy(Self);

  OffsetTPA(Result, [X, Y]);
end;

function TPointArray.Offset(off: TPoint): TPointArray; constref; overload;
begin
  Result := Offset(Off.X, Off.Y);
end;

(*
## TPointArray.Invert
```pascal
function TPointArray.Invert(Area:TBox=[0,0,-1,-1]): TPointArray; constref;
```
Inverts the shape based on the area covered, alternatively the given area.
Same as `ReturnPointsNotInTPA` in Simba.
*)
function TPointArray.Invert(area:TBox=[0,0,-1,-1]): TPointArray; constref;
begin
  if Area = Box(0,0,-1,-1) then
    Area := Self.Bounds();
  Result := ReturnPointsNotInTPA(Self, Area);
end;


(*
## TPointArray.Filter
```pascal
function TPointArray.FilterBox(b: TBox): TPointArray; constref;
function TPointArray.FilterRectangle(rect: TRectangle): TPointArray; constref;
function TPointArray.FilterCircle(circle: TCircle): TPointArray; constref;
function TPointArray.FilterDist(MinDist,MaxDist: Double; Mx,My: Int32): TPointArray; constref;
function TPointArray.FilterDuplicates(): TPointArray; constref;
```
Returns a filtered versions of the TPA.
They should be self explanatory by their naming and parameters.
*)
function TPointArray.FilterBox(b: TBox): TPointArray; constref;
begin
  Result := Copy(Self);
  FilterPointsBox(Result, b.X1, b.Y1, b.X2, b.Y2);
end;

function TPointArray.FilterRectangle(rect: TRectangle): TPointArray; constref;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].InRect(rect) then
      Result += Self[i];
end;

function TPointArray.FilterCircle(circle: TCircle): TPointArray; constref;
begin
  Result := Copy(Self);
  FilterPointsDist(Result, 0, circle.Radius, circle.X, circle.Y);
end;

function TPointArray.FilterDist(MinDist,MaxDist: Double; Mx,My: Int32): TPointArray; constref;
begin
  Result := Copy(Self);
  FilterPointsDist(Result, MinDist, MaxDist, Mx,My);
end;

function TPointArray.FilterDuplicates(): TPointArray; constref;
begin
  Result := Copy(Self);
  ClearDoubleTPA(Result);
end;


(*
## TPointArray.ClearDuplicates
```pascal
procedure TPointArray.ClearDuplicates();
```
Removes all the duplicate points from self.
*)
procedure TPointArray.ClearDuplicates();
begin
  ClearDoubleTPA(Self);
end;

function TPointArray.Unique(): TPointArray; constref;
begin
  Result := Copy(Self);
  ClearDoubleTPA(Result);
end;

(*
## TPointArray.Rotate
```pascal
function TPointArray.Rotate(angleRad, x, y: Double): TPointArray;
function TPointArray.Rotate(angleRad: Double; mid: TPoint): TPointArray; constref; overload;
function TPointArray.Rotate(angleRad: Double; mid: Vector2): TPointArray; constref; overload;
```
Returns a copy where all points are rotated around `x` and `y`, a `TPoint` or a `Vector2`.
Same as Simba's `RotatePoints`.
*)
function TPointArray.Rotate(angleRad, MidX, MidY: Double): TPointArray; constref;
begin
  Result := RotatePoints(Self, angleRad, MidX, MidY);
end;

function TPointArray.Rotate(angleRad: Double; mid: TPoint): TPointArray; constref; overload;
begin
  Result := RotatePoints(Self, angleRad, mid.X, mid.Y);
end;

function TPointArray.Rotate(angleRad: Double; mid: Vector2): TPointArray; constref; overload;
begin
  Result := RotatePoints(Self, angleRad, mid.X, mid.Y);
end;


(*
## TPointArray.SplitRows
```pascal
function TPointArray.SplitRows(dist:Int32): T2DPointArray; constref;
```
Splits a TPA `Arr` into TPAs of each row, it then proceeds to further split the rows
in to separate TPAs when the given distance ``dist`` is less than the distance between the points
Same output as `SplitTPAEx(TPA,dist,0)`, but generally faster.

```{note}
By slacky
```

Example:
```pascal
  ATPA := TPA.SplitRows(5);
```
*)
function TPointArray.SplitRows(dist:Int32): T2DPointArray; constref;
var
  TPA,tmp:TPointArray;
  i,ii,j,n,s,h,l:Int32 = 0;
begin
  TPA := Copy(self);
  SortTPAByY(TPA,True);
  SetLength(Result, Length(TPA));
  l := Length(TPA);
  while j < l do
  begin
    s := 0;
    i := j;
    inc(j);
    while (j < l) and (TPA[j].y = TPA[j-1].y) do Inc(j);

    if j-i > 1 then
    begin
      tmp := Copy(TPA,i,j-i);
      SortTPAByX(tmp,True);
      h := High(tmp);
      for ii:=1 to h do
        if (tmp[ii].x-tmp[ii-1].x > dist) or (ii = h) then
        begin
          Result[Inc(n)-1] := Copy(tmp, s, ii-s+(ord(ii = h) and 1));
          s := ii;
        end;
    end else if j-i = 1 then
      Result[Inc(n)-1] := [TPA[i]];
  end;
  SetLength(Result, n);
end;


(*
## TPointArray.Connect
```pascal
function TPointArray.Connect(): TPointArray; constref;
```
Fills a line between all the points (by their order), can be used to get the edges
around a polygon

```{note}
By slacky
```

Example:
```pascal
  edges := TPA.ConvexHull().Connect();
```
*)
function TPointArray.Connect(): TPointArray; constref;
var line:TPointArray; i:Int32;
begin
  if Length(self) = 0 then Exit;

  for i:=0 to High(self)-1 do
  begin
    line := TPAFromLine(self[i].x, self[i].y, self[i+1].x, self[i+1].y);
    Result := Result.Combine(line);
  end;
  line := TPAFromLine(self[High(self)].x, self[High(self)].y, self[0].x, self[0].y);
  Result := Result.Combine(line);
end;


function TPointArray.CreateFromLine(start, stop: TPoint): TPointArray; static;
begin
  Result := TPAFromLine(start.X, start.Y, stop.X, stop.Y);
end;


(*
## TPointArray.ConvexHull
```pascal
function TPointArray.ConvexHull(): TPointArray; constref;
```
Computes the convex hull around the given TPA. Imagine placing a rubber band around the
points, the points which strech the band are the points returned by this function.

See: http://en.wikipedia.org/wiki/Convex_hull for more information.

```{note}
By slacky
```

Example:
```pascal
  Smart.Image.DrawTPA(TPA.ConvexHull());
```
*)
function TPointArray.ConvexHull(): TPointArray; constref;
var
  pts: TPointArray;
  h,i,k,u: Int32;
begin
  if High(self) <= 2 then Exit(self);
  pts := Copy(self);
  SortTPAByX(pts,True);

  H := High(pts);
  SetLength(result, 2 * (h+1));

  for i:=0 to h do
  begin
    while (k >= 2) and (srl.CrossProduct(result[k-2], result[k-1], pts[i]) <= 0) do
      Dec(k);
    result[k] := pts[i];
    Inc(k);
  end;

  u := k+1;
  for i:=h-1 downto 0 do
  begin
    while (k >= u) and (srl.CrossProduct(result[k-2], result[k-1], pts[i]) <= 0) do
      Dec(k);
    result[k] := pts[i];
    Inc(k);
  end;
  SetLength(result, k-1);
end;

(*
## TPointArray.MinAreaRect
```pascal
function TPointArray.MinAreaRect(): TRectangle;
```
Computes the minimum bounding box (defined by area) around the given shape.
Four points (which are in order) are always returned.

See: http://en.wikipedia.org/wiki/Minimum_bounding_box for more information.

```{note}
By slacky
```

Example:
```pascal
  WriteLn('The four box corners are: ', TPA.MinAreaRect());
```
*)
function TPointArray.MinAreaRect(): TRectangle; constref;
var
  TPA: TPointArray;
  l,i,ii,j,c: Int32;
  x,y,cosA,cosAP,cosAM: Double;
  xl,yl,xh,yh,angle: Double;
  angles, best: Array of Double;
  added: Boolean;

  function Modulo(X,Y:Double): Double;
  begin
    Result := X - Floor(X / Y) * Y;
  end;
const
  HALF_PI := PI / 2;
begin
  if Length(Self) <= 1 then Exit;
  TPA := Self.ConvexHull();
  L := High(TPA);
  SetLength(angles, L);

  j := 0;
  for i:=0 to (L-1) do
  begin
    angles[j] := High(Int32);
    added := False;
    angle := Abs(Modulo(ArcTan2(TPA[i+1].y-TPA[i].y, TPA[i+1].x-TPA[i].x), HALF_PI));
    for c:=0 to j do
      if (angles[c] = angle) then
        added := True;

    if not(added) then
      angles[Inc(j)-1] := angle;
  end;

  SetLength(best, 2);
  best[1] := High(Int32);
  for i:=0 to j-1 do
  begin
    CosA  := Cos(Angles[i]);
    CosAP := Cos(Angles[i] + HALF_PI);
    CosAM := Cos(Angles[i] - HALF_PI);
    xl := (CosA*TPA[0].x) + (CosAM*TPA[0].y);
    yl := (CosAP*TPA[0].x) + (CosA*TPA[0].y);
    xh := xl;
    yh := yl;

    for ii:=0 to L do
    begin
      x := (CosA * TPA[ii].x) + (CosAM * TPA[ii].y);
      y := (CosAP * TPA[ii].x) + (CosA * TPA[ii].y);
      if (x > xh) then xh := x
      else if (x < xl) then xl := x;
      if (y > yh) then yh := y
      else if (y < yl) then yl := y;
    end;

    if (xh-xl)*(yh-yl) < best[1] then
    begin
      best[0] := angles[i];       //angle
      best[1] := (xh-xl)*(yh-yl); //area
      Result.Top   := Point(Round((cosAP*yl) + (cosA*xl)), Round((cosA*yl) + (cosAM*xl)));
      Result.Right := Point(Round((cosAP*yl) + (cosA*xh)), Round((cosA*yl) + (cosAM*xh)));
      Result.Btm   := Point(Round((cosAP*yh) + (cosA*xh)), Round((cosA*yh) + (cosAM*xh)));
      Result.Left  := Point(Round((cosAP*yh) + (cosA*xl)), Round((cosA*yh) + (cosAM*xl)));
    end;
  end;
end;

function TPointArray.MinAreaRectEx(out LongSideLen, ShortSideLen: Int32): TRectangle; constref;
begin
  Result := Self.MinAreaRect();
  LongSideLen  := Round(Distance(Result.Btm, Result.Right));
  ShortSideLen := Round(Distance(Result.Btm, Result.Left));
  if (LongSideLen < ShortSideLen) then
    Swap(LongSideLen, ShortSideLen);
end;


(*
## TPointArray.MinAreaCircle
```pascal
function TPointArray.MinAreaCircle(): TCircle;
```
Computes the minimum bounding circle around the given shape.

See: https://en.wikipedia.org/wiki/Smallest-circle_problem for more information.

Implementation is a mixture of a few implementations I've seen.
*)
function TPointArray.MinAreaCircle(): TCircle; constref;
  function NewCircle2(p0, p1: TPoint): TCircle;
  var
    x,y: Int32;
  begin
    x := (p0.x + p1.x) div 2;
    y := (p0.y + p1.y) div 2;
    Result := [x,y, Ceil(Max(Hypot(x-p0.x,y-p0.y),Hypot(x-p1.x,y-p1.y)))];
  end;

  function NewCircle3(p0, p1, p2: TPoint): TCircle;
  var
    d,ax,ay,bx,by,cx,cy,ox,oy,x,y,ra,rb,rc: Int32;
  begin
    // Mathematical algorithm from Wikipedia: Circumscribed circle
    ax := p0.x; ay := p0.y;
    bx := p1.x; by := p1.y;
    cx := p2.x; cy := p2.y;
    ox := (Min(Min(ax, bx), cx) + Max(Max(ax, bx), cx)) div 2;
    oy := (Min(Min(ay, by), cy) + Max(Max(ay, by), cy)) div 2;
    ax -= ox; ay -= oy;
    bx -= ox; by -= oy;
    cx -= ox; cy -= oy;
    d := (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) * 2;
    if (d = 0) then
      Exit;
    x := ox + ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) div d;
    y := oy + ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) div d;
    ra := Ceil(Hypot(x-p0.x, y-p0.y));
    rb := Ceil(Hypot(x-p1.x, y-p1.y));
    rc := Ceil(Hypot(x-p2.x, y-p2.y));
    Result := [x,y, Max(Max(ra, rb), rc)];
  end;

  // Two boundary points known
  function makeCircleTwoPoints(points:TPointArray; p, q: TPoint): TCircle;
  var
    c, circ, left, right: TCircle;
    r: TPoint;
    cross: Double;
  begin
    circ := NewCircle2(p, q);

    // For each point not in the two-point circle
    for r in points do
    begin
      if (circ.Contains(r)) then
        continue;

      // Form a circumcircle and classify it on left or right side
      cross := srl.CrossProduct(p.x, p.y, q.x, q.y, r.x, r.y);
      c := NewCircle3(p, q, r);
      if (c.Radius = 0) then
        continue
      else if (cross > 0) and ((left.Radius = 0) or (srl.CrossProduct(p.x, p.y, q.x, q.y, c.x, c.y) > srl.CrossProduct(p.x, p.y, q.x, q.y, left.x, left.y))) then
        left := c
      else if (cross < 0) and ((right.Radius = 0) or (srl.CrossProduct(p.x, p.y, q.x, q.y, c.x, c.y) < srl.CrossProduct(p.x, p.y, q.x, q.y, right.x, right.y))) then
        right := c;
    end;

    // Select which circle to return
    if (left.Radius = 0) and (right.Radius = 0) then
      Exit(circ)
    else if (left.Radius = 0) then
      Exit(right)
    else if (right.Radius = 0) or (left.Radius <= right.Radius) then
      Exit(left)
    else
      Exit(right);
  end;

  // One boundary point known
  function makeCircleOnePoint(Points:TPointArray; p:TPoint): TCircle;
  var
    i:Int32;
    q:TPoint;
  begin
    Result := [p.x, p.y, 0];
    for i:=0 to High(Points) do
    begin
      q := points[i];
      if (not Result.Contains(q)) then
      begin
        if (Result.Radius = 0) then
          Result := NewCircle2(p, q)
        else
          Result := makeCircleTwoPoints(Copy(points, 0, i + 1), p, q);
      end;
    end;
  end;

var
  TPA: TPointArray;
  i: Int32;
  p: TPoint;
begin
  if Length(Self) = 0 then Exit();
  if Length(Self) = 1 then Exit(TCircle([Self[0].x, Self[0].y, 0]));

  // Copy the list and shuffle
  TPA := Copy(Self);
  for i := High(TPA) downto 0 do
    Swap(TPA[i], TPA[Random(0,i)]);

  // Add points to circle one by one, and if needed recompute circle
  for i:=0 to High(TPA) do
  begin
    p := TPA[i];
    if (Result.Radius = 0) or (not Result.Contains(p)) then
      Result := makeCircleOnePoint(Copy(TPA, 0, i + 1), p);
  end;
end;

(*
## TPointArray.Density
```pascal
function TPointArray.Density(): Double; constref;
```
Returns the TPA's density (Length(TPA)/(width*height))
*)
function TPointArray.Density(): Double; constref;
var
  Area: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  Area := Self.MinAreaRect().Expand(1).Area;
  if (Area > 0) then
    Result := Length(Self) / Area;
end;



function TPointArray.NearestPoint(other: TPoint): TPoint;
begin
  if Length(Self) <= 0 then Exit;
  Result := Self.Sorted(other)[0];
end;


function TPointArray.Skeleton(FMin: Integer; FMax: Integer = 10): TPointArray; constref;
begin
  Result := SkeletonTPA(Self, fMin, fMax);
end;



//--| Other TPA methods |------------------------------------------------------>
//----------------------------------------------------------------------------->
(*
## ExpandPolygon
```pascal
function ExpandPolygon(Poly:TPointArray; inc:Int32): TPointArray;
```
A method for increasing the size of any convex polygon.

```{note}
By slacky
```
*)
function ExpandPolygon(Poly: TPointArray; inc: Int32): TPointArray;
type
  TPointF = record x,y:Double; end;
var
  i,k:Int32;
  theta, det: Double;
  c1,c2:array [0..2] of Double;
  p1,q1,p2,q2: TPointF;
  tmp:array of TPointF;
begin
  SetLength(Result, Length(Poly));
  SetLength(tmp, Length(Poly)*2);
  for i:=0 to High(Poly) do
  begin
    k := (i+1) mod Length(poly);
    theta := ArcTan2(poly[i].Y - poly[k].Y, poly[i].X - poly[k].X) + PI/2;
    tmp[i*2]  := TPointF([inc*Cos(theta)+poly[i].x, inc*Sin(theta)+poly[i].y]);
    tmp[i*2+1]:= TPointF([inc*Cos(theta)+poly[k].x, inc*Sin(theta)+poly[k].y]);
  end;

  for i:=0 to High(tmp) with 2 do
  begin
    p1 := tmp[i];
    p2 := tmp[(i+1) mod Length(tmp)];
    q1 := tmp[(i+2) mod Length(tmp)];
    q2 := tmp[(i+3) mod Length(tmp)];

    c1 := [(p1.y-p2.y), (p2.x-p1.x), -(p1.x*p2.y-p2.x*p1.y)];
    c2 := [(q1.y-q2.y), (q2.x-q1.x), -(q1.x*q2.y-q2.x*q1.y)];
    det  := c1[0] * c2[1] - c1[1] * c2[0];
    if (det <> 0) then
    begin
      Result[i div 2].x := Round((c1[2] * c2[1] - c1[1] * c2[2]) / det);
      Result[i div 2].y := Round((c1[0] * c2[2] - c1[2] * c2[0]) / det);
    end else
      Result[i div 2] := Point(Round(p2.x), Round(p2.y));
  end;
end;

function RandomTPA(n:Int32; B:TBox): TPointArray;
var i:Int32;
begin
  SetLength(Result, n);
  for i:=0 to n-1 do
    Result[i] := Point(Random(B.x1,B.x2), Random(B.y1,B.y2));
end;

// -------------------------------------------------------------------------------------
// Legacy methods (should be removed at some point, don't use them)

function MinAreaRect(TPA: TPointArray): TPointArray;
begin
  Result := TPA.MinAreaRect().ToTPA();
end;

function MinAreaRectEx(TPA: TPointArray; out LongSideLen, ShortSideLen: Int32): TPointArray;
begin
  Result := TPA.MinAreaRectEx(LongSideLen, ShortSideLen).ToTPA();
end;


procedure TPointArray.Fill;
begin
  FillEllipse(Self);
end;

function TPointArray.ShapeFill(): TPointArray; constref;
begin
  Result := Copy(Self);
  FillEllipse(Result);
end;


function TPointArray.Grow(constref Amount: Int32): TPointArray; constref;
begin
  Result := TPAGrow(Self, Amount);
end;

function TPointArray.Erode(constref Amount: Int32): TPointArray; constref;
begin
  Result := TPAErode(Self, Amount);
end;

(*
## TPointArray.PointsInRangeOf
```pascal
function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDist, MaxDist: Double): TPointArray; constref;
function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDistX, MinDistY, MaxDistX, MaxDistY: Double): TPointArray; constref; overload;
```
Returns all the points from `self` that are within range of any point in `other`.
The parameters `mindist` and `maxdist` determine what "within range" means.
*)
function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDist, MaxDist: Double): TPointArray; constref;
begin
  Result := System.PointsInRangeOf(Self, Other, MinDist, MinDist, MaxDist, MaxDist);
end;

function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDistX, MinDistY, MaxDistX, MaxDistY: Double): TPointArray; constref; overload;
begin
  Result := System.PointsInRangeOf(Self, Other, MinDistX, MinDistY, MaxDistX, MaxDistY);
end;

function TPointArray.Frameness(): Single;
var
  Edge: TPointArray := EdgeFromBox(Self.Bounds());
begin
  Result := (Length(Edge.PointsInRangeOf(Self, 0, 1)) / Length(Edge)) * 100;
end;

(*
## TPointArray.InRange
```pascal
function TPointArray.AnyInRange(p: TPoint; dist: Double): Boolean;
function TPointArray.AnyInRange(other: TPointArray; dist: Double): Boolean; overload;
function TPointArray.AllInRange(p: TPoint; dist: Double): Boolean;
```
Checks if the current points are within `dist` distance of `p`.
*)
function TPointArray.AnyInRange(p: TPoint; dist: Double): Boolean;
var
  q: TPoint;
begin
  for q in Self do
    if p.InRange(q, dist) then
      Exit(True);
end;

function TPointArray.AnyInRange(other: TPointArray; dist: Double): Boolean; overload;
var
  p, q: TPoint;
begin
  for p in Self do
    for q in other do
      if p.InRange(q, dist) then
        Exit(True);
end;

function TPointArray.AllInRange(p: TPoint; dist: Double): Boolean;
var
  q: TPoint;
begin
  for q in Self do
    if not p.InRange(q, dist) then
      Exit;
  Result := True;
end;



procedure T2DPointArray.Append(const Value: TPointArray);
var top:Int32;
begin
  top := Length(Self);
  SetLength(self, top+1);
  Self[top] := Value;
end;

procedure T2DPointArray.Insert(const Value: TPointArray; Index: Integer);
var
  l: UInt32;
begin
  l := Length(Self);
  if (l <= Index) then
  begin
    Self.Append(Value);
    Exit();
  end;

  SetLength(Self, l + 1);
  MemMove(Self[Index], self[Index + 1], (L - Index) * SizeOf(self[0]));
  Self[Index] := Value;
end;

procedure T2DPointArray.Del(const Index:Int32; const Count:Int32=1);
begin
  Delete(Self, Index, Count);
end;

function T2DPointArray.Len(): Integer;
begin
  Result := Length(Self);
end;

procedure T2DPointArray.Remove(const Value: TPointArray; const All: Boolean = False);
var
  i: Int32;
  lst: TIntegerArray;
begin
  if (not All) then
  begin
    i := Self.Find(Value);
    if i >= 0 then Self.Del(i);
    Exit;
  end;

  lst := Self.FindAll(Value);
  for i:=High(lst) downto 0 do
    Self.Del(lst[i]);
end;

function T2DPointArray.Pop(): TPointArray;
var
  h: Integer;
begin
  h := High(Self);
  Result := Self[h];
  SetLength(Self, h);
end;

procedure T2DPointArray.Extend(Arr:T2DPointArray);
var
  i: Int32;
begin
  for i := 0 to High(Arr) do
    Self := Self + Copy(Arr[i]);
end;

function T2DPointArray.Find(const Value: TPointArray): Integer; constref;
begin
  for Result:=0 to High(Self) do
    if Self[Result].Equals(Value) then
      Exit;
  Result := -1;
end;

function T2DPointArray.FindAll(const Value: TPointArray): TIntegerArray; constref;
var
  i: UInt32;
begin
  for i:=0 to High(Self) do
    if Value.Equals(Self[i]) then
      Result += i;
end;

function T2DPointArray.Reversed(): T2DPointArray;
var
  lo:PtrUInt;
  p,r:^TPointArray;
begin
  if (Length(Self) = 0) then
    Exit();

  SetLength(Result,length(self));
  p := @Self[high(self)];
  r := @Result[0];

  lo := PtrUInt(@Self[0]);
  while (lo<=PtrUInt(p)) do
  begin
    r^ := p^;
    dec(p);
    inc(r);
  end;
end;

procedure T2DPointArray.Reverse();
var
  tmp:TPointArray;
  lo,hi:^TPointArray;
begin
  if (Length(Self) = 0) then
    Exit();

  lo := @Self[0];
  hi := @Self[High(self)];
  while (PtrUInt(lo)<PtrUInt(hi)) do
  begin
    tmp := hi^;
    hi^ := lo^;
    lo^ := tmp;
    dec(hi);
    inc(lo);
  end;
end;

function T2DPointArray.Combine(Other: T2DPointArray): T2DPointArray; constref;
begin
  SetLength(Result, Length(Self) + Length(Other));
  if Length(self) > 0 then
    MemMove(self[0], result[0], Length(self)*SizeOf(self[0]));
  if Length(Other) > 0 then
    MemMove(Other[0], result[Length(Self)], Length(Other)*SizeOf(Other[0]));
end;


function T2DPointArray.Means(): TPointArray; constref;
var i:Int32;
begin
  SetLength(Result, Length(self));
  for i:=0 to High(Self) do
    Result[i] := MiddleTPA(Self[i]);
end;


function T2DPointArray.Equals(Other:T2DPointArray): Boolean;
var i:Int32;
begin
  if (Length(Self) <> Length(Other)) then Exit(False);
  if (Length(Self) = 0) then Exit(True);

  for i:=0 to High(self) do
    if not self[i].Equals(Other[i]) then
      Exit(False);
  Result := True;
end;

function T2DPointArray.Merge(): TPointArray; constref;
begin
  Result := MergeATPA(self);
end;


procedure T2DPointArray.FilterSize(MinLen:Int32; KeepIf:EComparator=__LT__);
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    case KeepIf of
      __LT__: if Length(TPA) < MinLen then tmp += TPA;
      __GT__: if Length(TPA) > MinLen then tmp += TPA;
      __EQ__: if Length(TPA) = MinLen then tmp += TPA;
      __NE__: if Length(TPA)<> MinLen then tmp += TPA;
    end;
  self := tmp;
end;

procedure T2DPointArray.FilterSize(MinLen,MaxLen:Int32); overload;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    if InRange(Length(TPA), MinLen, MaxLen) then
      tmp += TPA;
  self := tmp;
end;


function T2DPointArray.ExcludeSize(MinLen:Int32; KeepIf:EComparator=__LT__): T2DPointArray; constref;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    case KeepIf of
      __LT__: if Length(TPA) < MinLen then tmp += TPA;
      __GT__: if Length(TPA) > MinLen then tmp += TPA;
      __EQ__: if Length(TPA) = MinLen then tmp += TPA;
      __NE__: if Length(TPA)<> MinLen then tmp += TPA;
    end;
  Result := tmp;
end;

function T2DPointArray.ExcludeSize(MinLen,MaxLen:Int32): T2DPointArray; constref; overload;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    if InRange(Length(TPA), MinLen, MaxLen) then
      tmp += TPA;
  Result := tmp;
end;


procedure T2DPointArray.FilterDimensions(MinW, MinH: Int32; MaxW: Int32 = $FFFFFF; MaxH: Int32 = $FFFFFF);
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    with GetTPABounds(TPA) do
      if InRange(x2-x1+1, MinW, MaxW) and InRange(y2-y1+1, MinH, MaxH) then
        tmp += TPA;
  self := tmp;
end;

procedure T2DPointArray.SortByMiddle(From: TPoint);
begin
  SortATPAFromMidPoint(Self, From);
end;

procedure T2DPointArray.SortByIndex(From: TPoint; Index:Int32=0);
var
  i: Int32;
  weight: TIntegerArray;
begin
  if (Length(self) <= 1) then Exit;
  SetLength(weight, Length(self));
  for i:=0 to High(self) do
  begin
    if Length(Self[i]) = 0 then continue;
    weight[i] := Round(Sqr(From.x - self[i][Index].x) + Sqr(From.y - self[i][Index].y));
  end;
  QuickATPASort(weight, self, 0, High(self), True);
end;

procedure T2DPointArray.SortBySize(Size:Int32=0; ClosestFirst: Boolean=False);
begin
  SortATPAFromSize(Self, Size, ClosestFirst);
end;

procedure T2DPointArray.SortByArea(LowToHi: Boolean = False);
var
  i: Int32;
  weight: TIntegerArray;
begin
  if (Length(self) <= 1) then Exit;
  SetLength(weight, Length(self));
  for i:=0 to High(self) do
  begin
    if Length(Self[i]) = 0 then
      Continue;
    weight[i] := Self[i].MinAreaRect.Area;
  end;
  QuickATPASort(weight, self, 0, High(Self), LowToHi);
end;

procedure T2DPointArray.SortByLongSide(LowToHi: Boolean = False);
var
  i, Long, Short: Int32;
  weight: TIntegerArray;
begin
  if (Length(self) <= 1) then Exit;
  SetLength(weight, Length(self));
  for i:=0 to High(self) do
  begin
    if Length(Self[i]) = 0 then
      Continue;
    Self[i].MinAreaRectEx(Long, Short);
    weight[i] := Long;
  end;
  QuickATPASort(weight, self, 0, High(Self), LowToHi);
end;

procedure T2DPointArray.SortByDensity(LowToHi: Boolean = False);
var
  i: Int32;
  weight: TIntegerArray;
begin
  if (Length(self) <= 1) then Exit;
  SetLength(weight, Length(self));
  for i:=0 to High(self) do
  begin
    if Length(Self[i]) = 0 then
      Continue;

    weight[i] := Round(Self[i].Density * 100);
  end;
  QuickATPASort(weight, self, 0, High(Self), LowToHi);
end;

procedure T2DPointArray.SortByX(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  SetLength(Weights, Length(Self));
  for I := 0 to High(Weights) do
    Weights[I] := Self[I].Bounds.X1;

  QuickATPASort(Weights, Self, Low(Self), High(Self), LowToHi);
end;

procedure T2DPointArray.SortByY(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  SetLength(Weights, Length(Self));
  for I := 0 to High(Weights) do
    Weights[I] := Self[I].Bounds.Y1;

  QuickATPASort(Weights, Self, Low(Self), High(Self), LowToHi);
end;


//Credits to someone from SRL. IDK who sorry.
procedure T2DPointArray.WeightedSort(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean);
var
  lo, hi, mid: Int32;
begin
  if (Length(weights) <> Length(Self)) then Exit;
  lo := iLo;
  hi := iHi;
  mid := weights[(lo + hi) shr 1];
  repeat
    if sortUp then
    begin
      while (weights[lo] < mid) do Inc(lo);
      while (weights[hi] > mid) do Dec(hi);
    end
    else
    begin
      while (weights[lo] > mid) do Inc(lo);
      while (weights[hi] < mid) do Dec(hi);
    end;

    if (lo <= hi) then
    begin
      Swap(weights[lo], weights[hi]);
      Swap(Self[lo], Self[hi]);
      Inc(lo);
      Dec(hi);
    end;
  until lo > hi;

  if (hi > iLo) then Self.WeightedSort(weights, iLo, hi, sortUp);
  if (lo < iHi) then Self.WeightedSort(weights, lo, iHi, sortUp);
end;

function T2DPointArray.WeightSorted(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean): T2DPointArray; constref;
begin
  Result := Copy(Self);
  Result.WeightedSort(weights, iLo, iHi, sortUp);
end;


procedure T2DPointArray.SortByRow(reverse:Boolean=False);
var
  i,hi,w: Int32;
  weights: TIntegerArray;
  area : TBox;
  means: TPointArray;
begin
  hi := High(Self);
  if hi <= 1 then Exit;

  area := GetATPABounds(Self);
  w := area.X2 - area.X1 + 1;
  SetLength(weights, hi+1);
  means := Self.Means();

  for i := 0 to hi do
    weights[i] := means[i].Y * w + means[i].X;

  Self.WeightedSort(weights, 0, hi, not reverse);
end;

procedure T2DPointArray.SortByColumn(reverse:Boolean=False);
var
  i,hi,h: Int32;
  weights: TIntegerArray;
  area: TBox;
  means: TPointArray;
begin
  hi := High(Self);
  if hi <= 1 then Exit;

  area := GetATPABounds(Self);
  h := area.Y2 - area.Y1 + 1;
  SetLength(weights, hi+1);
  means := Self.Means();

  for i := 0 to hi do
    weights[i] := means[i].X * h + means[i].Y;

  Self.WeightedSort(weights, 0, hi, not reverse);
end;


procedure T2DPointArray.SortByXY(tolerance: Int32 = 0);
var
  hi, i, j: Int32;
  weights: TIntegerArray;
  means: TPointArray;
begin
  hi := High(Self);
  if hi <= 1 then Exit;

  SetLength(weights, hi + 1);
  means := Self.Means();

  for i := 0 to High(Self) do
  begin
    weights[i] := means[i].X + (means[i].Y * 1000);
    if tolerance = 0 then Continue;

    for j := 0 to High(Self) do
      if Abs(means[i].Y - means[j].Y) < tolerance then
        weights[i] := means[i].X + (means[j].Y * 1000);
  end;

  Self.WeightedSort(weights, 0, hi, True);
end;


function T2DPointArray.ToTBA(): TBoxArray; constref;
var
  i: Int32;
begin
  SetLength(Result, Length(self));
  for i := 0 to High(Self) do
    Result[i] := GetTPABounds(Self[i]);
end;

function T2DPointArray.InSameTPA(p, q: TPoint): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Bounds().ContainsAny([p, q]) then
      case Length(Self[i].Intersection([p, q])) of
        1: if p = q then Exit(True);
        2: Exit(True);
      end;
end;


function T2DPointArray.First(): TPointArray; constref;
begin
  if Self <> [] then
    Result := Self[0];
end;

function T2DPointArray.Last(): TPointArray; constref;
begin
  if Self <> [] then
    Result := Self[High(Self)];
end;


function T2DPointArray.Smallest(): TPointArray; constref;
var
  tpa: TPointArray;
begin
  for tpa in Self do
  begin
    if Result = [] then
      Result := tpa;

    if (Length(tpa) < Length(Result)) then
      Result := tpa;
  end;
end;

function T2DPointArray.Biggest(): TPointArray; constref;
var
  tpa: TPointArray;
begin
  for tpa in Self do
  begin
    if Result = [] then
      Result := tpa;

    if (Length(tpa) > Length(Result)) then
      Result := tpa;
  end;
end;


function T2DPointArray.Contains(const value: TPointArray): Boolean;
begin
  Result := Self.Find(value) > -1;
end;


function T2DPointArray.SortFrom(From: TPoint): T2DPointArray; constref;
begin
  Result := Self;
  SortATPAFromMidPoint(Result, From);
end;

function T2DPointArray.RandomValue(): TPointArray; constref;
begin
  if Length(Self) > 0 then
    Result := Self[Random(0, High(Self))];
end;
