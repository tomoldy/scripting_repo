{$DEFINE SCRIPT_ID := 'f8daec32-1d6f-4465-9634-ff12604b60ad'}
{$DEFINE SCRIPT_REVISION := '27'}
{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
{$I WaspLib/optional/handlers/discord.simba}
{$I WaspLib/optional/handlers/teleports/transport.simba}
{$I WaspLib/optional/handlers/farmrunner.simba}

{
----------------------------------------------------------------------------------
HAVE ISSUES?! Please report any issues in the script thread
with a screenshot with Simba AND RuneLite fully visible with
any sensitive information censored.
Script thread: https://discord.com/channels/795071177475227709/1397778362340081766
Screenshot example: https://i.imgur.com/WpSdEXF.jpeg
----------------------------------------------------------------------------------
}

var
  WEBHOOKURL: String                     = '';
  ENABLEWEBHOOKS: Boolean                = True;
  ENABLEWORLDHOPPING: Boolean            = True;
  WORLDHOPINTERVAL: Integer              = 45;
  SENDSESSIONSUMMARYMSG: Boolean         = True;
  SENDHOURLYREPORTMSG: Boolean           = True;
  ABLOSEFOCUS: Boolean                   = True;
  USEBOOSTS: Boolean                     = False;
  REPOTINTERVAL: Integer                 = 5;
  USEDHAROKS: Boolean                    = False;
  USESPECIALATTACKSGUI: Boolean          = False;
  USEDRAGONBATTLEAXEGUI: Boolean         = False;
  USEQUICKPRAYERSGUI: Boolean            = False;
  DHAROKSTARGETHPS: Integer              = 1;
  ENABLEPRAYERFLICK: Boolean             = False;
  STOPONDEGRADE: Boolean                 = False;
  OVERRIDEBREAKS: Boolean                = False;
  CUSTOMBREAKINTERVAL: Integer           = 60;
  CUSTOMBREAKDURATION: Integer           = 5;
  DEBUGMODE: Boolean                     = False;
  ENABLEBOLTENCHANTING: Boolean          = False;
  ENABLEFARMRUNS: Boolean                = False;

  // Farm Run Configuration
  FARMHERBSEED: Integer                  = 5; // Ranarr seed
  FARMFOWERSEED: Integer                 = 0; // None
  FARMALLOTMENTSEED: Integer             = 0; // None
  FARMCOMPOSTTYPE: Integer               = 2; // Ultra compost
  FARMCATHERBYTP: Integer                = 0; // Catherby teleport
  FARMHOSIDIUSTP: Integer                = 0; // Xeric's talisman
  FARMFARMGUILDTP: Integer               = 0; // Farming cape
  FARMRUNEPOUCH: Integer                 = 0; // None

  // Farm Patch Settings
  FARMWEISSHERB: Boolean                 = False;
  FARMSTRONGHOLDHERB: Boolean            = False;
  FARMARDOUGNEHERB: Boolean              = True;
  FARMFALADORHERB: Boolean               = True;
  FARMCATHERBYHERB: Boolean              = True;
  FARMPORTPHASMATYSHERB: Boolean         = True;
  FARMHOSIDIUSHERB: Boolean              = True;
  FARMFARMGUILDHERB: Boolean             = True;

  FARMHOSIDIUSFLOWER: Boolean            = False;
  FARMARDOUGNEFLOWER: Boolean            = False;
  FARMFALADORFLOWER: Boolean             = False;
  FARMCATHERBYFLOWER: Boolean            = False;
  FARMFARMGUILDFLOWER: Boolean           = False;

  FARMCATHERBYALLOTMENTN: Boolean        = False;
  FARMCATHERBYALLOTMENTS: Boolean        = False;
  FARMFARMGUILDALLOTMENTN: Boolean       = False;
  FARMFARMGUILDALLOTMENTS: Boolean       = False;

  FARMGIANTSEAWEEDN: Boolean             = False;
  FARMGIANTSEAWEEDS: Boolean             = False;
  FARMJUSTGIANTSEAWEED: Boolean          = False;
  FARMKANDARINBUSH: Boolean              = False;
  FARMFARMGUILDBUSH: Boolean             = False;
  FARMFARMGUILDCACTUS: Boolean           = False;

  FARMCLEANHERBS: Boolean                = True;
  FARMBARBDIBBER: Boolean                = False;
  FARMMAGICSECATEURS: Boolean            = False;

  STARTWITHFARMRUN: Boolean              = False;

type
  TRuneRequirements = record
    AirRunes: Int32;
    LawRunes: Int32;
    EarthRunes: Int32;
    FireRunes: Int32;
  end;

  GemStoneCrabSlayer = record(TBaseBankScript)
    InCombat: Boolean;
    IsAttacking: Boolean;
    LastHealthCheck: UInt64;

    StartXP: Int32;
    CurrentXP: Integer;

    UIPosition: TPoint;
    UISize: TPoint;
    UIEnabled: Boolean;

    UIFontSize: Int32;
    UIBackgroundColor: TColor;
    UITextColor: TColor;
    PrevXP: Integer;
    XPGained: Integer;
    LastHourlyReportTime: Int64;
    GainedXP: Integer;
    CurrentHP: Integer;
    CurrentBossHealth: Integer;

    GemStoneCrabNorth: TRSNPCV2;
    GemStoneCrabEast: TRSNPCV2;
    GemStoneCrabSouth: TRSNPCV2;
    Renu: TRSNPCV2;

    CaveNorth: TRSObjectV2;
    CaveEast: TRSObjectV2;
    CaveSouth: TRSObjectV2;

    ConsecutiveFailedAttacks: Int32;
    LastFailedAttackTime: UInt64;
    LastSuccessfulClick: Boolean;

    LastCaveExitTime: UInt64;

    ConsecutiveBlockedCaveAttempts: Int32;

    NextRepotTime: UInt64;
    LastRepotTime: UInt64;

    RunningTime: TStopWatch;
    ActiveTimer: TStopWatch;

    NextWorldHopTime: UInt64;
    WorldHopsCompleted: Int32;
    LastWorldHopTime: Int64;

    LastReportTime: UInt64;
    LastImageClear: UInt64;
    LastSystemUpdateCheck: UInt64;
    LastClearDebugTime: UInt64;
    SystemUpdateWarningShown: Boolean;

    ConsumableHandler: TConsumableHandler;

    UseFallbackMode: Boolean;

    LastHPReduction: UInt64;
    DharoksInitialized: Boolean;

    // Farm run variables
    FarmRun: TFarmRun;
    LastFarmRunTime: UInt64;
    FarmRunInProgress: Boolean;
    CompostNeeded: Int32;

    UseDragonBattleaxe: Boolean;
    DragonBattleaxeSlot: Int32;
    LastDragonBattleaxeUse: UInt64;
    NextDragonBattleaxeUse: UInt64;

    SpecialAttackEnabled: Boolean;
    SpecialAttackCost: Int32;
    SpecialAttackDiscovered: Boolean;
    LastSpecialAttackTime: UInt64;
    NextSpecialAttackThreshold: Int32;

    UseQuickPrayers: Boolean;

    PrayFlickTimer: TCountDown;
    PrayFlickEnabled: Boolean;

    LogFile: String;

    InventoryLoadout: TRSBankItemArray;
    HasSupplies: Boolean;
    BankingDisabled: Boolean;
    OutOfPotions: Boolean;
    OutOfFood: Boolean;
    OutOfPrayer: Boolean;
    HadFoodAtStart: Boolean;
    HadPrayerAtStart: Boolean;
    FoodHPThreshold: Int32;
    PrayerThreshold: Int32;
    MaxPrayerLevel: Int32;

    BankItems: TRSBankItemArray;
    FailedBankItems: TStringArray;

    ConsecutiveXPFailures: Int32;

    HasAccess: Boolean;

    AttackOptionChecked: Boolean;

    // Equipment check variables
    ArdyCloakEquipped: Boolean;
    FarmingCapeEquipped: Boolean;
    ConstructionCapeEquipped: Boolean;
    MagicSecsEquipped: Boolean;
    XericTaliEquipped: Boolean;
    LumbyRingEquipped: Boolean;

    // Infinite rune variables
    InfiniteWater: Boolean;
    InfiniteFire: Boolean;
    InfiniteEarth: Boolean;

    // Diary-specific teleports
    ArdyCloakName: String;
    LumbyRingName: String;

    LastBoltEnchantTime: UInt64;

    SRLTVersion: String;
    WaspLibVersion: String;
    UpdateAvailable: Boolean;
    LatestRevision: Int32;
    LastUpdateCheck: UInt64;
    RSWWalker: TRSWalker;
    Transport: TUniversalTransport;

  end;

var
  GemStoneCrabBot: GemStoneCrabSlayer;
  Discord: TDiscordClient;
  HandleConsumables: array[ERSConsumable] of Boolean;

function CompareVersions(version1, version2: String): Integer;
var
  parts1, parts2: TStringArray;
  i, num1, num2: Int32;
begin
  // Split versions by dots because 10 is less than 8 ok mate
  parts1 := version1.Split('.');
  parts2 := version2.Split('.');
  
  for i := 0 to Min(Length(parts1) - 1, Length(parts2) - 1) do
  begin
    num1 := StrToInt(parts1[i]);
    num2 := StrToInt(parts2[i]);
    
    if num1 < num2 then
      Exit(-1)
    else if num1 > num2 then
      Exit(1);
  end;
  
  if Length(parts1) < Length(parts2) then
    Exit(-1)
  else if Length(parts1) > Length(parts2) then
    Exit(1)
  else
    Exit(0);
end;

// Reworked to withdraw from search window and not do all that
function GemStoneCrabSlayer.WithdrawHelper(item: TRSItem; quant: Int32): Boolean;
var
  withdrawItem: TRSBankItem;
  attempts: Int32;
  I: Int32;
  itemBox: TBox;
begin
  if Inventory.ContainsItem(item) then
    Exit(True);

  if Inventory.CountEmptySlots() < 2 then
  begin
    writeln('[FARM] Ensure you have not selected to many patches/teleport options');
    writeln('[FARM] We need at least 1 empty slot for farm runs');
    TerminateScript('[FARM] Inventory has no empty slots to withdraw item' + item);
  end;

  WriteLn('[FARM] Attempting to withdraw ' + item);

  for I := 0 to High(Self.BankItems) do
  begin
    if Self.BankItems[I].Item = item then
    begin
      withdrawItem := Self.BankItems[I];
      Break;
    end;
  end;

  if withdrawItem.Item <> item then
  begin
    withdrawItem := TRSBankItem.Setup(item, quant, False);
    Self.BankItems += withdrawItem;
  end;

  withdrawItem.Quantity := quant;

  for attempts := 0 to 2 do
  begin
    // Find without search
    if Bank.FindItem(item, itemBox) then
    begin
      Result := Bank.WithdrawHelper(itemBox, quant, False, False);
    end
    else
    begin
      // type letter by letter and check for item
      Result := Self.ProgressiveBankSearch(item, itemBox);
      if Result then
      begin
        // Found weclick
        Result := Bank.WithdrawHelper(itemBox, quant, False, False);
      end;
    end;

    if Result then
    begin
      Result := Waituntil(Inventory.ContainsItem(item), 35, 3000);
      if Result then
        Break;
    end;

    if (attempts >= 2) and not Inventory.ContainsItem(item) then
    begin
      WriteLn('[FARM] Failed to withdraw "' + item + '" after 3 attempts');
      TerminateScript('Failed to withdraw "' + item + '" after 3 attempts');
    end;
  end;
end;

function GemStoneCrabSlayer.GetSpawnPoint(const ALocation: String): TPoint;
begin
  if (ALocation = 'North') then
    Result := Point(996, 37738)
  else if (ALocation = 'East') then
    Result := Point(1316, 37982)
  else
    Result := Point(860, 38258);
end;

function GemStoneCrabSlayer.DistanceToSpawn(const ALocation: String): Double;
var
  CurrentPos: TPoint;
begin
  CurrentPos := Map.Position;
  Result := CurrentPos.DistanceTo(Self.GetSpawnPoint(ALocation));
end;

// Override tores because it would click deposit all sometimes, so lets add an uptext check
function TRSBank.OpenSearch(waitTime: Int32 = 0): Boolean; override;
var
  searchButton: TRSButton;
begin
  searchButton := Self.GetButton(ERSBankButton.SEARCH);

  Mouse.Move(searchButton.Bounds);
  
  if MainScreen.IsUpText('Search') then
    Result := searchButton.Click() and Self.IsSearchOpen(waitTime)
  else
    Result := False;
end; 

// Fixed withdraw
function GemStoneCrabSlayer.ProgressiveBankSearch(item: TRSItem; out itemBox: TBox): Boolean;
var
  searchText: String;
  currentSearch: String;
  I, J: Int32;
begin
  Result := False;
  searchText := item;
  
  if not Bank.ClearSearch() then
  begin
    WriteLn('[FARM] Failed to clear existing search');
    Exit(False);
  end;
  
  if not Bank.OpenSearch(Random(2000, 2500)) then
  begin
    WriteLn('[FARM] Failed to open bank search interface');
    Exit(False);
  end;
  
  currentSearch := '';
  
  for I := 1 to Length(searchText) do
  begin
    currentSearch += searchText[I];
    
    Keyboard.Send(searchText[I]);
    Wait(Random(70, 100));
    
    if not Bank.IsSearchOpen(1200) then
    begin
      WriteLn('[FARM] Search closed unexpectedly, reopening and retyping...');
      
      if not Bank.ClearSearch() then
      begin
        WriteLn('[FARM] Failed to clear search during retry');
        Exit(False);
      end;
      
      if not Bank.OpenSearch(Random(2000, 2500)) then
      begin
        WriteLn('[FARM] Failed to reopen bank search interface');
        Exit(False);
      end;
      
      // Retype everything
      currentSearch := '';
      for J := 1 to I do
      begin
        currentSearch += searchText[J];
        Keyboard.Send(searchText[J]);
        Wait(Random(70, 100));
      end;
    end;
    
    if Bank.FindItem(item, itemBox) then
    begin
      // Antiban: Sometimes type extra letters
      {if (SRL.Dice(30)) and (I < Length(searchText)) then
      begin
        // Type 1-2 extra letters
        extraLetters := Random(1, 3);
        for j := 1 to extraLetters do
        begin
          if (I + j) <= Length(searchText) then
          begin
            currentSearch += searchText[I + j];
            Keyboard.Send(searchText[I + j]);
            Wait(Random(70, 100));
            Bank.FindItem(item, itemBox);
          end;
        end;
      end;}
      
      Result := True;
      WriteLn('[FARM] Found item "' + item + '" after typing: "' + currentSearch + '"');
      Exit;
    end;
  end;
  
  WriteLn('[FARM] Item "' + item + '" not found even after typing full name');
end;

procedure GemStoneCrabSlayer.SetupObjects();
begin
  writeln('[MAP] Setting up objects...');

  with GemStoneCrabNorth do
  begin
    GemStoneCrabNorth.Finder.Colors := [CTS2(3635624, 36, 0.28, 1.25)];
    GemStoneCrabNorth.Walker := @Map.Walker;
    GemStoneCrabNorth.SetupEx([5], [6, 6, 5], [[996, 37738]]);
    GemStoneCrabNorth.SetupUpText('Attack');
    GemStoneCrabNorth.Filter.Minimap := True;
    GemStoneCrabNorth.DotType := ERSMinimapDot.NPC;
  end;

  with GemStoneCrabEast do
  begin
    GemStoneCrabEast.Finder.Colors := [CTS2(3635624, 36, 0.28, 1.25)];
    GemStoneCrabEast.Walker := @Map.Walker;
    GemStoneCrabEast.SetupEx([5], [6, 6, 5], [[1316, 37982]]);
    GemStoneCrabEast.SetupUpText('Attack');
    GemStoneCrabEast.Filter.Minimap := True;
    GemStoneCrabEast.DotType := ERSMinimapDot.NPC;
  end;

  with GemStoneCrabSouth do
  begin
    GemStoneCrabSouth.Finder.Colors := [CTS2(3635624, 36, 0.28, 1.25)];
    GemStoneCrabSouth.Walker := @Map.Walker;
    GemStoneCrabSouth.SetupEx([5], [6, 6, 5], [[860, 38258]]);
    GemStoneCrabSouth.SetupUpText('Attack');
    GemStoneCrabSouth.Filter.Minimap := True;
    GemStoneCrabSouth.DotType := ERSMinimapDot.NPC;
  end;

  with CaveNorth do
  begin
    CaveNorth.Walker := @Map.Walker;
    CaveNorth.Finder.Colors := [CTS2(5992046, 7, 0.13, 0.13)];
    CaveNorth.SetupEx([2, 2, 6], [[1020, 37758]]);
    CaveNorth.SetupUpText('Cave');
  end;

  with CaveEast do
  begin
    CaveEast.Walker := @Map.Walker;
    CaveEast.Finder.Colors := [CTS2(5992046, 7, 0.13, 0.13)];
    CaveEast.SetupEx([2, 2, 6], [[1312, 37934]]);
    CaveEast.SetupUpText('Cave');
  end;

  with CaveSouth do
  begin
    CaveSouth.Walker := @Map.Walker;
    CaveSouth.Finder.Colors := [CTS2(5992046, 7, 0.13, 0.13)];
    CaveSouth.SetupEx([2, 2, 6], [[892, 38286]]);
    CaveSouth.SetupUpText('Cave');
  end;

  with Renu do
  begin
    Renu.Walker := @Map.Walker;
    Renu.Finder.Colors := [CTS2(9809513, 14, 0.16, 1.68)];
    Renu.SetupEx([4], [3, 3, 4], [[2692, 37862]]);
    Renu.SetupUpText('Travel');
    Renu.Filter.Minimap := True;
    Renu.DotType := ERSMinimapDot.NPC;
  end;

  writeln('[MAP] Objects setup complete');
end;

procedure GemStoneCrabSlayer.CheckForUpdates(forceCheck: Boolean = True);
var
  currentRevision: Int32;
  maxRetries, retryCount: Int32;
  response: String;
  revisionStr: String;
  currentTime: UInt64;
  timeSinceLastCheck: UInt64;
begin
  try
    currentTime := GetTickCount();

    // We will check every 24hours for a script update for long proggers
    if not forceCheck then
    begin
      if Self.LastUpdateCheck > 0 then
      begin
        timeSinceLastCheck := currentTime - Self.LastUpdateCheck;
        if timeSinceLastCheck < 86400000 then
          Exit;
      end;
    end;

    Self.UpdateAvailable := False;
    Self.LatestRevision := -1;

    if not APIClient.IsSetup then
      Exit;

    maxRetries := 3;
    retryCount := 0;

    while retryCount < maxRetries do
    begin
      try
        response := APIClient.GET('simba/revision/' + {$MACRO SCRIPT_ID}, False);

        if response.Contains('"revision":') then
        begin
          revisionStr := response.After('"revision":').Before('}');
          Self.LatestRevision := StrToInt(revisionStr);
          Break;
        end;
      except
        //
      end;

      Inc(retryCount);
      if retryCount < maxRetries then
        Wait(1000, 2000);
    end;

    if Self.LatestRevision = -1 then
      Exit;

    Self.LastUpdateCheck := currentTime;

    currentRevision := StrToInt({$MACRO SCRIPT_REVISION});

    if Self.LatestRevision > currentRevision then
    begin
      Self.UpdateAvailable := True;
      WriteLn('========================================');
      WriteLn('SCRIPT UPDATE AVAILABLE!');
      WriteLn('Current version: ' + {$MACRO SCRIPT_REVISION});
      WriteLn('Latest version: ' + ToStr(Self.LatestRevision));
      WriteLn('========================================');
    end;
  except
    Self.UpdateAvailable := False;
    Self.LatestRevision := -1;
  end;
end;

// DTM Dots from Vard to improve detection as Timage one fails
function GetEnhancedNPCDots(): TPointArray;
const
  NPC_DTM1: Int64 := DTMFromString('mQwAAAHicY2ZgYGhnguAOIA4G8kOBOASI374FEgyMUIwAjKiiANXeBHs=');
  NPC_DTM2: Int64 := DTMFromString('mQwAAAHicY2ZgYKhnguA6IA4A8gMZIPTdu0CCgRGKEYARVRQAyRcENg==');
  NPC_DTM3: Int64 := DTMFromString('mQwAAAHicY2ZgYGhgguBGIPYD8n0ZIPTXrwwM//7xMdy9y4ACGJEwEAAASrQIJQ==');
  NPC_DTM4: Int64 := DTMFromString('mQwAAAHicY2ZgYKhnguA6IPYD8n0ZIPSfP0wM//4JgzEyYETCQAAAVqMIig==');
  NPC_DTM5: Int64 := DTMFromString('mQwAAAHicY2ZgYGhgYmBohOIQID8MiIOA+M8foAADI8O/f8IMyIARCQMBABS6BpU=');
  NPC_DTM6: Int64 := DTMFromString('mQwAAAHicY2ZgYGhhguBWIA4B8sOg+M8foAADIxQjACOqKADZUASW');
  NPC_DTM7: Int64 := DTMFromString('mQwAAAHicY2ZgYGhhguBmIA4G8kOBOAiI794FEgyMDP/+8TEgA0YkDAQADEUGVw==');
var
  TempPoints, AllPoints: TPointArray;
  SearchArea: TBox;
  I, J: Integer;
  TooClose: Boolean;
begin
  Result := [];
  SearchArea := Minimap.Bounds.Expand(-15);

  try
    // Collect all DTM results
    if FindDTMs(NPC_DTM1, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM2, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM3, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM4, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM5, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM6, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;
    if FindDTMs(NPC_DTM7, TempPoints, SearchArea) then AllPoints := AllPoints + TempPoints;

    // Filter duplicates
    for I := 0 to High(AllPoints) do
    begin
      TooClose := False;
      for J := 0 to High(Result) do
        if AllPoints[I].DistanceTo(Result[J]) < 8 then
        begin
          TooClose := True;
          Break;
        end;
      if not TooClose then
        Result := Result + [AllPoints[I]];
    end;

  finally
    FreeDTM(NPC_DTM1); FreeDTM(NPC_DTM2); FreeDTM(NPC_DTM3); FreeDTM(NPC_DTM4);
    FreeDTM(NPC_DTM5); FreeDTM(NPC_DTM6); FreeDTM(NPC_DTM7);
  end;
end;

// Override tors
{function TRSNPCV2.IsVisible(): Boolean; override;
var
  NPCDots: TPointArray;
  NPCDot, NPCCoord: TPoint;
  CurrentDistance: Double;
begin
  // Try his
  Result := inherited();
  if Result then Exit;

  // Fall back to my better one
  NPCDots := GetEnhancedNPCDots();
  if Length(NPCDots) = 0 then Exit;

  for NPCCoord in Self.Coordinates do
    for NPCDot in NPCDots do
    begin
      CurrentDistance := Map.Map2MM(NPCCoord).DistanceTo(NPCDot);
      if CurrentDistance <= 45.0 then
        Exit(True);
    end;
end;}

// Bootie overrides to fix broken shit becuase wasp are cry babies
function TRSLogin.LoginPlayer(): Boolean; override;
var
  attempts, world: Int32;
  timeout: UInt64;
  player: TRSLoginPlayer;
  isLauncher: Boolean;
begin
  WriteLn('Logging in player');

  timeout := GetTickCount() + 40000;

  while not Self.IsReady() do
  begin
    if Self.FindText('CLICK HERE TO PLAY') then
      Exit(Self.EnterGame());

    if Self.HandleDialogs() then
      Wait(500);

    if GetTickCount() > timeout then
    begin
      WriteLn('Timed out waiting for the loginscreen to be ready.');
      Exit;
    end;
  end;

  player := Self.GetPlayer();
  isLauncher := Self.UsingLauncher();

  if isLauncher then
    WriteLn('Jagex Launcher login detected.')
  else
  begin
    WriteLn('Legacy login detected.');
    if (player.User = '') or (player.Password = '') then
      Self.Fatal('Player has no username or password');
  end;

  while Self.IsOpen() and (attempts < 10) do
  begin
    WriteLn('Attempt ' + ToString(attempts + 1));

    if player.Worlds <> [] then
      if not (Self.GetCurrentWorld() in player.Worlds) or SRL.Dice(30) then
      begin
        world := Player.Worlds[Random(Length(Player.Worlds))];
        if (not Self.SwitchToWorld(world)) then
        begin
          Self.CloseWorldSwitcher();
          Exit;
        end;
      end;

    if Self.HandleDialogs() then
      Wait(500);

    if Self.DoLogin(player, isLauncher) and not Self.WaitLoginMessage() then
      Exit;

    Inc(attempts);
  end;
  Result := Self.EnterGame();
end;
// love you bootie

// More overrides so walker just doesn't crash tf
function TWebGraphV2.FindObjectPath(me: TPoint; out p: TPoint): TPointArray; override;
var
  i: Int32;
  cluster, best: TPointArray;
begin
  if Self.UseCollisionData then
  begin
    for i := 0 to High(Self.WalkableClusters) do
      if Self.WalkableClusters[i].Contains(me) then
        cluster := Self.WalkableClusters[i];

    if cluster = [] then
      RaiseException(SRL.TimeStamp() + ':[WebGraph]:[Fatal]: Can''t find player cluster containg: ' + me.ToString());
  end;

  best := Self.FindNearestNodesEx(p, 12);
  for i := 0 to High(best) do
  begin
    p := best[i];

    if not Self.UseCollisionData or cluster.Contains(p) then
    begin
      try
        Result := Self.PathBetweenEx(me, p, 0.2, 2);
        if Result = [] then
        begin
          if me.InRange(p, 52) then Exit([p]);
          exit;
          //RaiseException('Path empty');
        end;
      except
        if me.InRange(p, 52) then Exit([p]);
        exit;
        //RaiseException(SRL.TimeStamp() + ':[WebGraph]:[Fatal]: Can''t find a walkable path to ' + p.ToString() + ' object.');
      end;
      Break;
    end;
  end;
end;

function FormatRoundedNumber(Number: Integer): String;
begin
  if Number >= 1000000 then
    Result := FormatFloat('0.0M', Number / 1000000)
  else if Number >= 1000 then
    Result := FormatFloat('0K', Number / 1000)
  else
    Result := SRL.FormatNumber(Number);
end;

// Override to remove logout chance when in combat
procedure TAntiban.TakeBreak(var task: TBreakTask); override;
var
  countdown: TCountDown;
  i: Int32;
  activeTasks: PAntibanTaskArray;
begin
  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Pause();

  countdown.Init(Abs(Round(SRL.GaussRand(task.Length, task.Length * task.StdVar))));

  WriteLn('Taking a break for ' + SRL.MsToTime(countdown.TimeRemaining(), TIME_FORMAL));

  if GemStoneCrabBot.UseQuickPrayers and Minimap.IsPrayerEnabled() then
  begin
    WriteLn('[PRAYER] Disabling quick prayers during break');
    Minimap.EnablePrayer();
  end;

  if (@Self.OnStartBreak <> nil) then
    Self.OnStartBreak(@task);

  if not (GemStoneCrabBot.InCombat or GemStoneCrabBot.IsAttacking) then
  begin
    if Random() < task.LogoutChance then
    begin
      WriteLn('Logging out');
      Logout.ClickLogout();
    end;
  end
  else
  begin
    WriteLn('In combat - skipping logout chance');
  end;

  if Random() < 0.50 then
    Self.LoseFocus();

  i := 0;
  while not countdown.IsFinished() do
  begin
    if (Inc(i) mod 12 = 0) then
      WriteLn('Break time remaining: ' + ToString(countdown.TimeRemaining() div 60000) + ' minutes');

    if (@Self.OnBreaking <> nil) then
      Self.OnBreaking(@task, countdown);

    Wait(Min(countdown.TimeRemaining(), 5 * ONE_SECOND));
  end;

  WriteLn('Break finished');

  if (@Self.OnFinishBreak <> nil) then
    Self.OnFinishBreak(@task);

  // Offset all tasks & breaks
  for i := 0 to High(Self.Breaks) do
    Self.Breaks[i].NextAtTime += GetTickCount() - (countdown.Timeout - countdown.Length);

  for I := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Resume();

  // Setup next time this break happens
  task.NextAtTime := GetTimeRunning() + Abs(SRL.GaussRand(task.Interval, task.Interval * task.StdVar));
end;

// Override DoAntiban to support my custom breaks if built-in breaks are disabled
function TBaseScript.DoAntiban(checkBreaks: Boolean = True; checkSleeps: Boolean = True): Boolean; override;
begin
  Antiban.DismissRandom();
  Self.TimeRunning.Pause();
  Self.OnAntiban := True;

  checkBreaks := checkBreaks and (WLSettings.GetObject('antiban').getBoolean('breaks') or OVERRIDEBREAKS);
  checkSleeps := checkSleeps and WLSettings.GetObject('antiban').getJSONObject('sleep').getBoolean('enabled');

  if WLSettings.GetObject('antiban').getJSONObject('tasks').getBoolean('enabled') or checkBreaks or checkSleeps then
    Result := Antiban.DoAntiban(checkBreaks, checkSleeps);

  Self.TimeRunning.Resume();
  Self.OnAntiban := False;

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();
end;

// Some camera angles cause XP Bar read to fail and terminate, override to remove terminations etc
function TRSXPBar.Read(): Int64; override;
var
  xpStr: String;
begin
  if not Self.IsSetup then
    Self._Setup();

  if not Self.IsSetup or not Self.Enable() then
    Exit;

  xpStr := OCR.Recognize(Self.Bounds, TOCRColorFilter.Create([$FFFFFF]), Self.Font);
  Result := xpStr.ExtractInteger(0);

  Self.Tracker.IsSetup := (Result > 0) and (Result >= Self.Tracker.Current);

  if not Self.Tracker.IsSetup and (Self.Tracker.Current = 0) and RSInterface.IsOpen() then
    if RSInterface.Close() then
    begin
      Self.IsSetup := False;
      Exit(Self.Read());
    end;

  if Self.Tracker.IsSetup then
  begin
    if Self.Tracker.Start = 0 then
      Self.Tracker.Start := Result;

    if (Self.Tracker.Current = 0) or (Result > Self.Tracker.Current) then
      Self.Tracker.Current := Result;

    Exit;
  end;
end;

function GemStoneCrabSlayer.IsOutOfAmmo(): Boolean;
var
  Messages: String;
  I: Int32;
begin
  Result := False;

  for I := 0 to CHAT_INPUT_LINE - 1 do
    Messages += Chat.GetMessage(I, [CHAT_COLOR_BLACK]);

  // Check for message
  Result := Messages.ContainsAny([
    'out of ammo',        // General ammo message
    'no charges',         // Magic weapons/trident
    'last one',            // Darts/throwing weapons
    'degraded'            // Dharoks armour
  ]);

  if Result then
    WriteLn('Out of ammo detected in chat messages');
end;

function GemStoneCrabSlayer.TryEnchantBolts(): Boolean;
var
  CurrentTime: UInt64;
begin
  Result := False;

  if not ENABLEBOLTENCHANTING then
    Exit;

  if not self.InCombat or not self.IsAttacking then
    Exit;

  CurrentTime := GetTickCount();
  if (CurrentTime - Self.LastBoltEnchantTime) < 300 then
    Exit;

  if not Magic.IsOpen() then
  begin
    if not Magic.Open() then
    begin
      WriteLn('[BOLT ENCHANTING] Failed to open magic interface');
      Exit;
    end;
    Wait(200, 400);
  end;

  if not Magic.CanActivate(ERSSpell.ENCHANT_CROSSBOW_BOLT) then
  begin
    WriteLn('[BOLT ENCHANTING] Cannot cast Enchant Crossbow Bolt - out of runes or bolts');
    ENABLEBOLTENCHANTING := False;
    Exit;
  end;

  if Chat.FindMessage('no bolts', [CHAT_COLOR_BLACK]) or Chat.FindMessage('not have enough', [CHAT_COLOR_BLACK]) then
  begin
    WriteLn('[BOLT ENCHANTING] Chat message for bolts - disabling bolt enchanting');
    ENABLEBOLTENCHANTING := False;
    Exit;
  end;

  KeyDown(VK_SPACE);

  if Magic.ClickSpell(ERSSpell.ENCHANT_CROSSBOW_BOLT) then
  begin
    Result := True;

    Self.LastBoltEnchantTime := GetTickCount();
  end
  else
  begin
    WriteLn('[BOLT ENCHANTING] Failed to cast Enchant Crossbow Bolt');
  end;

  KeyUp(VK_SPACE);
end;

function GemStoneCrabSlayer.CheckForDegradation(): Boolean;
var
  Messages: String;
  I: Int32;
begin
  Result := False;

  if not USEDHAROKS or not STOPONDEGRADE then
    Exit;

  for I := 0 to CHAT_INPUT_LINE - 1 do
    Messages += Chat.GetMessage(I, [CHAT_COLOR_BLACK]);

  // Replace with actual words when we find out
  if Messages.ContainsAny(['Degrade', 'degrade', 'DEGRADE']) then
  begin
    WriteLn('Dharoks armour degradation detected!');

    if ENABLEWEBHOOKS then
    begin
      try
        Discord.Webhook.Content := '**DHAROKS ARMOUR DEGRADED** :warning: Your Dharoks armour has degraded and the script will terminate.';
        Discord.SendScreenshot(False);
      except
        WriteLn('[Discord] Failed to send degradation notification');
      end;
    end;

    if STOPONDEGRADE then
    begin
      WriteLn('Stop on degrade enabled - terminating script');
      Self.TakeScreenshot('_DharoksDegraded');
      Logout.ClickLogout();
      TerminateScript('Dharoks armour degraded');
    end;

    Result := True;
  end;
end;

function GemStoneCrabSlayer.ShouldReduceHP(): Boolean;
var
  CurrentHP: Int32;
  TimeSinceLastReduction: UInt64;
  TargetHP: Int32;
begin
  Result := False;

  if not USEDHAROKS then
    Exit;

  CurrentHP := Minimap.GetHPLevel();
  TimeSinceLastReduction := GetTickCount() - Self.LastHPReduction;
  TargetHP := DHAROKSTARGETHPS;

  if Self.LastHPReduction = 0 then
  begin
    if CurrentHP > TargetHP then
    begin
      if TimeSinceLastReduction > 3000 then
        Result := True;
    end;
  end
  else
  begin
    if CurrentHP > TargetHP then
    begin
      if TimeSinceLastReduction > 3000 then
      begin
        WriteLn('Dharoks: HP at ', CurrentHP, ' is above target ', TargetHP, ' - reducing to target');
        Result := True;
      end;
    end;
  end;
end;

function GemStoneCrabSlayer.TryReduceHP(): Boolean;
var
  Slot: Int32;
  CurrentHP: Int32;
  AttemptsLeft: Int32;
  ExpectedDamage: Int32;
  TargetHP: Int32;
begin
  Result := False;

  if not USEDHAROKS then
    Exit;

  CurrentHP := Minimap.GetHPLevel();
  TargetHP := DHAROKSTARGETHPS;

  if CurrentHP <= TargetHP then
  begin
    WriteLn('Already at or below target HP (', CurrentHP, ' <= ', TargetHP, ')');
    Exit(True);
  end;

  WriteLn('Dharoks: Reducing HP from ', CurrentHP, ' to target ', TargetHP, ' or lower...');

  if not Inventory.IsOpen() then
    Inventory.Open();

  AttemptsLeft := 40;

  while (Minimap.GetHPLevel() > TargetHP) and (AttemptsLeft > 0) do
  begin
    CurrentHP := Minimap.GetHPLevel();

    // Try Locator orb
    if Inventory.FindItem('Locator orb', Slot) then
    begin
      WriteLn('Using Locator orb to reduce HP (10 damage per click)');
      if Inventory.ClickSlot(Slot) then
      begin
        Wait(800, 1200);
        Self.LastHPReduction := GetTickCount();
        Dec(AttemptsLeft);
        Continue;
      end;
    end
    // Try Dwarven rock cake
    else if Inventory.FindItem('Dwarven rock cake', Slot) then
    begin
      ExpectedDamage := Ceil(CurrentHP * 0.1); // 10% of current HP, rounded up according to wiki
      if ExpectedDamage < 1 then ExpectedDamage := 1;

      // When HP = 2, we need to use "Guzzle" to get 1 damage
      if (ExpectedDamage = 1) and (CurrentHP > 2) then
      begin
        WriteLn('Using Dwarven rock cake (Eat)');
        if Inventory.ClickSlot(Slot, 'Eat') then
        begin
          Wait(800, 1200);
          Self.LastHPReduction := GetTickCount();
          Dec(AttemptsLeft);
          Continue;
        end;
      end
      else
      begin
        WriteLn('Using Dwarven rock cake (Guzzle) to reduce HP (', ExpectedDamage, ' damage expected)');
        if Inventory.ClickSlot(Slot, 'Guzzle') then
        begin
          Wait(800, 1200);
          Self.LastHPReduction := GetTickCount();
          Dec(AttemptsLeft);
          Continue;
        end
        else
        begin
          WriteLn('Guzzle failed, trying Eat option (1 damage per click)');
          if Inventory.ClickSlot(Slot, 'Eat') then
          begin
            Wait(800, 1200);
            Self.LastHPReduction := GetTickCount();
            Dec(AttemptsLeft);
            Continue;
          end;
        end;
      end;
    end
    else
    begin
      WriteLn('ERROR: No HP reduction items found in inventory!');
      WriteLn('Please ensure you have either a "Locator orb" or "Dwarven rock cake" in your inventory.');
      USEDHAROKS := False;
      Exit(False);
    end;

    WriteLn('Failed to click HP reduction item, retrying...');
    Dec(AttemptsLeft);
  end;

  if Minimap.GetHPLevel() <= TargetHP then
  begin
    WriteLn('Successfully reduced HP to ', Minimap.GetHPLevel(), ' (at or below target ', TargetHP, ')');
    Self.IsAttacking := False;
    Self.InCombat := False;
    Result := True;
  end
  else
  begin
    WriteLn('Failed to reduce HP to target, current HP: ', Minimap.GetHPLevel());
    if AttemptsLeft <= 0 then
      WriteLn('Stopped due to safety limit');
  end;
end;

function GemStoneCrabSlayer.InitializeDharoks(): Boolean;
begin
  Result := False;

  if not USEDHAROKS then
    Exit(True);

  if Self.DharoksInitialized then
    Exit(True);

  WriteLn('Initializing Dharoks setup...');

  // Check if we have the required items
  if not Inventory.IsOpen() then
    Inventory.Open();

  if not (Inventory.ContainsItem('Locator orb') or Inventory.ContainsItem('Dwarven rock cake')) then
  begin
    WriteLn('ERROR: Dharoks mode enabled but no HP reduction items found!');
    WriteLn('Please add either a "Locator orb" or "Dwarven rock cake" to your inventory.');
    USEDHAROKS := False;
    Exit(False);
  end;

  // Reduce HP to target range initially
  if Self.TryReduceHP() then
  begin
    Self.DharoksInitialized := True;
    WriteLn('Dharoks setup complete - ready for combat at target HP ', DHAROKSTARGETHPS, ' or lower!');
    Result := True;
  end
  else
  begin
    WriteLn('Failed to initialize Dharoks setup');
    USEDHAROKS := False;
  end;
end;

function GemStoneCrabSlayer.GetRandomWorldHopTime(): UInt64;
var
  BaseInterval: UInt64;
  RandomVariation: Integer;
begin
  BaseInterval := WORLDHOPINTERVAL * 60000;

  // 10% random variation to the interval eitherside
  RandomVariation := Random(-10, 10);
  Result := BaseInterval + Round(BaseInterval * (RandomVariation / 100.0));

  WriteLn('Next world hop scheduled in: ' + SRL.MsToTime(Result, Time_Short) +
          ' (Base: ' + IntToStr(WORLDHOPINTERVAL) + 'min, Variation: ' + IntToStr(RandomVariation) + '%)');
end;

procedure GemStoneCrabSlayer.SetupWorldHopping();
begin
  WriteLn('[ANTIBAN] Setting up world hopping...');

  if not ENABLEWORLDHOPPING then
  begin
    WriteLn('[ANTIBAN] World hopping is disabled.');
    Exit;
  end;

  if Length(Login.GetPlayer().Worlds) < 2 then
  begin
    WriteLn('[ANTIBAN] ERROR: World hopping is enabled but you have less than 2 worlds configured!');
    WriteLn('Please configure at least 2 worlds in your player setup or disable world hopping.');
    Logout.ClickLogout();
    TerminateScript();
  end;

  Self.NextWorldHopTime := GetTickCount() + Self.GetRandomWorldHopTime();
  WriteLn('[ANTIBAN] World hopping enabled. Next hop in: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short));
end;

function GemStoneCrabSlayer.ShouldHopWorld(): Boolean;
var
  TimeSinceLastCombat: UInt64;
  RequiredCombatCooldown: UInt64;
  TimeToWait: UInt64;
begin
  if not ENABLEWORLDHOPPING then
    Exit(False);

  // Don't try to hop if we're currently in combat
  if Self.InCombat or Self.IsAttacking then
    Exit(False);

  // Check if it's time to hop
  if GetTickCount() < Self.NextWorldHopTime then
    Exit(False);

  if Self.UseQuickPrayers and Minimap.IsPrayerEnabled() then
  begin
    WriteLn('[PRAYER] Disabling quick prayers.');
    Minimap.DisablePrayer();
  end;

  TimeSinceLastCombat := GetTickCount() - Self.LastHealthCheck;

  // Require 20-30 seconds out of combat before allowing world hop for combat drop
  RequiredCombatCooldown := Random(20000, 30000); // 20-30 seconds

  if TimeSinceLastCombat < RequiredCombatCooldown then
  begin
    TimeToWait := RequiredCombatCooldown - TimeSinceLastCombat;
    WriteLn('Waiting ' + IntToStr(TimeToWait div 1000) + ' seconds out of combat before hopping...');
    Wait(TimeToWait);
  end;

  Result := True;
end;

procedure GemStoneCrabSlayer.DoWorldHop();
var
  currentWorld: Int32;
  playerWorlds: TIntegerArray;
  targetWorld: Int32;
  availableWorlds: TIntegerArray;
  i: Int32;
begin
  if not ENABLEWORLDHOPPING then
    Exit;

  if Self.InCombat or Self.IsAttacking then
  begin
    WriteLn('Skipping world hop - currently in combat');
    Exit;
  end;

  Self.CheckSystemUpdate();

  WriteLn('Time to hop worlds!');

  playerWorlds := Login.GetPlayer().Worlds;

  if not Logout.Open() then
  begin
    WriteLn('Failed to open logout menu');
    Self.NextWorldHopTime := GetTickCount() + 120000;
    Exit;
  end;

  if not Logout.IsWorldSwitcherOpen() then
    Logout.GetButton(ERSLogoutButton.WORLD_SWITCHER).Click(MOUSE_LEFT);
  WaitUntil((currentWorld := WorldHopper.GetCurrentWorld()) <> 0, 65, 20000);

  WriteLn('Current world: ' + ToStr(currentWorld));
  WriteLn('Available worlds: ' + ToStr(playerWorlds));

  availableWorlds := [];
  for i := 0 to High(playerWorlds) do
  begin
    if playerWorlds[i] <> currentWorld then
      availableWorlds += playerWorlds[i];
  end;

  if Length(availableWorlds) = 0 then
  begin
    WriteLn('No other worlds available to hop to, disabling world hopping!');
    ENABLEWORLDHOPPING := False;
    Exit;
  end;

  targetWorld := availableWorlds[Random(Length(availableWorlds))];
  WriteLn('Randomly selected target world: ' + ToStr(targetWorld));

  if WorldHopper.Hop([targetWorld]) then
  begin
    WriteLn('Successfully hopped to world ' + ToStr(targetWorld) + '!');

    Inc(Self.WorldHopsCompleted);
    Self.LastWorldHopTime := GetTickCount();

    Self.NextWorldHopTime := GetTickCount() + Self.GetRandomWorldHopTime();
    WriteLn('Next world hop in: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short));
  end
  else
  begin
    WriteLn('World hop to ' + ToStr(targetWorld) + ' failed, trying again in 2 minutes');
    Self.NextWorldHopTime := GetTickCount() + 120000;
  end;
end;

// Thanks Bootie
function TRSChat.CheckSystemUpdate(minuteTreshold: Integer): Boolean;
var
  b: TBox;
  s: String;
  numbers: TExtendedArray;
begin
  b := Chat.Bounds;
  b.X1 += 4;
  b.Y1 -= 16;
  b.Y2 := Chat.Bounds.Y1 -1;
  b.X2 := b.X1 + 140;

  s := OCR.Recognize(
      b,
      TOCRColorFilter.Create([65535]),
      RS_FONT_PLAIN_12
    );

  if s.Contains('System update') then
  begin
    s := s.After(': ');
    numbers := s.ExtractNumbers();
    if (length(numbers) > 0) and (numbers[0] <= minuteTreshold) then
      Result := True;
  end;
end;

procedure OnBreakStart(Task: PBreakTask);
begin
  GemStoneCrabBot.ActiveTimer.Pause();
  WL.Activity.Pause();
end;

procedure OnBreakFinish(Task: PBreakTask);
begin
  GemStoneCrabBot.ActiveTimer.Resume();
  WL.Activity.Resume();
end;

procedure OnSleepStart(Task: PSleepTask);
begin
  GemStoneCrabBot.ActiveTimer.Pause();
  WL.Activity.Pause();
end;

procedure OnSleepFinish(Task: PSleepTask);
begin
  GemStoneCrabBot.ActiveTimer.Resume();
  WL.Activity.Resume();
end;

// More overrides
procedure TAntiban.AdjustZoom(); override;
var
  zoom, newZoom: Int32;
  attempts: Int32;
begin

  if (Self.MaxZoom = 0) then
  begin
    WriteLn('No maximum zoom set, using default value of 100');
    Self.MaxZoom := 15;
  end;

  if RSInterface.IsOpen() then
    Exit;

  zoom := EnsureRange(MM2MS.GetZoomLevel(), Self.MinZoom, Self.MaxZoom);

  repeat
    Inc(attempts);
    if attempts > 100 then
      Exit;

    newZoom := EnsureRange(SRL.SkewedRand(zoom, Self.MinZoom, Self.MaxZoom), Self.MinZoom, Self.MaxZoom);
  until Abs(zoom - newZoom) > Min(15, (Self.MinZoom - Self.MaxZoom) div 2);

  //WriteLn('Adjust zoom: ' + ToString(newZoom));
  RSMouseZoom.SetZoomLevel(newZoom);
end;

// Disablechat antiban becaUse of chatbot and like who does this
procedure TAntiban.RandomChatTask(); override;
begin
  Exit;
end;

// Check after our doAntiban if we have put the mouse in a shit spot
procedure TAntiban.HandleFinishTask(Task: PAntibanTask);
var
  MousePos: TPoint;
  GlobeButton: TBox;
  YellowChatbox: TPointArray;
begin
  MousePos := Mouse.Position();
  GlobeButton := ([715, 120, 745, 148]);
  
  if GlobeButton.Contains(MousePos) then
  begin
    WriteLn('[ANTIBAN] Mouse detected on globe button (', MousePos.X, ', ', MousePos.Y, '), moving to mainscreen');
    Mouse.Move(Mainscreen.Bounds);
  end;

  // Final Check
  SRL.FindColors(YellowChatbox, CTS2(10551295, 1, 0.01, 0.01), Minimap.Bounds);
  if Length(YellowChatbox) > 2000 then
  begin
    WriteLn('[ANTIBAN] Yellow chatbox detected on minimap, waiting 2 seconds');
    Wait(2000);
  end;
end;

procedure TAntiban.Setup(); override;
var
  I: Int32;
begin
  inherited;
  
  Self.Skills := [ERSSkill.TOTAL, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.HITPOINTS];
  Self.MinZoom := 0;
  Self.MaxZoom := 15;

  Self.OnStartBreak := @OnBreakStart;
  Self.OnFinishBreak := @OnBreakFinish;
  Self.OnStartSleep := @OnSleepStart;
  Self.OnFinishSleep := @OnSleepFinish;
  Self.OnFinishTask := @Self.HandleFinishTask;

  if OVERRIDEBREAKS then
  begin
    WriteLn('[ANTIBAN] Custom break override enabled:');
    WriteLn('  - Break Interval: ', CUSTOMBREAKINTERVAL, ' minutes');
    WriteLn('  - Break Duration: ', CUSTOMBREAKDURATION, ' minutes');

    // Clear the default breaks so we can use our own
    Self.Breaks := [];

    // now we add our custom tbreaks
    Self.AddBreak(CUSTOMBREAKINTERVAL * ONE_MINUTE, CUSTOMBREAKDURATION * ONE_MINUTE, 0.33, 0.15);

    WriteLn('[ANTIBAN] Custom breaks initialized successfully');
  end
  else
  begin
    WriteLn('[ANTIBAN] Using WaspLib break system');
  end;
end;

{$IFDEF SCRIPT_GUI}
type
  TConfig = record(TScriptForm)
    WebhookLabel: TLabel;
    WebHookInput: TLabeledEdit;
    WorldHopIntervalInput: TLabeledEdit;
    RepotIntervalInput: TLabeledEdit;
    DharoksTargetHPInput: TLabeledEdit;
    EnableWebhooksCheckBox,
      HourlyReportsCheckBox, SessionSummaryCheckBox,
      LoseFocusCheckBox, EnableWorldHoppingCheckBox, UseBoostsCheckBox, UseDharoksCheckBox, UseSpecialAttacksCheckBox, UseQuickPrayersCheckBox, UseDragonBattleaxeCheckBox, EnablePrayerFlickCheckBox, StopOnDegradeCheckBox, EnableBoltEnchantingCheckBox, EnableFarmRunsCheckBox: TLabeledCheckBox;
      cb_runinit: TLabeledCheckBox;
      // Farm patch checkboxes
      cb_whp, cb_shp, cb_ahp, cb_fgh, cb_fhp, cb_chp, cb_php, cb_hhp, cb_afp, cb_ffp, cb_cfp, cb_hfp, cb_gfp,
      cb_capn, cb_caps, cb_fgan, cb_fgas, cb_wbp, cb_gbp, cb_gcp, cb_gsn, cb_gss, cb_barbdibber, cb_msecat, cb_clherbs: TLabeledCheckBox;
      // Farm combo boxes
      lcb_herbseed, lcb_flowerseed, lcb_allotmentseed, lcb_compost, lcb_cathtp, lcb_hostp, lcb_rpouch, lcb_fguildtp: TLabeledComboBox;
      // Farm grouped panels
      FarmHerbsPanel, FarmFlowersPanel, FarmAllotmentsPanel, FarmSpecialPanel: TLabeledPanel;
      WebhookInfo: TLabel;
    TestButton: TButton;
    SavedWebhookURL: String;
    DiscordPanel: TLabeledPanel;
    ScriptSettingsPanel: TLabeledPanel;
    UISettingsPanel: TLabeledPanel;
    Username: String;

    OverrideBreaksCheckBox: TLabeledCheckBox;
    CustomBreakIntervalInput: TLabeledEdit;
    CustomBreakDurationInput: TLabeledEdit;

    DebugModeCheckBox: TLabeledCheckBox;

    UIEnabledCheckBox: TLabeledCheckBox;
    UIXPositionInput: TLabeledEdit;
    UIYPositionInput: TLabeledEdit;
    UIPreviewButton: TButton;
    UIResetButton: TButton;

    UIPreviewPanel: TPanel;
    UIPreviewLabel: TLabel;
    UIPreviewTitleLabel: TLabel;

    UIFontSizeInput: TLabeledEdit;
    UIBackgroundColorCombo: TLabeledCombobox;
    UITextColorCombo: TLabeledCombobox;
    UIBackgroundColorHexInput: TLabeledEdit;
    UITextColorHexInput: TLabeledEdit;
    UIBackgroundColorPreview: TPanel;
    UITextColorPreview: TPanel;
  end;

procedure TConfig.UpdateAccountValues(sender: TObject);
var
  selector: TComboBox;
  user, pass, pin: TEdit;
  worlds: TMemo;
  idx: Int32;
  worldsStr: String;
  i: Int32;
begin
  selector := TComboBox(Self.Form.GetChild('am_selector_combobox'));
  idx := selector.GetItemIndex();

  if (idx < 0) or (idx > High(Login.Players)) then Exit;

  Self.SaveUserSettings();

  Login.PlayerIndex := idx;

  user := TEdit(Self.Form.GetChild('am_user_edit'));
  pass := TEdit(Self.Form.GetChild('am_pass_edit'));
  pin := TEdit(Self.Form.GetChild('am_pin_edit'));
  worlds := TMemo(Self.Form.GetChild('am_worlds_memo'));

  user.SetText(Login.Players[idx].User);
  pass.SetText(Login.Players[idx].Password);
  pin.SetText(Login.Players[idx].Pin);

  worldsStr := '';
  for i := 0 to High(Login.Players[idx].Worlds) do
  begin
    worldsStr += ToStr(Login.Players[idx].Worlds[i]);
    if i < High(Login.Players[idx].Worlds) then
      worldsStr += ', ';
  end;
  worlds.SetText(worldsStr);

  Self.LoadUserSettings();
end;

procedure TConfig.InitializeAccountManager;
var
  selector: TComboBox;
begin
  selector := TComboBox(Self.Form.GetChild('am_selector_combobox'));
  selector.SetOnChange(@UpdateAccountValues);
end;

procedure TConfig.LoadUserSettings();
var
  SavedWebhookURL: String;
  SavedEnableWebhooks: Boolean;
  SavedHourlyReports, SavedSessionSummary, SavedLoseFocus, SavedEnableWorldHopping, SavedUseBoosts, SavedUseDharoks, SavedUseSpecialAttacks, SavedUseQuickPrayers, SavedUseDragonBattleaxe, SavedEnablePrayerFlick, SavedStopOnDegrade, SavedEnableBoltEnchanting: Boolean;
  SavedWorldHopInterval, SavedRepotInterval: Integer;
  Username: String;
  SavedOverrideBreaks: Boolean;
  SavedCustomBreakInterval, SavedCustomBreakDuration: Integer;
  SavedDharoksTargetHP: Integer;
  SavedDebugMode: Boolean;
  SavedUIEnabled: Boolean;
  SavedUIX, SavedUIY, SavedUIWidth, SavedUIHeight: Integer;
  SavedUIFontSize: Integer;
  SavedUIBackgroundColorIndex, SavedUITextColorIndex: Integer;
  SavedUIBackgroundColorHex, SavedUITextColorHex: String;
begin
 if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  if Username = '' then Exit;

  SavedHourlyReports := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'HourlyReports', 'Configs/BASettings.ini'), True);
  SavedSessionSummary := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'SessionSummary', 'Configs/BASettings.ini'), True);
  SavedLoseFocus := StrToBoolDef(ReadINI(Username + ' Antiban Manager', 'LoseFocus', 'Configs/BASettings.ini'), True);
  SavedWebhookURL := ReadINI(Username + ' Webhook Settings', 'WebhookURL', 'Configs/BASettings.ini');
  SavedEnableWebhooks := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'EnableWebhooks', 'Configs/BASettings.ini'), False);
  SavedEnableWorldHopping := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', 'Configs/BASettings.ini'), False);
  SavedWorldHopInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', 'Configs/BASettings.ini'), 45);
  SavedUseBoosts := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseBoosts', 'Configs/BASettings.ini'), False);
  SavedRepotInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'RepotInterval', 'Configs/BASettings.ini'), 5);
  SavedUseDharoks := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseDharoks', 'Configs/BASettings.ini'), False);
  SavedUseDragonBattleaxe := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseDragonBattleaxe', 'Configs/BASettings.ini'), False);
  SavedUseSpecialAttacks := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseSpecialAttacks', 'Configs/BASettings.ini'), False);
  SavedUseQuickPrayers := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseQuickPrayers', 'Configs/BASettings.ini'), False);
  SavedDharoksTargetHP := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'DharoksTargetHP', 'Configs/BASettings.ini'), 1);
  SavedEnablePrayerFlick := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnablePrayerFlick', 'Configs/BASettings.ini'), False);
  SavedStopOnDegrade := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'StopOnDegrade', 'Configs/BASettings.ini'), False);
  SavedDebugMode := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'DebugMode', 'Configs/BASettings.ini'), False);

  if SavedDharoksTargetHP < 1 then
    SavedDharoksTargetHP := 1
  else if SavedDharoksTargetHP > 99 then
    SavedDharoksTargetHP := 99;

  // Load custom break override settings
  SavedOverrideBreaks := StrToBoolDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'OverrideBreaks', 'Configs/BASettings.ini'), False);
  SavedCustomBreakInterval := StrToIntDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakInterval', 'Configs/BASettings.ini'), 60);
  SavedCustomBreakDuration := StrToIntDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakDuration', 'Configs/BASettings.ini'), 5);

  // Load UI settings
  SavedUIEnabled := StrToBoolDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIEnabled', 'Configs/BASettings.ini'), True);
  SavedUIX := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIX', 'Configs/BASettings.ini'), 10);
  SavedUIY := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIY', 'Configs/BASettings.ini'), 230);
  SavedUIWidth := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIWidth', 'Configs/BASettings.ini'), 120);
  SavedUIHeight := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIHeight', 'Configs/BASettings.ini'), 78);

  // Load UI settings
  SavedUIFontSize := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIFontSize', 'Configs/BASettings.ini'), 10);

  // Ensure font size is within 6-20 to big otyherwise
  if SavedUIFontSize < 6 then SavedUIFontSize := 6;
  if SavedUIFontSize > 20 then SavedUIFontSize := 20;

  SavedUIBackgroundColorIndex := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorIndex', 'Configs/BASettings.ini'), 0);
  SavedUITextColorIndex := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UITextColorIndex', 'Configs/BASettings.ini'), 0);
  SavedUIBackgroundColorHex := ReadINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorHex', 'Configs/BASettings.ini');
  SavedUITextColorHex := ReadINI(Username + 'Gemstone Crab UI Settings', 'UITextColorHex', 'Configs/BASettings.ini');

  if Assigned(Self.HourlyReportsCheckBox) then
    Self.HourlyReportsCheckBox.SetChecked(SavedHourlyReports);

  if Assigned(Self.SessionSummaryCheckBox) then
    Self.SessionSummaryCheckBox.SetChecked(SavedSessionSummary);

  if Assigned(Self.LoseFocusCheckBox) then
    Self.LoseFocusCheckBox.SetChecked(SavedLoseFocus);

  if Assigned(Self.EnableWebhooksCheckBox) then
  begin
    Self.EnableWebhooksCheckBox.SetChecked(SavedEnableWebhooks);
    Self.WebhooksCheckboxChanged(Self.EnableWebhooksCheckBox.CheckBox);
  end;

  if Assigned(Self.EnableBoltEnchantingCheckBox) then
    Self.EnableBoltEnchantingCheckBox.SetChecked(SavedEnableBoltEnchanting);

  if Assigned(Self.EnableWorldHoppingCheckBox) then
    Self.EnableWorldHoppingCheckBox.SetChecked(SavedEnableWorldHopping);

  if Assigned(Self.UseBoostsCheckBox) then
    USEBOOSTS := Self.UseBoostsCheckBox.IsChecked();

  if Assigned(Self.UseDharoksCheckBox) then
    USEDHAROKS := Self.UseDharoksCheckBox.IsChecked();

  if Assigned(Self.UseSpecialAttacksCheckBox) then
    USESPECIALATTACKSGUI := Self.UseSpecialAttacksCheckBox.IsChecked();

  if Assigned(Self.UseQuickPrayersCheckBox) then
    USEQUICKPRAYERSGUI := Self.UseQuickPrayersCheckBox.IsChecked();

  if Assigned(Self.UseDragonBattleaxeCheckBox) then
    USEDRAGONBATTLEAXEGUI := Self.UseDragonBattleaxeCheckBox.IsChecked();

  if Assigned(Self.EnableBoltEnchantingCheckBox) then
    ENABLEBOLTENCHANTING := Self.EnableBoltEnchantingCheckBox.IsChecked();

  if Assigned(Self.EnableFarmRunsCheckBox) then
    ENABLEFARMRUNS := Self.EnableFarmRunsCheckBox.IsChecked();

  // Load farm run settings from INI
  FARMHERBSEED := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'HerbSeed', 'Configs/BASettings.ini'), 5);
  FARMFOWERSEED := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'FlowerSeed', 'Configs/BASettings.ini'), 0);
  FARMALLOTMENTSEED := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'AllotmentSeed', 'Configs/BASettings.ini'), 0);
  FARMCOMPOSTTYPE := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'CompostType', 'Configs/BASettings.ini'), 2);
  FARMCATHERBYTP := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyTP', 'Configs/BASettings.ini'), 0);
  FARMHOSIDIUSTP := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'HosidiusTP', 'Configs/BASettings.ini'), 0);
  FARMFARMGUILDTP := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildTP', 'Configs/BASettings.ini'), 0);
  FARMRUNEPOUCH := StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'RunePouch', 'Configs/BASettings.ini'), 0);

  FARMWEISSHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'WeissHerb', 'Configs/BASettings.ini'), False);
  FARMSTRONGHOLDHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'StrongholdHerb', 'Configs/BASettings.ini'), False);
  FARMARDOUGNEHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'ArdougneHerb', 'Configs/BASettings.ini'), True);
  FARMFALADORHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FaladorHerb', 'Configs/BASettings.ini'), True);
  FARMCATHERBYHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyHerb', 'Configs/BASettings.ini'), True);
  FARMPORTPHASMATYSHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'PortPhasmatysHerb', 'Configs/BASettings.ini'), True);
  FARMHOSIDIUSHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'HosidiusHerb', 'Configs/BASettings.ini'), True);
  FARMFARMGUILDHERB := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildHerb', 'Configs/BASettings.ini'), True);

  FARMHOSIDIUSFLOWER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'HosidiusFlower', 'Configs/BASettings.ini'), False);
  FARMARDOUGNEFLOWER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'ArdougneFlower', 'Configs/BASettings.ini'), False);
  FARMFALADORFLOWER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FaladorFlower', 'Configs/BASettings.ini'), False);
  FARMCATHERBYFLOWER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyFlower', 'Configs/BASettings.ini'), False);
  FARMFARMGUILDFLOWER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildFlower', 'Configs/BASettings.ini'), False);

  FARMCATHERBYALLOTMENTN := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyAllotmentN', 'Configs/BASettings.ini'), False);
  FARMCATHERBYALLOTMENTS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyAllotmentS', 'Configs/BASettings.ini'), False);
  FARMFARMGUILDALLOTMENTN := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentN', 'Configs/BASettings.ini'), False);
  FARMFARMGUILDALLOTMENTS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentS', 'Configs/BASettings.ini'), False);

  FARMGIANTSEAWEEDN := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'GiantSeaweedN', 'Configs/BASettings.ini'), False);
  FARMGIANTSEAWEEDS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'GiantSeaweedS', 'Configs/BASettings.ini'), False);
  FARMKANDARINBUSH := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'KandarinBush', 'Configs/BASettings.ini'), False);
  FARMFARMGUILDBUSH := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildBush', 'Configs/BASettings.ini'), False);
  FARMFARMGUILDCACTUS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildCactus', 'Configs/BASettings.ini'), False);

  FARMCLEANHERBS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CleanHerbs', 'Configs/BASettings.ini'), True);
  FARMBARBDIBBER := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'BarbDibber', 'Configs/BASettings.ini'), False);
  FARMMAGICSECATEURS := StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'MagicSecateurs', 'Configs/BASettings.ini'), False);

  if Assigned(Self.WorldHopIntervalInput) then
    Self.WorldHopIntervalInput.SetText(IntToStr(SavedWorldHopInterval));

  if Assigned(Self.RepotIntervalInput) then
    Self.RepotIntervalInput.SetText(IntToStr(SavedRepotInterval));

  if Assigned(Self.WebHookInput) then
    Self.WebHookInput.SetText(SavedWebhookURL);

  if Assigned(Self.OverrideBreaksCheckBox) then
    Self.OverrideBreaksCheckBox.SetChecked(SavedOverrideBreaks);

  if Assigned(Self.CustomBreakIntervalInput) then
    Self.CustomBreakIntervalInput.SetText(IntToStr(SavedCustomBreakInterval));

  if Assigned(Self.CustomBreakDurationInput) then
    Self.CustomBreakDurationInput.SetText(IntToStr(SavedCustomBreakDuration));

  if Assigned(Self.UseDharoksCheckBox) then
    USEDHAROKS := Self.UseDharoksCheckBox.IsChecked();

  if Assigned(Self.UseSpecialAttacksCheckBox) then
    USESPECIALATTACKSGUI := Self.UseSpecialAttacksCheckBox.IsChecked();

  if Assigned(Self.UseDragonBattleaxeCheckBox) then
    USEDRAGONBATTLEAXEGUI := Self.UseDragonBattleaxeCheckBox.IsChecked();

  if Assigned(Self.EnableBoltEnchantingCheckBox) then
    ENABLEBOLTENCHANTING := Self.EnableBoltEnchantingCheckBox.IsChecked();

  if Assigned(Self.EnablePrayerFlickCheckBox) then
    ENABLEPRAYERFLICK := Self.EnablePrayerFlickCheckBox.IsChecked();

  if Assigned(Self.DharoksTargetHPInput) then
    DHAROKSTARGETHPS := StrToIntDef(Self.DharoksTargetHPInput.GetText(), 1);

  if Assigned(Self.DebugModeCheckBox) then
    Self.DebugModeCheckBox.SetChecked(SavedDebugMode);

  if Assigned(Self.StopOnDegradeCheckBox) then
    Self.StopOnDegradeCheckBox.SetChecked(SavedStopOnDegrade);

  // WE load the UI settings in its own function because so much shit FYI

  // Validate Dharoks target HP range
  if DHAROKSTARGETHPS < 1 then
    DHAROKSTARGETHPS := 1
  else if DHAROKSTARGETHPS > 99 then
    DHAROKSTARGETHPS := 99;
end;

procedure TConfig.LoadUISettings();
var
  Username: String;
  SavedUIEnabled: Boolean;
  SavedUIX, SavedUIY, SavedUIWidth, SavedUIHeight: Integer;
  SavedUIFontSize: Integer;
  SavedUIBackgroundColorIndex, SavedUITextColorIndex: Integer;
  SavedUIBackgroundColorHex, SavedUITextColorHex: String;
begin
  if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  // Load UI positioning
  SavedUIEnabled := StrToBoolDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIEnabled', 'Configs/BASettings.ini'), True);
  SavedUIX := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIX', 'Configs/BASettings.ini'), 10);
  SavedUIY := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIY', 'Configs/BASettings.ini'), 230);
  SavedUIWidth := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIWidth', 'Configs/BASettings.ini'), 120);
  SavedUIHeight := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIHeight', 'Configs/BASettings.ini'), 78);

  // Load UI appearance
  SavedUIFontSize := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIFontSize', 'Configs/BASettings.ini'), 11);

  // Ensure font size is within 6-20 to big
  if SavedUIFontSize < 6 then SavedUIFontSize := 6;
  if SavedUIFontSize > 20 then SavedUIFontSize := 20;

  SavedUIBackgroundColorIndex := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorIndex', 'Configs/BASettings.ini'), 0);
  SavedUITextColorIndex := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UITextColorIndex', 'Configs/BASettings.ini'), 0);
  SavedUIBackgroundColorHex := ReadINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorHex', 'Configs/BASettings.ini');
  SavedUITextColorHex := ReadINI(Username + 'Gemstone Crab UI Settings', 'UITextColorHex', 'Configs/BASettings.ini');

  // Apply settings to UI
  if Assigned(Self.UIEnabledCheckBox) then
    Self.UIEnabledCheckBox.SetChecked(SavedUIEnabled);

  if Assigned(Self.UIXPositionInput) then
    Self.UIXPositionInput.SetText(IntToStr(SavedUIX));

  if Assigned(Self.UIYPositionInput) then
    Self.UIYPositionInput.SetText(IntToStr(SavedUIY));

  if Assigned(Self.UIFontSizeInput) then
    Self.UIFontSizeInput.SetText(IntToStr(SavedUIFontSize));

  if Assigned(Self.UIBackgroundColorCombo) then
  begin
    Self.UIBackgroundColorCombo.SetItemIndex(SavedUIBackgroundColorIndex);
    Self.UIBackgroundColorChanged(Self.UIBackgroundColorCombo.ComboBox);
  end;

  if Assigned(Self.UITextColorCombo) then
  begin
    Self.UITextColorCombo.SetItemIndex(SavedUITextColorIndex);
    Self.UITextColorChanged(Self.UITextColorCombo.ComboBox);
  end;

  if Assigned(Self.UIBackgroundColorHexInput) and (SavedUIBackgroundColorIndex = 6) then
    Self.UIBackgroundColorHexInput.SetText(SavedUIBackgroundColorHex);

  if Assigned(Self.UITextColorHexInput) and (SavedUITextColorIndex = 7) then
    Self.UITextColorHexInput.SetText(SavedUITextColorHex);

  // Update our live preview after WE load it all
  Self.UpdateUIPreview(nil);
end;

procedure TConfig.SaveUserSettings();
var
  Username: String;
  fontSize: Int32;
begin
 if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  if Username = '' then Exit;

  if Assigned(Self.HourlyReportsCheckBox) then
    SENDHOURLYREPORTMSG := Self.HourlyReportsCheckBox.IsChecked();

  if Assigned(Self.SessionSummaryCheckBox) then
    SENDSESSIONSUMMARYMSG := Self.SessionSummaryCheckBox.IsChecked();

  if Assigned(Self.LoseFocusCheckBox) then
    ABLOSEFOCUS := Self.LoseFocusCheckBox.IsChecked();

  if Assigned(Self.EnableWebhooksCheckBox) then
    ENABLEWEBHOOKS := Self.EnableWebhooksCheckBox.IsChecked();

  if Assigned(Self.EnableWorldHoppingCheckBox) then
    ENABLEWORLDHOPPING := Self.EnableWorldHoppingCheckBox.IsChecked();

  if Assigned(Self.UseBoostsCheckBox) then
    USEBOOSTS := Self.UseBoostsCheckBox.IsChecked();

  if Assigned(Self.WorldHopIntervalInput) then
    WORLDHOPINTERVAL := StrToIntDef(Self.WorldHopIntervalInput.GetText(), 45);

  if Assigned(Self.RepotIntervalInput) then
    REPOTINTERVAL := StrToIntDef(Self.RepotIntervalInput.GetText(), 5);

  if Assigned(Self.WebHookInput) then
    WEBHOOKURL := Self.WebHookInput.GetText();

  if Assigned(Self.OverrideBreaksCheckBox) then
    OVERRIDEBREAKS := Self.OverrideBreaksCheckBox.IsChecked();

  if Assigned(Self.CustomBreakIntervalInput) then
    CUSTOMBREAKINTERVAL := StrToIntDef(Self.CustomBreakIntervalInput.GetText(), 60);

  if Assigned(Self.CustomBreakDurationInput) then
    CUSTOMBREAKDURATION := StrToIntDef(Self.CustomBreakDurationInput.GetText(), 5);

  if Assigned(Self.UseDharoksCheckBox) then
    USEDHAROKS := Self.UseDharoksCheckBox.IsChecked();

  if Assigned(Self.UseSpecialAttacksCheckBox) then
    USESPECIALATTACKSGUI := Self.UseSpecialAttacksCheckBox.IsChecked();

  if Assigned(Self.UseDragonBattleaxeCheckBox) then
    USEDRAGONBATTLEAXEGUI := Self.UseDragonBattleaxeCheckBox.IsChecked();

  if Assigned(Self.UseQuickPrayersCheckBox) then
    USEQUICKPRAYERSGUI := Self.UseQuickPrayersCheckBox.IsChecked();

  if Assigned(Self.EnableBoltEnchantingCheckBox) then
    ENABLEBOLTENCHANTING := Self.EnableBoltEnchantingCheckBox.IsChecked();

  if Assigned(Self.EnablePrayerFlickCheckBox) then
    ENABLEPRAYERFLICK := Self.EnablePrayerFlickCheckBox.IsChecked();

  if Assigned(Self.DharoksTargetHPInput) then
    DHAROKSTARGETHPS := StrToIntDef(Self.DharoksTargetHPInput.GetText(), 1);

  if Assigned(Self.DebugModeCheckBox) then
    DEBUGMODE := Self.DebugModeCheckBox.IsChecked();

  if Assigned(Self.StopOnDegradeCheckBox) then
    STOPONDEGRADE := Self.StopOnDegradeCheckBox.IsChecked();

  if Assigned(Self.EnableFarmRunsCheckBox) then
    ENABLEFARMRUNS := Self.EnableFarmRunsCheckBox.IsChecked();

  if Assigned(Self.cb_runinit) then
    STARTWITHFARMRUN := Self.cb_runinit.IsChecked();

  // Farm GUI
  if Assigned(Self.cb_whp) then
    FARMWEISSHERB := Self.cb_whp.IsChecked();
  if Assigned(Self.cb_shp) then
    FARMSTRONGHOLDHERB := Self.cb_shp.IsChecked();
  if Assigned(Self.cb_ahp) then
    FARMARDOUGNEHERB := Self.cb_ahp.IsChecked();
  if Assigned(Self.cb_fhp) then
    FARMFALADORHERB := Self.cb_fhp.IsChecked();
  if Assigned(Self.cb_chp) then
    FARMCATHERBYHERB := Self.cb_chp.IsChecked();
  if Assigned(Self.cb_php) then
    FARMPORTPHASMATYSHERB := Self.cb_php.IsChecked();
  if Assigned(Self.cb_hhp) then
    FARMHOSIDIUSHERB := Self.cb_hhp.IsChecked();
  if Assigned(Self.cb_fgh) then
    FARMFARMGUILDHERB := Self.cb_fgh.IsChecked();

  if Assigned(Self.cb_afp) then
    FARMARDOUGNEFLOWER := Self.cb_afp.IsChecked();
  if Assigned(Self.cb_ffp) then
    FARMFALADORFLOWER := Self.cb_ffp.IsChecked();
  if Assigned(Self.cb_cfp) then
    FARMCATHERBYFLOWER := Self.cb_cfp.IsChecked();
  if Assigned(Self.cb_hfp) then
    FARMHOSIDIUSFLOWER := Self.cb_hfp.IsChecked();
  if Assigned(Self.cb_gfp) then
    FARMFARMGUILDFLOWER := Self.cb_gfp.IsChecked();

  if Assigned(Self.cb_capn) then
    FARMCATHERBYALLOTMENTN := Self.cb_capn.IsChecked();
  if Assigned(Self.cb_caps) then
    FARMCATHERBYALLOTMENTS := Self.cb_caps.IsChecked();
  if Assigned(Self.cb_fgan) then
    FARMFARMGUILDALLOTMENTN := Self.cb_fgan.IsChecked();
  if Assigned(Self.cb_fgas) then
    FARMFARMGUILDALLOTMENTS := Self.cb_fgas.IsChecked();

  if Assigned(Self.cb_wbp) then
    FARMKANDARINBUSH := Self.cb_wbp.IsChecked();
  if Assigned(Self.cb_gbp) then
    FARMFARMGUILDBUSH := Self.cb_gbp.IsChecked();
  if Assigned(Self.cb_gcp) then
    FARMFARMGUILDCACTUS := Self.cb_gcp.IsChecked();
  if Assigned(Self.cb_gsn) then
    FARMGIANTSEAWEEDN := Self.cb_gsn.IsChecked();
  if Assigned(Self.cb_gss) then
    FARMGIANTSEAWEEDS := Self.cb_gss.IsChecked();

  if Assigned(Self.cb_barbdibber) then
    FARMBARBDIBBER := Self.cb_barbdibber.IsChecked();
  if Assigned(Self.cb_msecat) then
    FARMMAGICSECATEURS := Self.cb_msecat.IsChecked();
  if Assigned(Self.cb_clherbs) then
    FARMCLEANHERBS := Self.cb_clherbs.IsChecked();

  if Assigned(Self.lcb_herbseed) then
    FARMHERBSEED := Self.lcb_herbseed.GetItemIndex();
  if Assigned(Self.lcb_flowerseed) then
    FARMFOWERSEED := Self.lcb_flowerseed.GetItemIndex();
  if Assigned(Self.lcb_allotmentseed) then
    FARMALLOTMENTSEED := Self.lcb_allotmentseed.GetItemIndex();
  if Assigned(Self.lcb_compost) then
    FARMCOMPOSTTYPE := Self.lcb_compost.GetItemIndex();
  if Assigned(Self.lcb_cathtp) then
  begin
    if (FARMCATHERBYHERB or FARMCATHERBYFLOWER or FARMCATHERBYALLOTMENTN or FARMCATHERBYALLOTMENTS) then
      FARMCATHERBYTP := Self.lcb_cathtp.GetItemIndex() + 1 // Add 1 because our dropdown starts at 0 but teleport values start at 1
    else
      FARMCATHERBYTP := 0; // No patches selected, no teleport needed
  end;
  if Assigned(Self.lcb_hostp) then
  begin
    if (FARMHOSIDIUSHERB or FARMHOSIDIUSFLOWER) then
      FARMHOSIDIUSTP := Self.lcb_hostp.GetItemIndex() + 1
    else
      FARMHOSIDIUSTP := 0;
  end;
  if Assigned(Self.lcb_fguildtp) then
  begin
    if (FARMFARMGUILDHERB or FARMFARMGUILDFLOWER or FARMFARMGUILDBUSH or FARMFARMGUILDALLOTMENTN or FARMFARMGUILDALLOTMENTS or FARMFARMGUILDCACTUS) then
      FARMFARMGUILDTP := Self.lcb_fguildtp.GetItemIndex() + 1
    else
      FARMFARMGUILDTP := 0;
  end;
  if Assigned(Self.lcb_rpouch) then
    FARMRUNEPOUCH := Self.lcb_rpouch.GetItemIndex();

  WriteINI(Username + ' Webhook Settings', 'WebhookURL', WEBHOOKURL, 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'EnableWebhooks', BoolToStr(ENABLEWEBHOOKS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'HourlyReports', BoolToStr(SENDHOURLYREPORTMSG, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'SessionSummary', BoolToStr(SENDSESSIONSUMMARYMSG, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Antiban Manager', 'LoseFocus', BoolToStr(ABLOSEFOCUS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', BoolToStr(ENABLEWORLDHOPPING, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', IntToStr(WORLDHOPINTERVAL), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'UseBoosts', BoolToStr(USEBOOSTS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'RepotInterval', IntToStr(REPOTINTERVAL), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'UseDharoks', BoolToStr(USEDHAROKS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'UseSpecialAttacks', BoolToStr(USESPECIALATTACKSGUI, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'UseQuickPrayers', BoolToStr(USEQUICKPRAYERSGUI, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'UseDragonBattleaxe', BoolToStr(USEDRAGONBATTLEAXEGUI, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'EnableBoltEnchanting', BoolToStr(ENABLEBOLTENCHANTING, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'EnableFarmRuns', BoolToStr(ENABLEFARMRUNS, 'true', 'false'), 'Configs/BASettings.ini');

  // Farm run settings saved to INI
  WriteINI(Username + ' Farm Run Settings', 'HerbSeed', IntToStr(FARMHERBSEED), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FlowerSeed', IntToStr(FARMFOWERSEED), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'AllotmentSeed', IntToStr(FARMALLOTMENTSEED), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'CompostType', IntToStr(FARMCOMPOSTTYPE), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'CatherbyTP', IntToStr(FARMCATHERBYTP), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'HosidiusTP', IntToStr(FARMHOSIDIUSTP), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildTP', IntToStr(FARMFARMGUILDTP), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'RunePouch', IntToStr(FARMRUNEPOUCH), 'Configs/BASettings.ini');

  WriteINI(Username + ' Farm Run Settings', 'WeissHerb', BoolToStr(FARMWEISSHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'StrongholdHerb', BoolToStr(FARMSTRONGHOLDHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'ArdougneHerb', BoolToStr(FARMARDOUGNEHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FaladorHerb', BoolToStr(FARMFALADORHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'CatherbyHerb', BoolToStr(FARMCATHERBYHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'PortPhasmatysHerb', BoolToStr(FARMPORTPHASMATYSHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'HosidiusHerb', BoolToStr(FARMHOSIDIUSHERB, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildHerb', BoolToStr(FARMFARMGUILDHERB, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + ' Farm Run Settings', 'HosidiusFlower', BoolToStr(FARMHOSIDIUSFLOWER, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'ArdougneFlower', BoolToStr(FARMARDOUGNEFLOWER, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FaladorFlower', BoolToStr(FARMFALADORFLOWER, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'CatherbyFlower', BoolToStr(FARMCATHERBYFLOWER, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildFlower', BoolToStr(FARMFARMGUILDFLOWER, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + ' Farm Run Settings', 'CatherbyAllotmentN', BoolToStr(FARMCATHERBYALLOTMENTN, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'CatherbyAllotmentS', BoolToStr(FARMCATHERBYALLOTMENTS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentN', BoolToStr(FARMFARMGUILDALLOTMENTN, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentS', BoolToStr(FARMFARMGUILDALLOTMENTS, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + ' Farm Run Settings', 'GiantSeaweedN', BoolToStr(FARMGIANTSEAWEEDN, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'GiantSeaweedS', BoolToStr(FARMGIANTSEAWEEDS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'KandarinBush', BoolToStr(FARMKANDARINBUSH, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildBush', BoolToStr(FARMFARMGUILDBUSH, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'FarmGuildCactus', BoolToStr(FARMFARMGUILDCACTUS, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + ' Farm Run Settings', 'CleanHerbs', BoolToStr(FARMCLEANHERBS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'BarbDibber', BoolToStr(FARMBARBDIBBER, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Farm Run Settings', 'MagicSecateurs', BoolToStr(FARMMAGICSECATEURS, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + ' Gemstone Crab Settings', 'DharoksTargetHP', IntToStr(DHAROKSTARGETHPS), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'EnablePrayerFlick', BoolToStr(ENABLEPRAYERFLICK, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'StopOnDegrade', BoolToStr(STOPONDEGRADE, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'DebugMode', BoolToStr(DEBUGMODE, 'true', 'false'), 'Configs/BASettings.ini');

  WriteINI(Username + 'Gemstone Crab Antiban Manager', 'OverrideBreaks', BoolToStr(OVERRIDEBREAKS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakInterval', IntToStr(CUSTOMBREAKINTERVAL), 'Configs/BASettings.ini');
  WriteINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakDuration', IntToStr(CUSTOMBREAKDURATION), 'Configs/BASettings.ini');

  if Assigned(Self.UIEnabledCheckBox) then
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIEnabled', BoolToStr(Self.UIEnabledCheckBox.IsChecked(), 'true', 'false'), 'Configs/BASettings.ini');
  if Assigned(Self.UIXPositionInput) then
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIX', Self.UIXPositionInput.GetText(), 'Configs/BASettings.ini');
  if Assigned(Self.UIYPositionInput) then
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIY', Self.UIYPositionInput.GetText(), 'Configs/BASettings.ini');

  if Assigned(Self.UIFontSizeInput) then
  begin
    fontSize := StrToIntDef(Self.UIFontSizeInput.GetText(), 11);
    if fontSize < 6 then fontSize := 6;
    if fontSize > 20 then fontSize := 20;
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIFontSize', IntToStr(fontSize), 'Configs/BASettings.ini');
  end;

  if Assigned(Self.UIBackgroundColorCombo) then
  begin
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorIndex', IntToStr(Self.UIBackgroundColorCombo.GetItemIndex()), 'Configs/BASettings.ini');

    case Self.UIBackgroundColorCombo.GetItemIndex() of
      0: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($2D2D30), 'Configs/BASettings.ini');
      1: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($000000), 'Configs/BASettings.ini');
      2: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($FFFFFF), 'Configs/BASettings.ini');
      3: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($0000FF), 'Configs/BASettings.ini');
      4: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($00FF00), 'Configs/BASettings.ini');
      5: WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr($FF0000), 'Configs/BASettings.ini');
      6: begin
           if Assigned(Self.UIBackgroundColorHexInput) then
           begin
             WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorHex', Self.UIBackgroundColorHexInput.GetText(), 'Configs/BASettings.ini');
             WriteINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColor', IntToStr(StrToIntDef('$' + Self.UIBackgroundColorHexInput.GetText(), $2D2D30)), 'Configs/BASettings.ini');
           end;
         end;
    end;
  end;

  if Assigned(Self.UITextColorCombo) then
  begin
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColorIndex', IntToStr(Self.UITextColorCombo.GetItemIndex()), 'Configs/BASettings.ini');

    case Self.UITextColorCombo.GetItemIndex() of
      0: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($FFFFFF), 'Configs/BASettings.ini');
      1: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($000000), 'Configs/BASettings.ini');
      2: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($C0C0C0), 'Configs/BASettings.ini');
      3: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($0000FF), 'Configs/BASettings.ini');
      4: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($00FF00), 'Configs/BASettings.ini');
      5: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($FF0000), 'Configs/BASettings.ini');
      6: WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr($00FFFF), 'Configs/BASettings.ini');
      7: begin
           if Assigned(Self.UITextColorHexInput) then
           begin
             WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColorHex', Self.UITextColorHexInput.GetText(), 'Configs/BASettings.ini');
             WriteINI(Username + 'Gemstone Crab UI Settings', 'UITextColor', IntToStr(StrToIntDef('$' + Self.UITextColorHexInput.GetText(), $FFFFFF)), 'Configs/BASettings.ini');
           end;
         end;
    end;
  end;
end;

procedure TConfig.StartScript(sender: TObject); override;
var
  Username: String;
begin
  Self.SaveUserSettings();

  // Transfer UI settings from config
  if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  GemStoneCrabBot.UIEnabled := StrToBoolDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIEnabled', 'Configs/BASettings.ini'), True);
  GemStoneCrabBot.UIPosition.X := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIX', 'Configs/BASettings.ini'), 10);
  GemStoneCrabBot.UIPosition.Y := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIY', 'Configs/BASettings.ini'), 230);
  
  // our reset Update Y position from old default (210) to new default (230)
  // We can remove this in a few weeks
  if (GemStoneCrabBot.UIPosition.Y = 210) and (ReadINI(Username + 'Gemstone Crab UI Settings', 'UIYResetDone', 'Configs/BASettings.ini') <> 'true') then
  begin
    GemStoneCrabBot.UIPosition.Y := 230;
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIY', '230', 'Configs/BASettings.ini');
    WriteINI(Username + 'Gemstone Crab UI Settings', 'UIYResetDone', 'true', 'Configs/BASettings.ini');
  end;

  GemStoneCrabBot.UISize.X := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIWidth', 'Configs/BASettings.ini'), 120);
  GemStoneCrabBot.UISize.Y := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIHeight', 'Configs/BASettings.ini'), 78);
  GemStoneCrabBot.UIFontSize := StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIFontSize', 'Configs/BASettings.ini'), 11);

  case StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UIBackgroundColorIndex', 'Configs/BASettings.ini'), 0) of
    0: GemStoneCrabBot.UIBackgroundColor := $2D2D30;
    1: GemStoneCrabBot.UIBackgroundColor := $000000;
    2: GemStoneCrabBot.UIBackgroundColor := $FFFFFF;
    3: GemStoneCrabBot.UIBackgroundColor := $0000FF;
    4: GemStoneCrabBot.UIBackgroundColor := $00FF00;
    5: GemStoneCrabBot.UIBackgroundColor := $FF0000;
    6: GemStoneCrabBot.UIBackgroundColor := StrToIntDef('$' + ReadINI(Username + ' UI Settings', 'UIBackgroundColorHex', 'Configs/BASettings.ini'), $2D2D30);
    else GemStoneCrabBot.UIBackgroundColor := $2D2D30;
  end;

  case StrToIntDef(ReadINI(Username + 'Gemstone Crab UI Settings', 'UITextColorIndex', 'Configs/BASettings.ini'), 0) of
    0: GemStoneCrabBot.UITextColor := $FFFFFF;
    1: GemStoneCrabBot.UITextColor := $000000;
    2: GemStoneCrabBot.UITextColor := $C0C0C0;
    3: GemStoneCrabBot.UITextColor := $0000FF;
    4: GemStoneCrabBot.UITextColor := $00FF00;
    5: GemStoneCrabBot.UITextColor := $FF0000;
    6: GemStoneCrabBot.UITextColor := $00FFFF;
    7: GemStoneCrabBot.UITextColor := StrToIntDef('$' + ReadINI(Username + ' UI Settings', 'UITextColorHex', 'Configs/BASettings.ini'), $FFFFFF);
    else GemStoneCrabBot.UITextColor := $FFFFFF;
  end;

  if ENABLEWEBHOOKS then
  begin
    Discord.SetWebhook(WEBHOOKURL);
    Discord.SetUsername('BigAussies Gemstone Crab Slayer');
    Discord.SetAvatar('https://oldschool.runescape.wiki/images/thumb/2/2e/Gemstone_crab.png/150px-Gemstone_crab.png');
  end;

  ENABLEBOLTENCHANTING := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableBoltEnchanting', 'Configs/BASettings.ini'), False);

  inherited;
end;

procedure TConfig.OpenURL(Sender: TObject);
begin
  if Sender = Self.WebhookInfo then
    OpenWebPage('https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks');
end;

procedure TConfig.WebhooksCheckboxChanged({$H-}sender: TObject){$H+};
begin
  Self.WebhookInfo.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.DiscordPanel) then
    Self.DiscordPanel.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.WebHookInput) then
    Self.WebHookInput.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.TestButton) then
    Self.TestButton.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.HourlyReportsCheckBox) then
    Self.HourlyReportsCheckBox.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.SessionSummaryCheckBox) then
    Self.SessionSummaryCheckBox.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
end;

procedure TConfig.WorldHoppingCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.WorldHopIntervalInput) then
    Self.WorldHopIntervalInput.SetVisible(Self.EnableWorldHoppingCheckBox.IsChecked());
end;

procedure TConfig.BoostCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.RepotIntervalInput) then
    Self.RepotIntervalInput.SetVisible(Self.UseBoostsCheckBox.IsChecked());
end;

procedure TConfig.OverrideBreaksCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.CustomBreakIntervalInput) then
    Self.CustomBreakIntervalInput.SetVisible(Self.OverrideBreaksCheckBox.IsChecked());
  if Assigned(Self.CustomBreakDurationInput) then
    Self.CustomBreakDurationInput.SetVisible(Self.OverrideBreaksCheckBox.IsChecked());
end;

procedure TConfig.DharoksCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.DharoksTargetHPInput) then
    Self.DharoksTargetHPInput.SetVisible(Self.UseDharoksCheckBox.IsChecked());

  if Assigned(Self.EnablePrayerFlickCheckBox) then
    Self.EnablePrayerFlickCheckBox.SetVisible(Self.UseDharoksCheckBox.IsChecked());

  if Assigned(Self.StopOnDegradeCheckBox) then
    Self.StopOnDegradeCheckBox.SetVisible(Self.UseDharoksCheckBox.IsChecked());

  if Self.UseDharoksCheckBox.IsChecked() then
  begin
    if Assigned(Self.UseSpecialAttacksCheckBox) then
      Self.UseSpecialAttacksCheckBox.SetChecked(False);
  end;
end;

procedure TConfig.SpecialAttacksCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Self.UseSpecialAttacksCheckBox.IsChecked() then
  begin
    if Assigned(Self.UseDragonBattleaxeCheckBox) then
      Self.UseDragonBattleaxeCheckBox.SetChecked(False);
  end;

  if Self.UseSpecialAttacksCheckBox.IsChecked() then
  begin
    if Assigned(Self.UseDharoksCheckBox) then
    begin
      Self.UseDharoksCheckBox.SetChecked(False);
      Self.DharoksCheckboxChanged(nil);
    end;
  end;
end;

procedure TConfig.DragonBattleaxeCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Self.UseDragonBattleaxeCheckBox.IsChecked() then
  begin
    if Assigned(Self.UseSpecialAttacksCheckBox) then
      Self.UseSpecialAttacksCheckBox.SetChecked(False);
  end;
end;

procedure TConfig.QuickPrayersCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Self.UseQuickPrayersCheckBox.IsChecked() then
  begin
    ShowMessage('IMPORTANT: Please ensure your quick prayers are properly configured in-game' + #13#10 + #13#10 +
                'To setup quick prayers:' + #13#10 +
                '1. Right-click on the prayer orb next to the minimap' + #13#10 +
                '2. Select "Setup Quick-prayers"' + #13#10 +
                '3. Choose which prayers to enable when quick prayers are activated');
  end;
end;

procedure TConfig.UpdateCatherbyTeleportDropdown();
var
  hasCatherbyPatches: Boolean;
  currentSelection: String;
  newIndex: Integer;
  Username: String;
  savedIndex: Integer;
  teleportPreference: String;
begin
  hasCatherbyPatches := (Assigned(cb_chp) and cb_chp.IsChecked()) or
                       (Assigned(cb_cfp) and cb_cfp.IsChecked()) or
                       (Assigned(cb_capn) and cb_capn.IsChecked()) or
                       (Assigned(cb_caps) and cb_caps.IsChecked());

  if Assigned(lcb_cathtp) then
  begin
    if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
      Username := 'NoUserNameSelected'
    else
      Username := Login.Players[Login.PlayerIndex].User;

    // Preserve ccurrent selection
    if lcb_cathtp.ComboBox.GetItems().GetCount() > 0 then
      currentSelection := lcb_cathtp.ComboBox.GetText();

    // Store the teleport preference
    if (currentSelection = 'Camelot TELEPORT') or 
       (currentSelection = 'Camelot TABLET') or 
       (currentSelection = 'Catherby TABLET') then
      teleportPreference := currentSelection
    else
      teleportPreference := 'Camelot TELEPORT';

    if hasCatherbyPatches then
    begin
      lcb_cathtp.Clear();
      lcb_cathtp.AddItemArray(['Camelot TELEPORT', 'Camelot TABLET', 'Catherby TABLET']);

       savedIndex := FARMCATHERBYTP;
       if savedIndex > 0 then
         savedIndex := savedIndex - 1;
       
       newIndex := 0;

       if (savedIndex >= 0) and (savedIndex <= 2) then
         newIndex := savedIndex
       else if teleportPreference = 'Camelot TELEPORT' then
         newIndex := 0
       else if teleportPreference = 'Camelot TABLET' then
         newIndex := 1
       else if teleportPreference = 'Catherby TABLET' then
         newIndex := 2;

      lcb_cathtp.SetItemIndex(newIndex);
    end
    else
    begin
      lcb_cathtp.Clear();
      lcb_cathtp.AddItemArray(['Not using Catherby patch']);
      lcb_cathtp.SetItemIndex(0);
    end;
  end;
end;

procedure TConfig.UpdateFarmingGuildTeleportDropdown();
var
  hasFarmingGuildPatches: Boolean;
  currentSelection: String;
  newIndex: Integer;
  Username: String;
  savedIndex: Integer;
  teleportPreference: String;
begin
  hasFarmingGuildPatches := (Assigned(cb_fgh) and cb_fgh.IsChecked()) or
                           (Assigned(cb_gfp) and cb_gfp.IsChecked()) or
                           (Assigned(cb_gbp) and cb_gbp.IsChecked()) or
                           (Assigned(cb_gcp) and cb_gcp.IsChecked()) or
                           (Assigned(cb_fgan) and cb_fgan.IsChecked()) or
                           (Assigned(cb_fgas) and cb_fgas.IsChecked());

  if Assigned(lcb_fguildtp) then
  begin
    if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
      Username := 'NoUserNameSelected'
    else
      Username := Login.Players[Login.PlayerIndex].User;

    if lcb_fguildtp.ComboBox.GetItems().GetCount() > 0 then
      currentSelection := lcb_fguildtp.ComboBox.GetText();

    if (currentSelection = 'Skills necklace') or 
       (currentSelection = 'Farming cape UNTRIMMED') or 
       (currentSelection = 'Farming cape TRIMMED') then
      teleportPreference := currentSelection
    else
      teleportPreference := 'Skills necklace';

    if hasFarmingGuildPatches then
    begin
      lcb_fguildtp.Clear();
      lcb_fguildtp.AddItemArray(['Skills necklace', 'Farming cape UNTRIMMED', 'Farming cape TRIMMED']);

      savedIndex := FARMFARMGUILDTP;
      if savedIndex > 0 then
        savedIndex := savedIndex - 1;
      
      newIndex := 0;

      if (savedIndex >= 0) and (savedIndex <= 2) then
        newIndex := savedIndex
      else if teleportPreference = 'Skills necklace' then
        newIndex := 0
      else if teleportPreference = 'Farming cape UNTRIMMED' then
        newIndex := 1
      else if teleportPreference = 'Farming cape TRIMMED' then
        newIndex := 2;

      lcb_fguildtp.SetItemIndex(newIndex);
    end
    else
    begin
      lcb_fguildtp.Clear();
      lcb_fguildtp.AddItemArray(['Not using Farm guild patch']);
      lcb_fguildtp.SetItemIndex(0);
    end;
  end;
end;

procedure TConfig.UpdateHosidiusTeleportDropdown();
var
  hasHosidiusPatches: Boolean;
  currentSelection: String;
  newIndex: Integer;
  Username: String;
  savedIndex: Integer;
  teleportPreference: String;
begin
  hasHosidiusPatches := (Assigned(cb_hhp) and cb_hhp.IsChecked()) or
                       (Assigned(cb_hfp) and cb_hfp.IsChecked());

  if Assigned(lcb_hostp) then
  begin
    if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
      Username := 'NoUserNameSelected'
    else
      Username := Login.Players[Login.PlayerIndex].User;

    if lcb_hostp.ComboBox.GetItems().GetCount() > 0 then
      currentSelection := lcb_hostp.ComboBox.GetText();

    if (currentSelection = 'Xerics Talisman (CHARGED)') or 
       (currentSelection = 'Hosidius TABLET') or 
       (currentSelection = 'House teleport TABLET') or 
       (currentSelection = 'House teleport RUNES') or 
       (currentSelection = 'Construction cape UNTRIMMED') or 
       (currentSelection = 'Construction cape TRIMMED') then
      teleportPreference := currentSelection
    else
      teleportPreference := 'Xerics Talisman (CHARGED)';

    if hasHosidiusPatches then
    begin
      lcb_hostp.Clear();
      lcb_hostp.AddItemArray(['Xerics Talisman (CHARGED)', 'Hosidius TABLET', 'House teleport TABLET', 'House teleport RUNES', 'Construction cape UNTRIMMED', 'Construction cape TRIMMED']);

      savedIndex := FARMHOSIDIUSTP;
      if savedIndex > 0 then
        savedIndex := savedIndex - 1;
      
      newIndex := 0;

      if (savedIndex >= 0) and (savedIndex <= 5) then
        newIndex := savedIndex
      else if teleportPreference = 'Xerics Talisman (CHARGED)' then
        newIndex := 0
      else if teleportPreference = 'Hosidius TABLET' then
        newIndex := 1
      else if teleportPreference = 'House teleport TABLET' then
        newIndex := 2
      else if teleportPreference = 'House teleport RUNES' then
        newIndex := 3
      else if teleportPreference = 'Construction cape UNTRIMMED' then
        newIndex := 4
      else if teleportPreference = 'Construction cape TRIMMED' then
        newIndex := 5;

      lcb_hostp.SetItemIndex(newIndex);
    end
    else
    begin
      lcb_hostp.Clear();
      lcb_hostp.AddItemArray(['Not using Hosidius Patch']);
      lcb_hostp.SetItemIndex(0);
    end;
  end;
end;

procedure TConfig.PatchCheckboxChanged({$H-}sender: TObject){$H+};
begin
  UpdateCatherbyTeleportDropdown();
  UpdateFarmingGuildTeleportDropdown();
  UpdateHosidiusTeleportDropdown();
end;

procedure TConfig.PrePlantedWarningCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if (sender = Self.cb_wbp.CheckBox) and Self.cb_wbp.IsChecked() then
  begin
    ShowMessage('Kandarin Bush Patch* requires a pre-planted whiteberry bush!' + #13#10 + #13#10 +
                'Make sure you have a whiteberry bush already planted at the Kandarin patch before enabling this option.');
  end
  else if (sender = Self.cb_gbp.CheckBox) and Self.cb_gbp.IsChecked() then
  begin
    ShowMessage('Farming Guild Bush Patch* requires a pre-planted whiteberry bush!' + #13#10 + #13#10 +
                'Make sure you have a whiteberry bush already planted at the Farming Guild patch before enabling this option.');
  end
  else if (sender = Self.cb_gcp.CheckBox) and Self.cb_gcp.IsChecked() then
  begin
    ShowMessage('Farming Guild Cactus Patch* requires a pre-planted potato cactus!' + #13#10 + #13#10 +
                'Make sure you have a potato cactus already planted at the Farming Guild patch before enabling this option.');
  end;

  // update teleport dropdowns when pre-planted patches are togled
  UpdateCatherbyTeleportDropdown();
  UpdateFarmingGuildTeleportDropdown();
  UpdateHosidiusTeleportDropdown();
end;

procedure TConfig.FarmRunsCheckboxChanged({$H-}sender: TObject){$H+};
var
  i: Int32;
  isChecked: Boolean;
begin
  isChecked := Self.EnableFarmRunsCheckBox.IsChecked();

  for i := 0 to High(Self.Tabs) do
  begin
    if Self.Tabs[i].getCaption() = 'Farm Run Settings' then
    begin
      Self.Tabs[i].SetTabVisible(isChecked);
    end;
  end;

  if isChecked then
  begin
    ShowMessage('Customise farm run settings in the "Farm Run Settings" tab at the top.');
  end;

  Self.UpdateUIPreview(nil);
end;


function GetHerbSeedName(seedIndex: Integer): String;
begin
  case seedIndex of
    0: Result := 'None';
    1: Result := 'Guam seed';
    2: Result := 'Marrentill seed';
    3: Result := 'Tarromin seed';
    4: Result := 'Harralander seed';
    5: Result := 'Ranarr seed';
    6: Result := 'Toadflax seed';
    7: Result := 'Irit seed';
    8: Result := 'Avantoe seed';
    9: Result := 'Kwuarm seed';
    10: Result := 'Snapdragon seed';
    11: Result := 'Cadantine seed';
    12: Result := 'Lantadyme seed';
    13: Result := 'Dwarf weed seed';
    14: Result := 'Torstol seed';
    else
      Result := 'Ranarr seed';
  end;
end;

function GetFlowerSeedName(seedIndex: Integer): String;
begin
  case seedIndex of
    0: Result := 'None';
    1: Result := 'Limpwurt seed';
    else
      Result := 'None';
  end;
end;

function GetAllotmentSeedName(seedIndex: Integer): String;
begin
  case seedIndex of
    0: Result := 'None';
    1: Result := 'Potato seed';
    2: Result := 'Onion seed';
    3: Result := 'Cabbage seed';
    4: Result := 'Tomato seed';
    5: Result := 'Sweetcorn seed';
    6: Result := 'Strawberry seed';
    7: Result := 'Watermelon seed';
    8: Result := 'Snape grass seed';
    else
      Result := 'None';
  end;
end;

procedure TConfig.CreateFarmRunSettings(tab: TTabSheet);
var
  lb_Script, lb_memo, lb_memo2: TLabel;
  SettingsPanel: TLabeledPanel;
begin
  { Setup farm run settings }
  with lb_Script do
  begin
    Create(tab);
  end;
  Self.FarmHerbsPanel := Self.CreateLabeledPanel(tab, 'Herb Patches', TControl.AdjustToDPI(0), 210, 10, clGreen);
  Self.FarmHerbsPanel.SetWidth(TControl.AdjustToDPI(200));

  Self.FarmAllotmentsPanel := Self.CreateLabeledPanel(tab, 'Allotment Patches', TControl.AdjustToDPI(215), 135, 10, clBlue);
  Self.FarmAllotmentsPanel.SetWidth(TControl.AdjustToDPI(200));

  Self.FarmFlowersPanel := Self.CreateLabeledPanel(tab, 'Flower Patches', TControl.AdjustToDPI(0), 135, 10, clPurple);
  Self.FarmFlowersPanel.SetLeft(TControl.AdjustToDPI(265)); // make panel go right k
  Self.FarmFlowersPanel.SetWidth(TControl.AdjustToDPI(200));

  Self.FarmSpecialPanel := Self.CreateLabeledPanel(tab, 'Special Patches', TControl.AdjustToDPI(215), 135, 10, clRed);
  Self.FarmSpecialPanel.SetLeft(TControl.AdjustToDPI(265));
  Self.FarmSpecialPanel.SetWidth(TControl.AdjustToDPI(200));

  SettingsPanel := Self.CreateLabeledPanel(tab, 'Farm Settings', TControl.AdjustToDPI(0), 350, 10, clNavy);
  SettingsPanel.SetLeft(TControl.AdjustToDPI(535));
  SettingsPanel.SetWidth(TControl.AdjustToDPI(200));

  with lcb_herbseed do
  begin
    Create(tab);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(25));
    SetWidth(TControl.AdjustToDPI(180));
    SetName('lcb_herbseed');
    SetCaption('Herb seed:');

    Caption.SetAlign(alNone);
    Caption.SetLeft(TControl.AdjustToDPI(0));
    Caption.SetTop(TControl.AdjustToDPI(4));
    Caption.SetWidth(TControl.AdjustToDPI(50));

    // Combobox positioning
    ComboBox.SetAlign(alNone);
    ComboBox.SetLeft(TControl.AdjustToDPI(60));
    ComboBox.SetWidth(TControl.AdjustToDPI(120));
    AddItemArray(['None','Guam seed', 'Marrentill seed', 'Tarromin seed', 'Harralander seed', 'Ranarr seed', 'Toadflax seed', 'Irit seed', 'Avantoe seed', 'Kwuarm seed', 'Snapdragon seed', 'Cadantine seed', 'Lantadyme seed', 'Dwarf weed seed', 'Torstol seed', 'Huasca seed']);
    SetItemIndex(StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'HerbSeed', 'Configs/BASettings.ini'), 5));
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
    SetHeight(ComboBox.GetHeight());
  end;

  with lcb_allotmentseed do
  begin
    Create(tab);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(240));
    SetWidth(TControl.AdjustToDPI(180));
    SetName('lcb_allotmentseed');
    SetCaption('Allot seed:');
    Caption.SetAlign(alNone);
    Caption.SetLeft(TControl.AdjustToDPI(0));
    Caption.SetTop(TControl.AdjustToDPI(4));
    Caption.SetWidth(TControl.AdjustToDPI(50));

    // Combobox positioning
    ComboBox.SetAlign(alNone);
    ComboBox.SetLeft(TControl.AdjustToDPI(60));
    ComboBox.SetWidth(TControl.AdjustToDPI(120));
    AddItemArray(['None','Potato seed', 'Onion seed', 'Cabbage seed', 'Tomato seed', 'Sweetcorn seed', 'Strawberry seed', 'Watermelon seed', 'Snape grass seed']);
    SetItemIndex(StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'AllotmentSeed', 'Configs/BASettings.ini'), 0));
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
    SetHeight(ComboBox.GetHeight());
  end;

  with lcb_flowerseed do
  begin
    Create(tab);
    SetLeft(TControl.AdjustToDPI(275));
    SetTop(TControl.AdjustToDPI(25));
    SetWidth(TControl.AdjustToDPI(180));
    SetName('lcb_flowerseed');
    SetCaption('Flower seed:');
    Caption.SetAlign(alNone);
    Caption.SetLeft(TControl.AdjustToDPI(0));
    Caption.SetTop(TControl.AdjustToDPI(4));
    Caption.SetWidth(TControl.AdjustToDPI(60));

    // Combobox positioning
    ComboBox.SetAlign(alNone);
    ComboBox.SetLeft(TControl.AdjustToDPI(70));
    ComboBox.SetWidth(TControl.AdjustToDPI(110));
    AddItemArray(['None','Limpwurt seed']);
    SetItemIndex(StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'FlowerSeed', 'Configs/BASettings.ini'), 0));
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
    SetHeight(ComboBox.GetHeight());
  end;

  // Herb patches
  with cb_ahp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(48));
    SetName('cb_ahp');
    SetFontColor($000000);
    SetCaption('Ardougne Herb Patch');
    SetToolTip('Requires: Ardy Cape 2+ (Equipped or bank)');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'ArdougneHerb', 'Configs/BASettings.ini'), True));
  end;

  with cb_fhp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_ahp.GetTop() + cb_ahp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_fhp');
    SetFontColor($000000);
    SetCaption('Falador Herb Patch');
    SetToolTip('Requires: Explorer''s Ring 2+ (Equipped or bank)');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FaladorHerb', 'Configs/BASettings.ini'), True));
  end;

  with cb_chp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_fhp.GetTop() + cb_fhp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_chp');
    SetFontColor($000000);
    SetCaption('Catherby Herb Patch');
    SetToolTip('Requires: Camelot runes/tablets or Catherby runes/tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyHerb', 'Configs/BASettings.ini'), True));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_hhp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_chp.GetTop() + cb_chp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_hhp');
    SetFontColor($000000);
    SetCaption('Hosidius Herb Patch');
    SetToolTip('Requires: Charged Xeric''s or Hosidius tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'HosidiusHerb', 'Configs/BASettings.ini'), True));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_php do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_hhp.GetTop() + cb_hhp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_php');
    SetFontColor($000000);
    SetCaption('Phasmatys Herb Patch');
    SetToolTip('Requires: Ectophial');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'PortPhasmatysHerb', 'Configs/BASettings.ini'), True));
  end;

  with cb_fgh do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_php.GetTop() + cb_php.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_fgh');
    SetFontColor($000000);
    SetCaption('Farming Guild Herb');
    SetToolTip('Requires: Farming Cape or Skill Necklaces');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildHerb', 'Configs/BASettings.ini'), True));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_whp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_fgh.GetTop() + cb_fgh.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_whp');
    SetFontColor($000000);
    SetCaption('Weiss Herb Patch');
    SetToolTip('Requires: Icy Basalt');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'WeissHerb', 'Configs/BASettings.ini'), False));
  end;

  with cb_shp do
  begin
    Create(Self.FarmHerbsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_whp.GetTop() + cb_whp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_shp');
    SetFontColor($000000);
    SetCaption('Stronghold Herb Patch');
    SetToolTip('Requires: Stony Basalt, 73 Agility, Fremennik Hard Diary');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'StrongholdHerb', 'Configs/BASettings.ini'), False));
  end;

  // Allotment patches
  with cb_capn do
  begin
    Create(Self.FarmAllotmentsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(50));
    SetName('cb_capn');
    SetFontColor($000000);
    SetCaption('Catherby N Allot Patch');
    SetToolTip('Requires: Camelot runes/tablets or Catherby runes/tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyAllotmentN', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_caps do
  begin
    Create(Self.FarmAllotmentsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_capn.GetTop() + cb_capn.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_caps');
    SetFontColor($000000);
    SetCaption('Catherby S Allot Patch');
    SetToolTip('Requires: Camelot runes/tablets or Catherby runes/tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyAllotmentS', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_fgan do
  begin
    Create(Self.FarmAllotmentsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_caps.GetTop() + cb_caps.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_fgan');
    SetFontColor($000000);
    SetCaption('Farming Guild N Allot Patch');
    SetToolTip('Requires: Farming Cape or Skill Necklaces');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentN', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_fgas do
  begin
    Create(Self.FarmAllotmentsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_fgan.GetTop() + cb_fgan.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_fgas');
    SetFontColor($000000);
    SetCaption('Farming Guild S Allot Patch');
    SetToolTip('Requires: Farming Cape or Skill Necklaces');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildAllotmentS', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  // Flower patches
  with cb_afp do
  begin
    Create(Self.FarmFlowersPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(25));
    SetName('cb_afp');
    SetFontColor($000000);
    SetCaption('Ardougne Flower Patch');
    SetToolTip('Requires: Ardy Cape 2+ (Equipped or bank)');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'ArdougneFlower', 'Configs/BASettings.ini'), False));
  end;

  with cb_ffp do
  begin
    Create(Self.FarmFlowersPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_afp.GetTop() + cb_afp.GetHeight() + TControl.AdjustToDPI(10));
    SetName('cb_ffp');
    SetFontColor($000000);
    SetCaption('Falador Flower Patch');
    SetToolTip('Requires: Explorer''s Ring 2+ (Equipped or bank)');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FaladorFlower', 'Configs/BASettings.ini'), False));
  end;

  with cb_cfp do
  begin
    Create(Self.FarmFlowersPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_ffp.GetTop() + cb_ffp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_cfp');
    SetFontColor($000000);
    SetCaption('Catherby Flower Patch');
    SetToolTip('Requires: Camelot runes/tablets or Catherby runes/tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CatherbyFlower', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_hfp do
  begin
    Create(Self.FarmFlowersPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_cfp.GetTop() + cb_cfp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_hfp');
    SetFontColor($000000);
    SetCaption('Hosidius Flower Patch');
    SetToolTip('Requires: Charged Xeric''s or Hosidius tablets');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'HosidiusFlower', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  with cb_gfp do
  begin
    Create(Self.FarmFlowersPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_hfp.GetTop() + cb_hfp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_gfp');
    SetFontColor($000000);
    SetCaption('Farming Guild Flower Patch');
    SetToolTip('Requires: Farming Cape or Skill Necklaces');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildFlower', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PatchCheckboxChanged);
  end;

  // Special patches
  with cb_wbp do
  begin
    Create(Self.FarmSpecialPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(TControl.AdjustToDPI(25));
    SetName('cb_wbp');
    SetFontColor($000000);
    SetCaption('Kandarin Bush Patch*');
    SetToolTip('Requires: Pre-planted White Berry, Ardy Cape 1+');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'KandarinBush', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PrePlantedWarningCheckboxChanged);
  end;

  with cb_gbp do
  begin
    Create(Self.FarmSpecialPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_wbp.GetTop() + cb_wbp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_gbp');
    SetFontColor($000000);
    SetCaption('Farming Guild Bush Patch*');
    SetToolTip('Requires: Farming Cape or Skill Necklaces');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildBush', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PrePlantedWarningCheckboxChanged);
  end;

  with cb_gcp do
  begin
    Create(Self.FarmSpecialPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_gbp.GetTop() + cb_gbp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_gcp');
    SetFontColor($000000);
    SetCaption('Farming Guild Cactus Patch*');
    SetToolTip('Requires: Pre-planted Potato Cactus');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'FarmGuildCactus', 'Configs/BASettings.ini'), False));
    CheckBox.SetOnChange(@PrePlantedWarningCheckboxChanged);
  end;

  with cb_gsn do
  begin
    Create(Self.FarmSpecialPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_gcp.GetTop() + cb_gcp.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_gsn');
    SetFontColor($000000);
    SetCaption('Giant Seaweed North');
    SetToolTip('Requires: Seaweed spores, Digsite Pendant');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'GiantSeaweedN', 'Configs/BASettings.ini'), False));
  end;

  with cb_gss do
  begin
    Create(Self.FarmSpecialPanel.Panel);
    SetLeft(TControl.AdjustToDPI(15));
    SetTop(cb_gsn.GetTop() + cb_gsn.GetHeight() + TControl.AdjustToDPI(5));
    SetName('cb_gss');
    SetFontColor($000000);
    SetCaption('Giant Seaweed South');
    SetToolTip('Requires: Seaweed spores, Digsite Pendant');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'GiantSeaweedS', 'Configs/BASettings.ini'), False));
  end;

  // Teleport preferences
  with lcb_cathtp do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(20));
    SetName('lcb_cathtp');
    SetCaption('Catherby teleport');
    AddItemArray(['Not using Catherby patch']);
    SetItemIndex(0);
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
  end;

  with lcb_fguildtp do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(60));
    SetName('lcb_fguildtp');
    SetCaption('Farming guild teleport');
    AddItemArray(['Not using Farm guild patch']);
    SetItemIndex(0);
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
  end;

  with lcb_hostp do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(100));
    SetName('lcb_hostp');
    SetCaption('Hosidius teleport');
    AddItemArray(['Not using Hosidius Patch']);
    SetItemIndex(0);
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
  end;

  with lcb_compost do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(140));
    SetName('lcb_compost');
    SetCaption('Compost type');
    AddItemArray(['Compost', 'Supercompost', 'Ultracompost', 'Bottomless compost bucket']);
    SetItemIndex(StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'CompostType', 'Configs/BASettings.ini'), 2));
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
  end;

  with lcb_rpouch do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(180));
    SetName('lcb_rpouch');
    SetCaption('Runes Option');
    AddItemArray(['Withdraw individual runes', 'Rune pouch', 'Divine rune pouch']);
    SetItemIndex(StrToIntDef(ReadINI(Username + ' Farm Run Settings', 'RunePouch', 'Configs/BASettings.ini'), 0));
    SetFontColor($000000);
    SetStyle(csDropDownList);
    ComboBox.SetFontColor(0);
  end;

  // Utility options
  with cb_barbdibber do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(220));
    SetName('cb_barbdibber');
    SetFontColor($000000);
    SetCaption('Barbarian dibber');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'BarbDibber', 'Configs/BASettings.ini'), False));
  end;

  with cb_msecat do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(240));
    SetName('cb_msecat');
    SetFontColor($000000);
    SetCaption('Use magic secateurs');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'MagicSecateurs', 'Configs/BASettings.ini'), False));
  end;

  with cb_clherbs do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(260));
    SetName('cb_clherbs');
    SetFontColor($000000);
    SetCaption('Clean herbs?');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'CleanHerbs', 'Configs/BASettings.ini'), True));
  end;

  with cb_runinit do
  begin
    Create(SettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(10));
    SetTop(TControl.AdjustToDPI(280));
    SetName('cb_runinit');
    SetFontColor($000000);
    SetCaption('Do first farm run now');
    SetChecked(StrToBoolDef(ReadINI(Username + ' Farm Run Settings', 'StartFarm', 'Configs/BASettings.ini'), False));
  end;

  // Assign all farm patch shit
  Self.cb_whp := cb_whp;
  Self.cb_shp := cb_shp;
  Self.cb_ahp := cb_ahp;
  Self.cb_fgh := cb_fgh;
  Self.cb_fhp := cb_fhp;
  Self.cb_chp := cb_chp;
  Self.cb_php := cb_php;
  Self.cb_hhp := cb_hhp;
  Self.cb_afp := cb_afp;
  Self.cb_ffp := cb_ffp;
  Self.cb_cfp := cb_cfp;
  Self.cb_hfp := cb_hfp;
  Self.cb_gfp := cb_gfp;
  Self.cb_capn := cb_capn;
  Self.cb_caps := cb_caps;
  Self.cb_fgan := cb_fgan;
  Self.cb_fgas := cb_fgas;
  Self.cb_wbp := cb_wbp;
  Self.cb_gbp := cb_gbp;
  Self.cb_gcp := cb_gcp;
  Self.cb_gsn := cb_gsn;
  Self.cb_gss := cb_gss;
  Self.cb_barbdibber := cb_barbdibber;
  Self.cb_msecat := cb_msecat;

  Self.lcb_herbseed := lcb_herbseed;
  Self.lcb_flowerseed := lcb_flowerseed;
  Self.lcb_allotmentseed := lcb_allotmentseed;
  Self.lcb_compost := lcb_compost;
  Self.lcb_cathtp := lcb_cathtp;
  Self.lcb_hostp := lcb_hostp;
  Self.lcb_rpouch := lcb_rpouch;
  Self.lcb_fguildtp := lcb_fguildtp;

  // Initialize teleport dropdowns
  UpdateCatherbyTeleportDropdown();
  UpdateFarmingGuildTeleportDropdown();
  UpdateHosidiusTeleportDropdown();

  with lb_memo do
  begin
    Create(tab);
    SetLeft(TControl.AdjustToDPI(200));
    SetTop(TControl.AdjustToDPI(415));
    SetFontColor($000000);
    GetFont().SetSize(12);
    if Random(10000) = 0 then
      SetCaption('nice cok')
    else
      SetCaption('Farm Run Include provided by XJ and Student');
    GetFont.SetStyle([fsBold, fsItalic]);
  end;

  with lb_memo2 do
  begin
    Create(tab);
    SetLeft(TControl.AdjustToDPI(0));
    SetTop(TControl.AdjustToDPI(355));
    SetFontColor($0000FF);
    GetFont().SetSize(12);
    SetCaption('Warning: Patches must be raked and auto-weed from Tithe Farm must be enabled.');
    GetFont.SetStyle([fsBold, fsItalic]);
  end;
end;

function TConfig.CreateLabeledPanel(owner: TControl; title: String; top, height: Int32; FontSize: Int32 = 10; Color: TColor = clBlack; FontStyles: TFontStyles = [fsBold]; centerCaption: Boolean = True): TLabeledPanel;
var
  verticalSpacing: Int32;
begin
  verticalSpacing := TControl.AdjustToDPI(3);
  Result.Create(owner);
  with Result do
  begin
    SetCaption(title);

    Panel.SetCaption('');
    Panel.SetBevelWidth(1);
    Panel.SetBevelInner(bvRaised);
    Panel.SetBevelOuter(bvLowered);
    Panel.SetTop(top + verticalSpacing);
    Panel.SetWidth(Self.Form.GetWidth - TControl.AdjustToDPI(25));
    Panel.SetHeight(TControl.AdjustToDPI(height));
    Panel.SetBorderStyle(bsNone);

    Caption.SetAlign(alNone);
    Caption.SetFontSize(FontSize);
    Caption.SetFontColor(Color);
    Caption.GetFont().SetStyle(FontStyles);
    Caption.SetTop(TControl.AdjustToDPI(2));

    if centerCaption then
      Caption.SetLeft(TControl.AdjustToDPI(45))
    else
      Caption.SetLeft(TControl.AdjustToDPI(5));
  end;
end;

procedure TConfig.TestButtonClick({$H-}sender: TObject){$H+};
begin
  if Self.WebHookInput.GetText = '' then
  begin
    ShowMessage('Please enter a Webhook URL');
    Exit;
  end;
  Discord.Webhook.Content := ('Test message from BigAussies Gemstone Crab Slayer');
  Discord.Webhook.URL := Self.WebHookInput.GetText;
  Discord.Send();
  ShowMessage('Test message sent. Please check Discord.');
end;

procedure TConfig.UIPreviewButtonClick({$H-}sender: TObject){$H+};
var
  previewX, previewY: Int32;
  previewBox: TBox;
  fontSize, lineSpacing, headerSpacing, requiredHeight, requiredWidth: Int32;
begin
  previewX := StrToIntDef(Self.UIXPositionInput.GetText(), 10);
  previewY := StrToIntDef(Self.UIYPositionInput.GetText(), 440);

  if (previewX < 0) or (previewX > 1800) or (previewY < 0) or (previewY > 1000) then
  begin
    ShowMessage('Position must be within screen bounds (0-1800 for X, 0-1000 for Y)');
    Exit;
  end;

  fontSize := StrToIntDef(Self.UIFontSizeInput.GetText(), 11);
  if fontSize < 6 then fontSize := 6;
  if fontSize > 20 then fontSize := 20;

  lineSpacing := fontSize + 2;
  headerSpacing := fontSize + 4;
  
  if Self.EnableFarmRunsCheckBox.IsChecked() then
    requiredHeight := 12 + headerSpacing + (lineSpacing * 5) + fontSize
  else
    requiredHeight := 12 + headerSpacing + (lineSpacing * 4) + fontSize;
  requiredWidth := Round(fontSize * 12) + 20;

  {$IFNDEF SRL_DISABLE_REMOTEINPUT}
  if not RSClient.RemoteInput.IsSetup() then
  begin
    try
      RSClient.RemoteInput.Setup();
    except
      ShowMessage('Unable to setup RemoteInput, is remote input enabled?');
      Exit;
    end;
  end;
  {$ENDIF}

  try
    if not Assigned(RSClient.Image()) then
    begin
      ShowMessage('Cannot access client image.');
      Exit;
    end;

    previewBox := Box(previewX, previewY, previewX + requiredWidth, previewY + requiredHeight);
    RSClient.Image().Clear();
    Self.DrawPersistentPreview(previewBox);
    ShowMessage('Preview displayed on runescape client.');

  except
    ShowMessage('Error drawing preview. Make sure game client has been selected and remote input is enabled.');
  end;
end;

procedure TConfig.DrawPersistentPreview(previewBox: TBox);
var
  tempScript: GemStoneCrabSlayer;
begin
  tempScript.UIEnabled := True;
  tempScript.DrawStatusOverlay(True, previewBox);
end;

procedure TConfig.ValidateFontSize({$H-}sender: TObject){$H+};
var
  fontSize: Int32;
  fontSizeText: String;
begin
  if not Assigned(Self.UIFontSizeInput) then Exit;

  fontSizeText := Self.UIFontSizeInput.GetText();
  fontSize := StrToIntDef(fontSizeText, 11);

  // Ensure font is not below 6 as its so small and above 20, background wont cover
  if fontSize < 6 then
  begin
    fontSize := 6;
    Self.UIFontSizeInput.SetText('6');
  end
  else if fontSize > 20 then
  begin
    fontSize := 20;
    Self.UIFontSizeInput.SetText('20');
  end;

  Self.UpdateUIPreview(nil);
end;

procedure TConfig.UIResetButtonClick({$H-}sender: TObject){$H+};
begin
  Self.UIXPositionInput.SetText('10');
  Self.UIYPositionInput.SetText('230');
  Self.UIFontSizeInput.SetText('11');
  Self.UIBackgroundColorCombo.SetItemIndex(0);
  Self.UITextColorCombo.SetItemIndex(0);
  Self.UIBackgroundColorHexInput.SetText('2D2D30');
  Self.UITextColorHexInput.SetText('FFFFFF');
  Self.UIBackgroundColorHexInput.SetVisible(False);
  Self.UITextColorHexInput.SetVisible(False);
  Self.UpdateUIPreview(nil);
  ShowMessage('UI appearance and position reset to default values.');
end;

procedure TConfig.UIBackgroundColorChanged({$H-}sender: TObject){$H+};
begin
  if Self.UIBackgroundColorCombo.GetItemIndex() = 6 then
    Self.UIBackgroundColorHexInput.SetVisible(True)
  else
    Self.UIBackgroundColorHexInput.SetVisible(False);

  Self.UpdateUIPreview(nil);
end;

procedure TConfig.UITextColorChanged({$H-}sender: TObject){$H+};
begin
  if Self.UITextColorCombo.GetItemIndex() = 7 then
    Self.UITextColorHexInput.SetVisible(True)
  else
    Self.UITextColorHexInput.SetVisible(False);

  Self.UpdateUIPreview(nil);
end;

procedure TConfig.UpdateUIPreview({$H-}sender: TObject){$H+};
var
  previewWidth, previewHeight: Int32;
  guiPreviewWidth, guiPreviewHeight: Int32;
  previewText: String;
  fontSize, lineSpacing, headerSpacing: Int32;
  bgColor, textColor: TColor;
begin
  if not Assigned(Self.UIPreviewPanel) then Exit;

  fontSize := StrToIntDef(Self.UIFontSizeInput.GetText(), 11);

  if fontSize < 6 then fontSize := 6;
  if fontSize > 20 then fontSize := 20;

  case Self.UIBackgroundColorCombo.GetItemIndex() of
    0: bgColor := $2D2D30;
    1: bgColor := $000000;
    2: bgColor := $FFFFFF;
    3: bgColor := $0000FF;
    4: bgColor := $00FF00;
    5: bgColor := $FF0000;
    6: bgColor := StrToIntDef('$' + Self.UIBackgroundColorHexInput.GetText(), $2D2D30);
    else bgColor := $2D2D30;
  end;

  case Self.UITextColorCombo.GetItemIndex() of
    0: textColor := $FFFFFF;
    1: textColor := $000000;
    2: textColor := $C0C0C0;
    3: textColor := $0000FF;
    4: textColor := $00FF00;
    5: textColor := $FF0000;
    6: textColor := $00FFFF;
    7: textColor := StrToIntDef('$' + Self.UITextColorHexInput.GetText(), $FFFFFF);
    else textColor := $FFFFFF;
  end;

  if fontSize < 6 then fontSize := 6;
  if fontSize > 20 then fontSize := 20;

  lineSpacing := fontSize + 2;
  headerSpacing := fontSize + 4;

  if Assigned(Self.EnableFarmRunsCheckBox) and Self.EnableFarmRunsCheckBox.IsChecked() then
    previewHeight := 12 + headerSpacing + (lineSpacing * 5) + fontSize
  else
    previewHeight := 12 + headerSpacing + (lineSpacing * 4) + fontSize;

  previewWidth := Round(fontSize * 12) + 20;

  guiPreviewWidth := Round(previewWidth * 1.5);
  guiPreviewHeight := Round(previewHeight * 1.4);
  Self.UIPreviewPanel.SetWidth(guiPreviewWidth);
  Self.UIPreviewPanel.SetHeight(guiPreviewHeight);
  Self.UIPreviewPanel.SetColor(bgColor);

  if Assigned(Self.UIBackgroundColorPreview) then
    Self.UIBackgroundColorPreview.SetColor(bgColor);
  if Assigned(Self.UITextColorPreview) then
    Self.UITextColorPreview.SetColor(textColor);

  previewText := 'GemStone Crab Slayer' + LineEnding +
                'Status: Attacking Boss' + LineEnding +
                'Runtime: 1h 23m' + LineEnding +
                'XP/HR: ' + FormatRoundedNumber(45000) + LineEnding;
  
  if Self.EnableFarmRunsCheckBox.IsChecked() then
  begin
    previewText := previewText + 'Farm Runs Completed: 24' + LineEnding;
    previewText := previewText + 'Next Farm Run: 2h 15m' + LineEnding;
  end;
  
  previewText := previewText + 'Script Revision: ' + {$MACRO SCRIPT_REVISION};

  if Assigned(Self.UIPreviewLabel) then
  begin
    Self.UIPreviewLabel.SetWidth(guiPreviewWidth - 6);
    Self.UIPreviewLabel.SetHeight(guiPreviewHeight - 6);
    Self.UIPreviewLabel.SetFontSize(Max(6, fontSize));

    Self.UIPreviewLabel.SetCaption('');
    Self.UIPreviewLabel.SetFontColorEx(textColor);
    Self.UIPreviewLabel.SetCaption(previewText);

    Self.UIPreviewLabel.Invalidate();
    Self.UIPreviewLabel.Repaint();
  end;
end;

procedure TConfig.UIEnabledCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.UIXPositionInput) then
    Self.UIXPositionInput.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIYPositionInput) then
    Self.UIYPositionInput.SetVisible(Self.UIEnabledCheckBox.IsChecked());

  if Assigned(Self.UIPreviewButton) then
    Self.UIPreviewButton.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIResetButton) then
    Self.UIResetButton.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIPreviewPanel) then
    Self.UIPreviewPanel.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIPreviewTitleLabel) then
    Self.UIPreviewTitleLabel.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIFontSizeInput) then
    Self.UIFontSizeInput.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIBackgroundColorCombo) then
    Self.UIBackgroundColorCombo.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UITextColorCombo) then
    Self.UITextColorCombo.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UIBackgroundColorHexInput) then
    Self.UIBackgroundColorHexInput.SetVisible(Self.UIEnabledCheckBox.IsChecked() and (Self.UIBackgroundColorCombo.GetItemIndex() = 6));
  if Assigned(Self.UITextColorHexInput) then
    Self.UITextColorHexInput.SetVisible(Self.UIEnabledCheckBox.IsChecked() and (Self.UITextColorCombo.GetItemIndex() = 7));
  if Assigned(Self.UIBackgroundColorPreview) then
    Self.UIBackgroundColorPreview.SetVisible(Self.UIEnabledCheckBox.IsChecked());
  if Assigned(Self.UITextColorPreview) then
    Self.UITextColorPreview.SetVisible(Self.UIEnabledCheckBox.IsChecked());
end;

procedure TConfig.Run(); override;
var
  tab: TTabSheet;
  i: Int32;
  SavedWebhookURL: String;
  SavedEnableWebhooks: Boolean;
  SavedHourlyReports, SavedSessionSummary, SavedLoseFocus, SavedEnableWorldHopping, SavedUseBoosts, SavedUseDharoks, SavedUseDragonBattleaxe, SavedUseSpecialAttacks, SavedUseQuickPrayers, SavedEnablePrayerFlick, SavedStopOnDegrade, SavedEnableBoltEnchanting, SavedEnableFarmRuns: Boolean;
  SavedWorldHopInterval, SavedRepotInterval: Integer;
  panelTop: Int32;
  SavedOverrideBreaks: Boolean;
  SavedCustomBreakInterval, SavedCustomBreakDuration: Integer;
  SavedDharoksTargetHP: Integer;
  SavedDebugMode: Boolean;
begin
  if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  Self.Setup('BigAussies Gemstone Crab Slayer');

  Self.Start.SetOnClick(@Self.StartScript);

  WLSettings.RemoteInput.BlockInput := True;

  // Check for script updates
  GemStoneCrabBot.CheckForUpdates();

  // Show update warning dialog if update is available
  if GemStoneCrabBot.UpdateAvailable then
  begin
    if MessageDlg(
      'Script Update Available',
      'A newer version of the script is available!' + LineEnding + LineEnding +
      'Current version: ' + {$MACRO SCRIPT_REVISION} + LineEnding +
      'Latest version: ' + ToStr(GemStoneCrabBot.LatestRevision) + LineEnding + LineEnding +
      'Please update your script from the WaspLauncher.' + LineEnding + LineEnding +
      'Do you want to continue with the current version?',
      TMsgDlgType.mtWarning,
      [mbYes, mbNo]
    ) = 7 then
    begin
      WriteLn('User chose to stop script');
      TerminateScript('Script update available - please update before running');
    end;
  end;

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);
  InitializeAccountManager();
  Self.LoadUserSettings();

  SavedWebhookURL := ReadINI(Username + ' Webhook Settings', 'WebhookURL', 'Configs/BASettings.ini');
  SavedEnableWebhooks := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'EnableWebhooks', 'Configs/BASettings.ini'), False);
  SavedHourlyReports := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'HourlyReports', 'Configs/BASettings.ini'), True);
  SavedSessionSummary := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'SessionSummary', 'Configs/BASettings.ini'), True);
  SavedLoseFocus := StrToBoolDef(ReadINI(Username + ' Antiban Manager', 'LoseFocus', 'Configs/BASettings.ini'), True);
  SavedEnableWorldHopping := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', 'Configs/BASettings.ini'), False);
  SavedWorldHopInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', 'Configs/BASettings.ini'), 45);
  SavedUseBoosts := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseBoosts', 'Configs/BASettings.ini'), False);
  SavedRepotInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'RepotInterval', 'Configs/BASettings.ini'), 5);
  SavedUseDharoks := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseDharoks', 'Configs/BASettings.ini'), False);
  SavedUseDragonBattleaxe := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseDragonBattleaxe', 'Configs/BASettings.ini'), False);
  SavedUseSpecialAttacks := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseSpecialAttacks', 'Configs/BASettings.ini'), False);
  SavedUseQuickPrayers := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'UseQuickPrayers', 'Configs/BASettings.ini'), False);
  SavedEnableBoltEnchanting := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableBoltEnchanting', 'Configs/BASettings.ini'), False);
  SavedEnableFarmRuns := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableFarmRuns', 'Configs/BASettings.ini'), False);
  SavedDharoksTargetHP := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'DharoksTargetHP', 'Configs/BASettings.ini'), 1);
  SavedEnablePrayerFlick := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnablePrayerFlick', 'Configs/BASettings.ini'), False);
  SavedStopOnDegrade := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'StopOnDegrade', 'Configs/BASettings.ini'), False);
  SavedDebugMode := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'DebugMode', 'Configs/BASettings.ini'), False);

  if SavedDharoksTargetHP < 1 then
    SavedDharoksTargetHP := 1
  else if SavedDharoksTargetHP > 99 then
    SavedDharoksTargetHP := 99;

  SavedOverrideBreaks := StrToBoolDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'OverrideBreaks', 'Configs/BASettings.ini'), False);
  SavedCustomBreakInterval := StrToIntDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakInterval', 'Configs/BASettings.ini'), 60);
  SavedCustomBreakDuration := StrToIntDef(ReadINI(Username + 'Gemstone Crab Antiban Manager', 'CustomBreakDuration', 'Configs/BASettings.ini'), 5);

  Self.ScriptSettingsPanel := Self.CreateLabeledPanel(tab, 'Script Settings', TControl.AdjustToDPI(140), 200, 10, clOrange, [fsBold], False);
  Self.ScriptSettingsPanel.SetLeft(TControl.AdjustToDPI(10));

  with Self.UseBoostsCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Use Boosts');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(TControl.AdjustToDPI(25));
    SetHint('Drinks any potions in your inventory during combat.');
    SetChecked(SavedUseBoosts);
    CheckBox.SetOnChange(@BoostCheckboxChanged);
  end;

  with Self.RepotIntervalInput do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Boost Interval (minutes)');
    SetLeft(Self.UseBoostsCheckBox.GetRight() + TControl.AdjustToDPI(80));
    SetTop(TControl.AdjustToDPI(5));
    SetWidth(TControl.AdjustToDPI(160));
    SetText(IntToStr(SavedRepotInterval));
    SetHint('How often to drink potions (15% random variation)');
    Edit.SetOnKeyPress(@Edit.NumberField);
  end;

  with Self.UseDharoksCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Dharoks Mode');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UseBoostsCheckBox.GetTop() + TControl.AdjustToDPI(35));
    SetHint('Enables Dharoks mode -  Requires Locator orb or Dwarven rock cake.');
    SetChecked(SavedUseDharoks);
    CheckBox.SetOnChange(@DharoksCheckboxChanged);
  end;

  with Self.DharoksTargetHPInput do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Dharoks Target HP (1-99)');
    SetLeft(Self.UseDharoksCheckBox.GetRight() + TControl.AdjustToDPI(60));
    SetTop(TControl.AdjustToDPI(45));
    SetWidth(TControl.AdjustToDPI(160));
    SetText(IntToStr(SavedDharoksTargetHP));
    SetHint('Target HP for Dharoks mode (reduces to target, then waits for HP to rise 3-5 points before reducing again)');
    Edit.SetOnKeyPress(@Edit.NumberField);
  end;

  with Self.EnablePrayerFlickCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Prayer Flicking');
    SetLeft(Self.DharoksTargetHPInput.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.UseDharoksCheckBox.GetTop());
    SetHint('Flicks Rapid Heal prayer to prevent HP regeneration (only works with Dharoks mode).');
    SetChecked(SavedEnablePrayerFlick);
    SetVisible(SavedUseDharoks);
  end;

  with Self.StopOnDegradeCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Stop on Degrade');
    SetLeft(Self.EnablePrayerFlickCheckBox.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.UseDharoksCheckBox.GetTop());
    SetHint('Terminate script when Dharoks armour degrades.');
    SetChecked(SavedStopOnDegrade);
    SetVisible(SavedUseDharoks);
  end;

  with Self.EnableFarmRunsCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Enable Farm Runs [BETA FEATURE]');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UseDharoksCheckBox.GetTop() + TControl.AdjustToDPI(35));
    SetHint('Enables farm runs, This is a beta feature and you may get stuck or terminate.');
    SetChecked(SavedEnableFarmRuns);
    CheckBox.SetOnChange(@FarmRunsCheckboxChanged);
  end;

  with Self.UseQuickPrayersCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Use Quick Prayers');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.EnableFarmRunsCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetHint('Automatically enables quick prayers during combat (requires quick prayers to be set up).');
    SetChecked(SavedUseQuickPrayers);
    CheckBox.SetOnChange(@QuickPrayersCheckboxChanged);
  end;

  with Self.EnableBoltEnchantingCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Enable Bolt Enchanting');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UseQuickPrayersCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetHint('Enables bolt enchanting during combat using Enchant Crossbow Bolt spell.');
    SetChecked(SavedEnableBoltEnchanting);
  end;

  with Self.UseSpecialAttacksCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Use Special Attacks');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.EnableBoltEnchantingCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetHint('Uses special attacks when available.');
    SetChecked(SavedUseSpecialAttacks);
    CheckBox.SetOnChange(@SpecialAttacksCheckboxChanged);
  end;

  with Self.UseDragonBattleaxeCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption('Use Dragon Battleaxe');
    SetLeft(Self.UseSpecialAttacksCheckBox.GetRight() + TControl.AdjustToDPI(60));
    SetTop(Self.EnableBoltEnchantingCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetHint('Uses Dragon Battleaxe special attack when available (requires Dragon Battleaxe in inventory).');
    SetChecked(SavedUseDragonBattleaxe);
    CheckBox.SetOnChange(@DragonBattleaxeCheckboxChanged);
  end;

  if SavedUseSpecialAttacks and SavedUseDragonBattleaxe then
  begin
    Self.UseSpecialAttacksCheckBox.SetChecked(True);
    Self.UseDragonBattleaxeCheckBox.SetChecked(False);
  end;

  if SavedUseDharoks then
  begin
    Self.UseSpecialAttacksCheckBox.SetChecked(False);
  end;

  with Self.EnableWebhooksCheckBox do
  begin
    Create(Self.ScriptSettingsPanel.Panel);
    SetCaption("Discord Notifications");
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UseSpecialAttacksCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetHint('Enable Discord notifications.');
    SetChecked(SavedEnableWebhooks);
    CheckBox.SetOnChange(@WebhooksCheckboxChanged);
  end;

  panelTop := Self.ScriptSettingsPanel.GetTop() + Self.ScriptSettingsPanel.GetHeight() + TControl.AdjustToDPI(3);
  Self.DiscordPanel := Self.CreateLabeledPanel(tab, 'Discord Settings', panelTop, 95, 10, clBlue, [fsBold], False);
  Self.DiscordPanel.SetLeft(TControl.AdjustToDPI(10));

  with Self.WebhookInfo do
  begin
    Create(Self.DiscordPanel.Panel);
    SetLeft(TControl.AdjustToDPI(150));
    SetTop(TControl.AdjustToDPI(5));
    SetCaption('Click here to learn how to generate your own Discord webhook URL');
    SetHint('Click here to learn how to generate your own Discord webhook URL');
    setOnClick(@OpenURL);
    SetFontSize(TControl.AdjustToDPI(9));
    SetFontColor(clBlue);
  end;

  with Self.WebHookInput do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Webhook URL');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(TControl.AdjustToDPI(25));
    SetWidth(TControl.AdjustToDPI(350));
    SetText(SavedWebhookURL);
    SetPasswordChar('*');
    SetHint('Your Discord webhook URL.');
  end;

  with Self.TestButton do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Test Webhook');
    SetLeft(Self.WebHookInput.GetRight() + TControl.AdjustToDPI(10));
    SetTop(Self.WebHookInput.GetTop() + TControl.AdjustToDPI(15));
    SetWidth(TControl.AdjustToDPI(90));
    SetHeight(TControl.AdjustToDPI(25));
    SetOnClick(@TestButtonClick);
    SetHint('Send a test message to your webhook.');
  end;

  with Self.HourlyReportsCheckBox do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Hourly Progress Reports');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.WebHookInput.GetTop() + TControl.AdjustToDPI(50));
    SetHint('Sends detailed progress embeds every hour');
    SetChecked(SavedHourlyReports);
  end;

  with Self.SessionSummaryCheckBox do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Session Summary on Stop');
    SetLeft(Self.HourlyReportsCheckBox.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.HourlyReportsCheckBox.GetTop());
    SetHint('Sends a detailed summary embed when script stops');
    SetChecked(SavedSessionSummary);
  end;

  Self.WebhooksCheckboxChanged(nil);
  Self.WorldHoppingCheckboxChanged(nil);
  Self.BoostCheckboxChanged(nil);
  Self.OverrideBreaksCheckboxChanged(nil);
  Self.DharoksCheckboxChanged(nil);

  Self.AddTab('Farm Run Settings');
  tab := Self.Tabs[High(Self.Tabs)];
  Self.CreateFarmRunSettings(tab);

  for i := 0 to High(Self.Tabs) do
  begin
    if Self.Tabs[i].getCaption() = 'Farm Run Settings' then
    begin
      Self.Tabs[i].SetTabVisible(SavedEnableFarmRuns);
    end;
  end;

  Self.CreateAntibanManager();

  for tab in Self.Tabs do
  begin
    if tab.GetCaption() = 'Antiban Manager' then
    begin
      with Self.LoseFocusCheckBox do
      begin
        Create(tab);
        SetCaption('Lose Focus');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(220));
        SetChecked(SavedLoseFocus);
        SetHint('Enable or disable losing client focus during combat.');
      end;

      with Self.OverrideBreaksCheckBox do
      begin
        Create(tab);
        SetCaption('Override Default Breaks');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(260));
        SetChecked(SavedOverrideBreaks);
        SetHint('Override the default WaspLib break intervals with custom settings.');
        CheckBox.SetOnChange(@OverrideBreaksCheckboxChanged);
      end;

      with Self.CustomBreakIntervalInput do
      begin
        Create(tab);
        SetCaption('Break Interval (minutes)');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(280));
        SetWidth(TControl.AdjustToDPI(160));
        SetText(IntToStr(SavedCustomBreakInterval));
        SetHint('How often to take breaks (e.g., 60 = every hour). Includes 25% randomness.');
        Edit.SetOnKeyPress(@Edit.NumberField);
      end;

      with Self.CustomBreakDurationInput do
      begin
        Create(tab);
        SetCaption('Break Duration (minutes)');
        SetLeft(TControl.AdjustToDPI(270));
        SetTop(TControl.AdjustToDPI(280));
        SetWidth(TControl.AdjustToDPI(160));
        SetText(IntToStr(SavedCustomBreakDuration));
        SetHint('How long breaks should last (e.g., 5 = 5 minute break). Includes 33% randomness.');
        Edit.SetOnKeyPress(@Edit.NumberField);
      end;

      with Self.EnableWorldHoppingCheckBox do
      begin
        Create(tab);
        SetCaption('Enable World Hopping');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(330));
        SetHint('Hop worlds at random intervals. Requires at least 2 worlds in player setup.');
        SetChecked(SavedEnableWorldHopping);
        CheckBox.SetOnChange(@WorldHoppingCheckboxChanged);
      end;

      with Self.WorldHopIntervalInput do
      begin
        Create(tab);
        SetCaption('World Hop Interval (minutes)');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(350));
        SetWidth(TControl.AdjustToDPI(160));
        SetText(IntToStr(SavedWorldHopInterval));
        SetHint('Interval in minutes between world hops (10% random variation)');
        Edit.SetOnKeyPress(@Edit.NumberField);
      end;

      Break;
    end;
  end;

  Self.WorldHoppingCheckboxChanged(nil);

  Self.AddTab('UI Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.UISettingsPanel := Self.CreateLabeledPanel(tab, 'UI Overlay Settings', TControl.AdjustToDPI(10), 380, 10, clGreen);
  Self.UISettingsPanel.SetLeft(TControl.AdjustToDPI(10));
  Self.UISettingsPanel.Panel.SetWidth(TControl.AdjustToDPI(720));

  with Self.UIEnabledCheckBox do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Enable UI Overlay');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(TControl.AdjustToDPI(25));
    SetHint('Shows/hides the status overlay.');
    SetChecked(True);
    CheckBox.SetOnChange(@UIEnabledCheckboxChanged);
  end;

  with Self.UIXPositionInput do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('X Position');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UIEnabledCheckBox.GetTop() + TControl.AdjustToDPI(30));
    SetWidth(TControl.AdjustToDPI(100));
    SetText('10');
    SetHint('Horizontal position of the UI overlay (pixels from left edge)');
    Edit.SetOnKeyPress(@Edit.NumberField);
  end;

  with Self.UIYPositionInput do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Y Position');
    SetLeft(Self.UIXPositionInput.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.UIXPositionInput.GetTop());
    SetWidth(TControl.AdjustToDPI(100));
    SetText('246');
    SetHint('Vertical position of the UI overlay (pixels from top edge)');
    Edit.SetOnKeyPress(@Edit.NumberField);
  end;

  with Self.UIPreviewButton do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Preview Settings');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UIYPositionInput.GetTop() + TControl.AdjustToDPI(210));
    SetWidth(TControl.AdjustToDPI(120));
    SetHeight(TControl.AdjustToDPI(25));
    SetOnClick(@UIPreviewButtonClick);
    SetHint('Shows a live preview of the UI overlay position and size on the game client');
  end;

  with Self.UIResetButton do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Reset to Default');
    SetLeft(Self.UIPreviewButton.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.UIPreviewButton.GetTop());
    SetWidth(TControl.AdjustToDPI(120));
    SetHeight(TControl.AdjustToDPI(25));
    SetOnClick(@UIResetButtonClick);
    SetHint('Reset UI position and size to default values');
  end;

  // Add Font Size control
  with Self.UIFontSizeInput do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Font Size');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UIYPositionInput.GetTop() + TControl.AdjustToDPI(150));
    SetWidth(TControl.AdjustToDPI(90));
    SetText('10');
    SetHint('Font size for the UI text (6-20)');
    Edit.SetOnKeyPress(@Edit.NumberField);
    Edit.SetOnChange(@UpdateUIPreview);
    Edit.SetOnExit(@ValidateFontSize);
  end;

  with Self.UIBackgroundColorCombo do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Background Color');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UIYPositionInput.GetTop() + TControl.AdjustToDPI(50));
    SetWidth(TControl.AdjustToDPI(130));
    SetStyle(csDropDownList);
    AddItem('Dark Gray');
    AddItem('Transparent'); // Black = Transparent dunno why but sure its cool
    AddItem('White');
    AddItem('Red');
    AddItem('Green');
    AddItem('Blue');
    AddItem('Custom (Hex)');
    SetItemIndex(0); // Default to Dark Gray
    SetHint('Choose background color or use custom hex');
    ComboBox.SetOnChange(@UIBackgroundColorChanged);
  end;

  with Self.UIBackgroundColorPreview do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetLeft(Self.UIBackgroundColorCombo.GetRight() + TControl.AdjustToDPI(5));
    SetTop(Self.UIBackgroundColorCombo.GetTop() + TControl.AdjustToDPI(20));
    SetWidth(TControl.AdjustToDPI(30));
    SetHeight(TControl.AdjustToDPI(25));
    SetColor($2D2D30);
    SetBevelOuter(bvLowered);
  end;

  with Self.UIBackgroundColorHexInput do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Custom BG Hex');
    SetLeft(Self.UIBackgroundColorPreview.GetRight() + TControl.AdjustToDPI(10));
    SetTop(Self.UIBackgroundColorCombo.GetTop());
    SetWidth(TControl.AdjustToDPI(110));
    SetText('2D2D30');
    SetHint('Enter hex color without # (e.g., FF0000 for red)');
    SetVisible(False);
    Edit.SetOnChange(@UpdateUIPreview);
  end;

  with Self.UITextColorCombo do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Text Color');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.UIYPositionInput.GetTop() + TControl.AdjustToDPI(100));
    SetWidth(TControl.AdjustToDPI(130));
    SetStyle(csDropDownList);
    AddItem('White');
    AddItem('Transparent'); // Black = Transparent dunno why but sure its cool
    AddItem('Light Gray');
    AddItem('Red');
    AddItem('Green');
    AddItem('Blue');
    AddItem('Yellow');
    AddItem('Custom (Hex)');
    SetItemIndex(0); // Default to White
    SetHint('Choose text color or use custom hex');
    ComboBox.SetOnChange(@UITextColorChanged);
  end;

  with Self.UITextColorPreview do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetLeft(Self.UITextColorCombo.GetRight() + TControl.AdjustToDPI(5));
    SetTop(Self.UITextColorCombo.GetTop() + TControl.AdjustToDPI(20));
    SetWidth(TControl.AdjustToDPI(30));
    SetHeight(TControl.AdjustToDPI(25));
    SetColor($FFFFFF);
    SetBevelOuter(bvLowered);
  end;

  with Self.UITextColorHexInput do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetCaption('Custom Text Hex');
    SetLeft(Self.UITextColorPreview.GetRight() + TControl.AdjustToDPI(10));
    SetTop(Self.UITextColorCombo.GetTop());
    SetWidth(TControl.AdjustToDPI(110));
    SetText('FFFFFF');
    SetHint('Enter hex color without # (e.g., FF0000 for red)');
    SetVisible(False);
    Edit.SetOnChange(@UpdateUIPreview);
  end;

  with Self.UIPreviewTitleLabel do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(310));
    SetTop(TControl.AdjustToDPI(5));
    SetCaption('Live Preview:');
    SetFontSize(TControl.AdjustToDPI(10));
    GetFont().SetStyle([fsBold]);
  end;

  with Self.UIPreviewPanel do
  begin
    Create(Self.UISettingsPanel.Panel);
    SetLeft(TControl.AdjustToDPI(310));
    SetTop(TControl.AdjustToDPI(25));
    SetWidth(120);
    SetHeight(78);
    SetColor($2D2D30);
    SetBevelInner(bvRaised);
    SetBevelOuter(bvLowered);
    SetBevelWidth(1);
  end;

  with Self.UIPreviewLabel do
  begin
    Create(Self.UIPreviewPanel);
    SetLeft(3);
    SetTop(3);
    SetAutoSize(False);
    SetWidth(120 - 6);
    SetHeight(78 - 6);
    SetFontColor($FFFFFF);
    SetFontSize(TControl.AdjustToDPI(8));
    SetCaption('GemStone Crab Slayer' + LineEnding +
              'Status: Searching for crab' + LineEnding +
              'Runtime: 00:15:30' + LineEnding +
              'XP/HR: 45,000' + LineEnding +
             // 'SRL: v7.21.1' + LineEnding +
             // 'Wasp: v20.3.8' + LineEnding +
              'Script Revision: 9');
  end;

  Self.LoadUISettings();

  Self.UIEnabledCheckboxChanged(nil);
  Self.UpdateUIPreview(nil);

  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;

var
  Config: TConfig;
{$ENDIF}

procedure GemStoneCrabSlayer.SendTerminationNotification();
begin

  Self.SendSessionSummary();
end;

procedure GemStoneCrabSlayer.CheckHourlyReport();
var
  CurrentTime: Int64;
begin
  CurrentTime := Self.RunningTime.ElapsedTime;

  if (CurrentTime - Self.LastHourlyReportTime) >= 3600000 then
  begin
    Self.SendHourlyReport();
    Self.LastHourlyReportTime := CurrentTime;
  end;
end;

procedure GemStoneCrabSlayer.CheckSystemUpdate();
var
  CurrentTime: UInt64;
  SystemUpdateThreshold: Integer;
begin
  CurrentTime := GetTickCount();

  if (CurrentTime - Self.LastSystemUpdateCheck) < 30000 then
    Exit;

  Self.LastSystemUpdateCheck := CurrentTime;

  SystemUpdateThreshold := 15;

  if Chat.CheckSystemUpdate(SystemUpdateThreshold) then
  begin
    WriteLn('SYSTEM UPDATE DETECTED! Server going down in ' + IntToStr(SystemUpdateThreshold) + ' minutes or less!');

    if not Self.SystemUpdateWarningShown then
    begin
      Self.SystemUpdateWarningShown := True;

      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**SYSTEM UPDATE DETECTED** :warning: Server going down in ' + IntToStr(SystemUpdateThreshold) + ' minutes or less! Preparing to logout...';
          Discord.Send();
        except
          WriteLn('[Discord] Failed to send system update warning');
        end;
      end;
    end;

    // Only logout if we're NOT in combat
    if not (Self.InCombat or Self.IsAttacking) then
    begin
      WriteLn('Not in combat - logging out safely for system update');

      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**SAFE LOGOUT** :white_check_mark: Successfully logged out before system update. Runtime: ' + SRL.MsToTime(GetTimeRunning(), Time_Short);
          Discord.SendScreenshot(False);
        except
          WriteLn('[Discord] Failed to send safe logout notification');
        end;
      end;

      Logout.ClickLogout();
      TerminateScript('System update - safe logout completed');
    end
    else
    begin
      WriteLn('Currently in combat - CANNOT logout during combat! Waiting for combat to end...');
      WriteLn('WARNING: Server will shutdown soon! Combat must end naturally before logout!');
    end;
  end;
end;

procedure GemStoneCrabSlayer.SendHourlyReport();
var
  EmbedIdx: Int32;
  TotalXPGained: Int32;
  XPPerHourActive, XPPerHourTotal: Int32;
begin
  if not SENDHOURLYREPORTMSG or not ENABLEWEBHOOKS then Exit;

  CurrentXP := Self.SafeReadXPBar();
  TotalXPGained := CurrentXP - Self.StartXP;

  XPPerHourActive := Round(TotalXPGained / (ActiveTimer.ElapsedTime / 3600000));
  XPPerHourTotal := Round(TotalXPGained / (RunningTime.ElapsedTime / 3600000));

  try
    Discord.Webhook.Content := '**Hourly Progress Report** :chart_with_upwards_trend:';

    EmbedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[EmbedIdx].Title := 'BigAussies Gemstone Crab Slayer - Hourly Report';
    Discord.Webhook.Embeds[EmbedIdx].Color := $FFA500;
    Discord.Webhook.Embeds[EmbedIdx].Description := 'Runtime: ' + SRL.MsToTime(GetTimeRunning, Time_Short) + LineEnding +
                                                    'XP Gained: ' + FormatRoundedNumber(TotalXPGained) + LineEnding +
                                                    'XP/Hour (Active): ' + FormatRoundedNumber(XPPerHourActive) + LineEnding +
                                                    'XP/Hour (Total): ' + FormatRoundedNumber(XPPerHourTotal) + LineEnding +
                                                    'Farm Runs Completed: ' + IntToStr(Self.FarmRun.RunsComplete);

    if Discord.Send() then
      WriteLn('[Discord] Hourly report sent!')
    else
      WriteLn('[Discord] Failed to send hourly report: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending hourly report: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.SendSessionSummary();
var
  EmbedIdx: Int32;
  TotalXPGained: Int32;
  XPPerHourActive, XPPerHourTotal: Int32;
begin
  if not SENDSESSIONSUMMARYMSG or not ENABLEWEBHOOKS then Exit;

  TotalXPGained := Self.CurrentXP - Self.StartXP;

  XPPerHourActive := Round(TotalXPGained / (ActiveTimer.ElapsedTime / 3600000));
  XPPerHourTotal := Round(TotalXPGained / (RunningTime.ElapsedTime / 3600000));

  try
    Discord.Webhook.Content := '**Session Complete!** :checkered_flag:';

    EmbedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[EmbedIdx].Title := 'BigAussies Gemstone Crab Slayer - Session Summary';
    Discord.Webhook.Embeds[EmbedIdx].Color := $0000FF;
    Discord.Webhook.Embeds[EmbedIdx].Description := 'Total Runtime: ' + SRL.MsToTime(GetTimeRunning, Time_Short) + LineEnding +
                                                    'Total XP Gained: ' + FormatRoundedNumber(TotalXPGained) + LineEnding +
                                                    'XP/Hour (Active): ' + FormatRoundedNumber(XPPerHourActive) + LineEnding +
                                                    'XP/Hour (Total): ' + FormatRoundedNumber(XPPerHourTotal) + LineEnding +
                                                    'Farm Runs Completed: ' + IntToStr(Self.FarmRun.RunsComplete);

    if Discord.SendScreenshot(False) then
      WriteLn('[Discord] Session summary sent!')
    else
      WriteLn('[Discord] Failed to send session summary: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending session summary: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.TakeScreenshot(Name: String);
var
  ScreenshotPath: String;
  FileCount: Integer;
begin
  try
    if (Name = '') then
      Name := 'Unknown';

    try
      CreateDirectory('Screenshots/');
    except
      WriteLn('[Screenshot] Failed to create Screenshots directory');
      Exit;
    end;

    try
      FileCount := Length(GetFiles('Screenshots/', 'png'));
    except
      WriteLn('[Screenshot] Failed to count existing screenshots, dfault to 0');
      FileCount := 0;
    end;

    ScreenshotPath := 'Screenshots/GemStoneCrab' + Name + '_' + IntToStr(FileCount) + '.png';

    try
      SaveScreenshot(ScreenshotPath);
      WriteLn('[Screenshot] Successfully saved: ' + ScreenshotPath);
    except
      WriteLn('[Screenshot] Failed to save screenshot - skipping');
    end;

  except
    WriteLn('[Screenshot] Error in TakeScreenshot - skipping');
  end;
end;

function GemStoneCrabSlayer.AttackClosestCrab(CrabLocation: String; StartXP: Integer): Boolean;
var
  CloseDistance: Double;
  DistanceToTarget: Double;
  UseWalk: Boolean;
  LabelPrefix: String;
  AttemptSucceeded: Boolean;

  function DoAttackOnce(Walk: Boolean): Boolean;
  begin
    Result := False;
    if CrabLocation = 'North' then
    begin
      if Walk then
        Result := GemStoneCrabNorth.WalkSelectOption(['Attack'])
      else
        Result := GemStoneCrabNorth.SelectOption(['Attack']);
    end
    else if CrabLocation = 'East' then
    begin
      if Walk then
        Result := GemStoneCrabEast.WalkSelectOption(['Attack'])
      else
        Result := GemStoneCrabEast.SelectOption(['Attack']);
    end
    else
    begin
      if Walk then
        Result := GemStoneCrabSouth.WalkSelectOption(['Attack'])
      else
        Result := GemStoneCrabSouth.SelectOption(['Attack']);
    end;
  end;
begin
  Result := False;

  CloseDistance := 50.0;
  DistanceToTarget := Self.DistanceToSpawn(CrabLocation);
  UseWalk := DistanceToTarget > CloseDistance;
  LabelPrefix := UpperCase(CrabLocation) + ': ';

  WriteLn('Attempting to attack ', CrabLocation, ' crab...');
  if UseWalk then
    WriteLn('Far from ', CrabLocation, ' crab (', FloatToStr(DistanceToTarget), ' tiles)')
  else
    WriteLn('Close to ', CrabLocation, ' crab (', FloatToStr(DistanceToTarget), ' tiles)');

  AttemptSucceeded := DoAttackOnce(UseWalk);
  if not AttemptSucceeded then
  begin
    WriteLn('Failed to attack ', CrabLocation, ' crab, retrying...');
    AttemptSucceeded := DoAttackOnce(UseWalk);
  end;

  if AttemptSucceeded then
  begin
    WriteLn('Successfully attacked ', CrabLocation, ' crab, waiting for XP...');
    if Self.WaitForXPGain(StartXP, LabelPrefix) then
    begin
      Self.AttackOptionChecked := True;
      Result := True;
      Exit;
    end;
  end
  else
  WriteLn('Failed to attack ', CrabLocation, ' crab on retry');
  if not Self.AttackOptionChecked then
  begin
    WriteLn('Checking NPC attack option after click failure...');
    if Options.GetNPCAttackOption() <> ERSAttackOption.ALWAYS_LEFT_CLICK then
    begin
      WriteLn('NPC attack option not set to ALWAYS_LEFT_CLICK, setting it now');
      Options.SetNPCAttackOption(ERSAttackOption.ALWAYS_LEFT_CLICK);
      Self.AttackOptionChecked := True;
    end
    else
    begin
      WriteLn('NPC attack option already set to ALWAYS_LEFT_CLICK');
      Self.AttackOptionChecked := True;
    end;
  end;
end;

function GemStoneCrabSlayer.GetClosestCrabInfo(): record
  Location: String;
  SpawnPoint: TPoint;
  Distance: Double;
end;
var
  CurrentPos: TPoint;
  NorthDistance, EastDistance, SouthDistance: Double;
begin
  CurrentPos := Map.Position;

  NorthDistance := CurrentPos.DistanceTo(Point(996, 37738));
  EastDistance := CurrentPos.DistanceTo(Point(1316, 37982));
  SouthDistance := CurrentPos.DistanceTo(Point(860, 38258));

  WriteLn('Distances - North: ', FloatToStr(NorthDistance), ', East: ', FloatToStr(EastDistance), ', South: ', FloatToStr(SouthDistance));

  if (NorthDistance <= EastDistance) and (NorthDistance <= SouthDistance) then
  begin
    Result.Location := 'North';
    Result.SpawnPoint := Point(996, 37738);
    Result.Distance := NorthDistance;
    WriteLn('North spawn is closest (', FloatToStr(NorthDistance), ' tiles)');
  end
  else if (EastDistance <= NorthDistance) and (EastDistance <= SouthDistance) then
  begin
    Result.Location := 'East';
    Result.SpawnPoint := Point(1316, 37982);
    Result.Distance := EastDistance;
    WriteLn('East spawn is closest (', FloatToStr(EastDistance), ' tiles)');
  end
  else
  begin
    Result.Location := 'South';
    Result.SpawnPoint := Point(860, 38258);
    Result.Distance := SouthDistance;
    WriteLn('South spawn is closest (', FloatToStr(SouthDistance), ' tiles)');
  end;
end;

function GemStoneCrabSlayer.FindAndAttackVisibleCrab(StartXP: Integer): Boolean;
var
  i: Int32;
  name: String;
begin
  Result := False;

  for i := 0 to 2 do
  begin
    if i = 0 then name := 'North'
    else if i = 1 then name := 'East'
    else name := 'South';

    if ((name = 'North') and GemStoneCrabNorth.IsVisible()) or
       ((name = 'East') and GemStoneCrabEast.IsVisible()) or
       ((name = 'South') and GemStoneCrabSouth.IsVisible()) then
    begin
      WriteLn(name, ' crab is visible - attempting to attack...');
      if Self.AttackClosestCrab(name, StartXP) then
      begin
        Result := True;
        Exit;
      end;
    end;
  end;
end;

procedure GemStoneCrabSlayer.SetCrabMinimapFilter(CrabLocation: String; Enable: Boolean);
begin
  if CrabLocation = 'North' then
  begin
    GemStoneCrabNorth.Filter.Minimap := Enable;
    {if Enable then
      WriteLn('Enabled minimap filter for North crab')
    else
      WriteLn('Disabled minimap filter for North crab');}
  end
  else if CrabLocation = 'East' then
  begin
    GemStoneCrabEast.Filter.Minimap := Enable;
    {if Enable then
      WriteLn('Enabled minimap filter for East crab')
    else
      WriteLn('Disabled minimap filter for East crab');}
  end
  else if CrabLocation = 'South' then
  begin
    GemStoneCrabSouth.Filter.Minimap := Enable;
    {if Enable then
      WriteLn('Enabled minimap filter for South crab')
    else
      WriteLn('Disabled minimap filter for South crab');}
  end;
end;

function GemStoneCrabSlayer.AttackWithMinimapDisabled(CrabLocation: String; StartXP: Integer): Boolean;
begin
  Result := False;

  Self.SetCrabMinimapFilter(CrabLocation, False);

  if Self.AttackClosestCrab(CrabLocation, StartXP) then
  begin
    Result := True;
  end;

  Self.SetCrabMinimapFilter(CrabLocation, True);
end;

function GemStoneCrabSlayer.IsBossHealthBarVisible(): Integer;
var
  GreenTPA, RedTPA: TPointArray;
  CompactHealthBarBox, FullHealthBarBox: TBox;
  GreenCount, RedCount: Integer;
  PreviousBossHealth: Integer;
  CompactGreenCount, CompactRedCount: Integer;
  FullGreenCount, FullRedCount: Integer;
begin
  Result := 0;

  CompactHealthBarBox := [204, 50, 220, 68];
  FullHealthBarBox := [164, 50, 182, 68];

  // Check full health bar first
  SRL.FindColors(GreenTPA, CTS2(51200, 1, 0.01, 0.01), FullHealthBarBox);
  SRL.FindColors(RedTPA, CTS2(200, 1, 0.01, 0.01), FullHealthBarBox);
  
  FullGreenCount := GreenTPA.Len;
  FullRedCount := RedTPA.Len;

  if (FullGreenCount > 0) or (FullRedCount > 0) then
  begin
    GreenCount := FullGreenCount;
    RedCount := FullRedCount;
  end
  else
  begin
    SRL.FindColors(GreenTPA, CTS2(51200, 1, 0.01, 0.01), CompactHealthBarBox);
    SRL.FindColors(RedTPA, CTS2(200, 1, 0.01, 0.01), CompactHealthBarBox);
    
    CompactGreenCount := GreenTPA.Len;
    CompactRedCount := RedTPA.Len;
    
    GreenCount := CompactGreenCount;
    RedCount := CompactRedCount;
  end;

  if (GreenCount = 0) and (RedCount = 0) then
  begin
    if Self.CurrentBossHealth > 0 then
    begin
      Result := 2;
      WriteLn('[BOSS HEALTH BAR] Boss health bar not visible, going to cave');
      Self.CurrentBossHealth := 0;
    end
    else
    begin
      Result := 0;
      //WriteLn('[BOSS HEALTH BAR] Disabled/Not visible - no colors detected');
    end;
  end

  else if GreenCount > 0 then
  begin
    Result := 1;
    PreviousBossHealth := Self.CurrentBossHealth;
    Self.CurrentBossHealth := Round((GreenCount / (GreenCount + RedCount)) * 100);
  end
  else if RedCount > 0 then
  begin
    Result := 2;
    WriteLn('[BOSS HEALTH BAR] No combat - only red damage bar visible, no green health Boss dead');
  end
  else
  begin
    Result := 0;
    WriteLn('[BOSS HEALTH BAR] Unexpected state - should not reach here');
  end;
end;

function GemStoneCrabSlayer.FindGemStoneCrab(): Boolean;
var
  StartXP: Integer;
  CrabInfo: record Location: String; SpawnPoint: TPoint; Distance: Double; end;
  CaveEntered: Boolean;
  RandomOffset: TPoint;
  TargetTile: TPoint;
  WaitStartTime: UInt64;
  WaitTimeout: UInt64;
  NPCVisible: Boolean;
  TimeSinceLastCaveExit: UInt64;
  HPBarsCount: Integer;
  MinimapFilterDisabled: Boolean;
  BossHealthBarStatus: Integer;
  AllowedToAttack: Boolean;
begin
  Result := False;

  StartXP := Self.SafeReadXPBar();

  // Get closest crab
  CrabInfo := Self.GetClosestCrabInfo();

  if CrabInfo.Distance > 50 then
  begin
    WriteLn('Too far from closest crab spawn (', FloatToStr(CrabInfo.Distance), ' tiles) - walking to ', CrabInfo.Location, ' spawn first...');

    Self.WalkToCrabSpawn();

    WriteLn('Checking for crabs after walking closer to spawn...');
    if Self.FindAndAttackVisibleCrab(StartXP) then
    begin
      Result := True;
      Exit;
    end;
  end;

  BossHealthBarStatus := Self.IsBossHealthBarVisible();
  AllowedToAttack := (BossHealthBarStatus = 1);

  HPBarsCount := Length(MainScreen.FindHPBars());
  MinimapFilterDisabled := False;

  case BossHealthBarStatus of
    0:
      begin
        WriteLn('[BOSS HEALTH BAR] Disabled/Not visible - using normal HP bar detection');
        AllowedToAttack := False;
      end;

    1:
      begin
        WriteLn('[BOSS HEALTH BAR] Boss spawned - disabling minimap filters and attacking immediately');
        Self.SetCrabMinimapFilter('North', False);
        Self.SetCrabMinimapFilter('East', False);
        Self.SetCrabMinimapFilter('South', False);
        MinimapFilterDisabled := True;

        if Self.FindAndAttackVisibleCrab(StartXP) then
        begin
          Result := True;
          Exit;
        end;
      end;

    2:
      begin
        WriteLn('[BOSS HEALTH BAR] No combat detected - boss died, entering cave');
        Self.CurrentBossHealth := 0;
        AllowedToAttack := False;
      end;
  end;

  if Self.LastCaveExitTime > 0 then
  begin
    TimeSinceLastCaveExit := GetTickCount() - Self.LastCaveExitTime;
    if TimeSinceLastCaveExit > 20000 then
    begin
      WriteLn('Been waiting too long since last cave exit (', TimeSinceLastCaveExit, 'ms) - resetting timer');
      Self.LastCaveExitTime := 0;
    end;
  end;

  if AllowedToAttack then
  begin
    WriteLn('Checking if any crab is visible...');
    if Self.FindAndAttackVisibleCrab(StartXP) then
    begin
      Result := True;
      Exit;
    end;
  end;

  if (Self.LastCaveExitTime > 0) and (TimeSinceLastCaveExit > 15000) then
  begin
    WriteLn('Been waiting to long, attempting to enter cave...');
  end
  else
  begin
    if not AllowedToAttack then
      WriteLn('Boss not visible - attempting to enter cave...')
    else
      WriteLn('No crab is visible - attempting to enter cave...');
  end;

  // Try to enter cave
  CaveEntered := Self.TryEnterCave();

  if CaveEntered then
  begin
    // Wait for cave exit (minimap black to not black)
    if WaitUntil(Minimap.PercentBlack() < 20, 65, 10000) then
    begin
      WriteLn('Successfully exited cave, looking for crab at new location...');
      Self.LastCaveExitTime := GetTickCount();

      CrabInfo := Self.GetClosestCrabInfo();

      WriteLn('Checking for crab after cave exit...');
      Self.SetCrabMinimapFilter('North', True);
      Self.SetCrabMinimapFilter('East', True);
      Self.SetCrabMinimapFilter('South', True);
      MinimapFilterDisabled := False;
    
      if Self.FindAndAttackVisibleCrab(StartXP) then
      begin
        Result := True;
        Exit;
      end;

      if CrabInfo.Location = 'North' then
      begin
        // North crab front position: [1004, 37750] - stand in front of the crab
        RandomOffset := Point(RandomRange(-4, 5), RandomRange(-4, 5));
        TargetTile := Point(1004 + RandomOffset.X, 37750 + RandomOffset.Y);
        //WriteLn('Moving to random tile in front of North crab spawn: ', TargetTile.X, ', ', TargetTile.Y);
      end
      else if CrabInfo.Location = 'East' then
      begin
        // East crab front position: [1316, 37970] - stand in front of the crab
        RandomOffset := Point(RandomRange(-4, 5), RandomRange(-4, 5));
        TargetTile := Point(1316 + RandomOffset.X, 37970 + RandomOffset.Y);
        //WriteLn('Moving to random tile in front of East crab spawn: ', TargetTile.X, ', ', TargetTile.Y);
      end
      else if CrabInfo.Location = 'South' then
      begin
        // South crab front position: [876, 38266] - stand in front of the crab
        RandomOffset := Point(RandomRange(-4, 5), RandomRange(-4, 5));
        TargetTile := Point(876 + RandomOffset.X, 38266 + RandomOffset.Y);
        //WriteLn('Moving to random tile in front of South crab spawn: ', TargetTile.X, ', ', TargetTile.Y);
      end;

      WriteLn('Moving to random tile near ', CrabInfo.Location, ' spawn: ', TargetTile.X, ', ', TargetTile.Y);
      if Map.Walker.WalkBlind(TargetTile) then
      begin
        WriteLn('Successfully moved to target tile');

        WaitStartTime := GetTickCount();
        WaitTimeout := 16000;

        WriteLn('Waiting for boss, AFKing');

        repeat
          NPCVisible := GemStoneCrabNorth.IsVisible() or GemStoneCrabEast.IsVisible() or GemStoneCrabSouth.IsVisible();
          if NPCVisible then
          begin
            //WriteLn('Mr Crabs appeared while waiting attacking');
            //TakeScreenshot('AttackVisibleCrab');
            if Self.FindAndAttackVisibleCrab(StartXP) then
            begin
              Result := True;
              Exit;
            end;
            WriteLn('Attack failed after NPC appeared');
            Break;
          end;

        until (GetTickCount() - WaitStartTime) >= WaitTimeout;

        if Self.AttackWithMinimapDisabled(CrabInfo.Location, StartXP) then
        begin
          Result := True;
          Exit;
        end
        else
        begin
          WriteLn('Attack failed after 6 second wait......');
          Exit(False);
        end;
      end
      else
      begin
        WriteLn('Failed to move to target tile near spawn...');
        Exit(False);
      end;
    end
    else
    begin
      WriteLn('Failed to exit cave within timeout?');
      Exit(False);
    end;
  end
  else
  begin
    // Cave entry failed - check if it was blocked
    if Self.ConsecutiveBlockedCaveAttempts > 0 then
    begin
      WriteLn('Cave was blocked - crab must be here.');
      
      // Disable minimap filter and try to attack
      Self.SetCrabMinimapFilter('North', False);
      Self.SetCrabMinimapFilter('East', False);
      Self.SetCrabMinimapFilter('South', False);
      MinimapFilterDisabled := True;
      
      if Self.AttackWithMinimapDisabled(CrabInfo.Location, StartXP) then
      begin
        Result := True;
        Exit;
      end
      else
      begin
        WriteLn('Failed to attack crab after cave was blocked - trying cave again...');
        
        // Try cave again
        CaveEntered := Self.TryEnterCave();
        
        if CaveEntered then
        begin
          // Successfully entered cave on retry
          WriteLn('Successfully entered cave on retry');
          // The cave exit logic will be handled by the next call to this function
          Exit(True);
        end
        else
        begin
          // Cave blocked again - terminate as per your specification
          WriteLn('Cave blocked again after failed attack - terminating script');
          TerminateScript('Cave blocked twice after failed crab attack');
        end;
      end;
    end
    else
    begin
      // Cave entry failed for other reasons (not blocked)
      WriteLn('Failed to enter cave (not blocked) - attempting walk-click on closest crab...');

      // Try to attack with minimap filter disabled
      if Self.AttackWithMinimapDisabled(CrabInfo.Location, StartXP) then
      begin
        Result := True;
        Exit;
      end
      else
      begin
        WriteLn('Failed to walk-click closest crab.');
        Exit(False);
      end;
    end;
  end;

  // Re-enable minimap filter if it was disabled due to high HP bar count
  if MinimapFilterDisabled then
  begin
    WriteLn('Re-enabling minimap filter after HP bar count check');
    Self.SetCrabMinimapFilter('North', True);
    Self.SetCrabMinimapFilter('East', True);
    Self.SetCrabMinimapFilter('South', True);
  end;
end;

function GemStoneCrabSlayer.WaitForXPGain(StartXP: Integer; ModePrefix: String): Boolean;
var
  TimeoutStart: UInt64;
  BossHealthBarStatus: Integer;
begin
  Result := False;
  TimeoutStart := GetTickCount();

  repeat
    BossHealthBarStatus := Self.IsBossHealthBarVisible();
    if BossHealthBarStatus = 2 then
    begin
      WriteLn(ModePrefix + '[COMBAT] Crab Dead');
      Self.InCombat := False;
      Self.IsAttacking := False;
      Exit(False);
    end;

    if Self.SafeReadXPBar() > StartXP then
    begin
      Self.IsAttacking := True;
      Self.InCombat := True;
      Self.PrevXP := Self.SafeReadXPBar();
      Self.LastHealthCheck := GetTickCount();
      WL.Activity.Restart();

      Self.ConsecutiveFailedAttacks := 0;
      WriteLn(ModePrefix + 'Successfully attacked boss and gained XP!');

      if USEBOOSTS then
      begin
        if Self.ShouldRepot() then
        begin
          if Self.TryConsumeAnyBoost() then
          begin
            Self.LastRepotTime := GetTickCount();
            Self.NextRepotTime := GetTickCount() + Self.GetRandomRepotTime();
          end
        end
      end;

      if Self.ShouldEatFood() and Self.HadFoodAtStart then
      begin
        WriteLn('[FOOD] HP below threshold after XP gain - eating food');
        Self.TryConsumeAnyFood();
      end;

      if Self.ShouldDrinkPrayer() and Self.HadPrayerAtStart then
      begin
        WriteLn('[PRAYER] Prayer below threshold after XP gain - drinking prayer potion');
        Self.TryConsumeAnyPrayer();
      end;

      Result := True;
      Exit;
    end;

  until (GetTickCount() - TimeoutStart) > 5000;

  WriteLn(ModePrefix + 'No XP gained within 5 seconds after attack');

  Inc(Self.ConsecutiveFailedAttacks);
  Self.LastFailedAttackTime := GetTickCount();
  WriteLn(ModePrefix + 'Attack failed to gain XP. Consecutive failed attacks: ', Self.ConsecutiveFailedAttacks, '/3');

  if Self.ConsecutiveFailedAttacks >= 3 then
  begin
    WriteLn('3 consecutive boss attacks failed to gain XP!');
    WriteLn('This likely means we are out of ammo/runes. Logging out and terminating script.');

    Self.TakeScreenshot('_NoAmmoFailsafe');

    if ENABLEWEBHOOKS then
    begin
      try
        Discord.Webhook.Content := 'Failed to gain XP! Script will logout and terminate. Please check your ammo/runes!';
        Discord.SendScreenshot(False);
      except
        WriteLn('[Discord] Failed to send no ammo notification');
      end;
    end;

    TerminateScript('No XP gained from 3 consecutive attacks');
    Logout.ClickLogout();
  end;

  Result := True;
end;

function GemStoneCrabSlayer.IsInCombat(): Boolean;
begin
  CurrentXP := Self.SafeReadXPBar();

  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();
    Result := True;
  end
  else
  begin
    if Self.InCombat and ((GetTickCount() - Self.LastHealthCheck) < 15000) then
      Result := True
    else
    begin
      Self.InCombat := False;
      Self.IsAttacking := False;
      Result := False;
    end;
  end;
end;

function GemStoneCrabSlayer.HandleCombat(): Boolean;
var
  TimeSinceLastXP: UInt64;
  BossHealthBarStatus: Integer;
begin
  if not Self.InCombat or not Self.IsAttacking then
    exit;

  Result := True;

  CurrentXP := Self.SafeReadXPBar();
  TimeSinceLastXP := GetTickCount() - Self.LastHealthCheck;

  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();

    if ABLOSEFOCUS then
    begin
      Antiban.LoseFocus();
    end;
  end
  else
  begin
    BossHealthBarStatus := Self.IsBossHealthBarVisible();
    if BossHealthBarStatus = 2 then
    begin
      WriteLn('[COMBAT] Crab Dead - Moving to cave');
      Self.InCombat := False;
      Self.IsAttacking := False;
      Result := False;
      Exit;
    end;

    if (Length(MainScreen.FindHPBars()) = 0) or (BossHealthBarStatus = 2) then
    begin
      Self.LastHealthCheck := GetTickCount();

      WriteLn('[COMBAT] Combat ended - no bars found');
      Self.InCombat := False;
      Self.IsAttacking := False;

      Self.DoAntiban(True, True);

      // Hop AFTER we break/sleep etc
      if Self.ShouldHopWorld() then
        Self.DoWorldHop();

      Result := False;
    end
    else if TimeSinceLastXP > Random(10000, 20000) then
    begin
      WriteLn('[COMBAT] No XP for a period of time, assuming combat ended');
      Self.InCombat := False;
      Self.IsAttacking := False;
      Result := False;
    end;

    // Check if we need to reduce HP for Dharoks
    if USEDHAROKS and Self.ShouldReduceHP() then
    begin
      WriteLn('Dharoks: Reducing HP during combat');
      Self.TryReduceHP();
    end;

    // Check if we should use Dragon Battleaxe special attack
    if Self.ShouldUseDragonBattleaxe() then
    begin
      WriteLn('Using Dragon Battleaxe special attack');
      Self.UseDragonBattleaxeSpecial();
    end;

    // Check if we should use weapon special attack
    if Self.ShouldUseSpecialAttack() then
    begin
      WriteLn('[SPECIAL] Using weapon special attack');
      Self.UseSpecialAttack();
    end;

    // Check if we need to repot while in combat
    if Self.InCombat then
      Self.TryRepot();

    // Check if we need to eat food while in combat
    if Self.InCombat and Self.ShouldEatFood() and Self.HadFoodAtStart then
      Self.TryConsumeAnyFood();

    // Check if we need to drink prayer potion while in combat
    if Self.InCombat and Self.ShouldDrinkPrayer() and Self.HadPrayerAtStart then
      Self.TryConsumeAnyPrayer();

    // Check if we should enable quick prayers during combat
    if Self.InCombat and Self.UseQuickPrayers and not Minimap.IsPrayerEnabled() then
    begin
      if (Minimap.GetPrayerLevel <= 0) and not Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]) then
      begin
        useQuickPrayers := False;
        WriteLn('[PRAYER] Prayer level below 0 and no prayer potions in inventory - disabling quick prayers');
        Exit;
      end;

      WriteLn('[PRAYER] Enabling quick prayers during combat');
      Minimap.EnablePrayer();
    end;

    // Check if we should flick prayer
    if Self.ShouldFlickPrayer() then
    begin
      WriteLn('Prayer flicking: Timer finished, flicking prayer');
      Self.FlickPrayer();
    end;

    // Try to enchant bolts while in combat
    if ENABLEBOLTENCHANTING then
    begin
      Self.TryEnchantBolts();
    end;
  end;
end;

procedure GemStoneCrabSlayer.DoAction();
var
  TimeSinceLastXP: UInt64;
  BossFound: Boolean;
  attempts: Int32;
begin
  if (Self.ConsecutiveFailedAttacks > 0) and
     (Self.LastFailedAttackTime > 0) and
     ((GetTickCount() - Self.LastFailedAttackTime) > 600000) then
  begin
    Self.ConsecutiveFailedAttacks := 0;
    Self.LastFailedAttackTime := 0;
  end;

  if (not ChatButtons.IsActive(ERSChatButton.ALL_CHAT)) and (not ChatButtons.IsActive(ERSChatButton.GAME_CHAT)) then
    ChatButtons.Open(ERSChatButton.ALL_CHAT);

  CurrentXP := Self.SafeReadXPBar();
  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();
  end;

  TimeSinceLastXP := GetTickCount() - Self.LastHealthCheck;
  if TimeSinceLastXP > 8000 then
  begin
    if Self.InCombat or Self.IsAttacking then
    begin
      WriteLn('No XP for 8 seconds - Out of combat?');
      Self.InCombat := False;
      Self.IsAttacking := False;
    end;
  end;

  if Self.IsAttacking and (TimeSinceLastXP > 8000) then
  begin
    Self.IsAttacking := False;
  end;

  if ((USEBOOSTS and Self.ShouldRepot() and Self.OutOfPotions) or
      (Self.ShouldEatFood() and Self.OutOfFood and Self.HadFoodAtStart) or
      (Self.ShouldDrinkPrayer() and Self.OutOfPrayer and Self.HadPrayerAtStart)) and not Self.BankingDisabled then
  begin
    if Self.OutOfPotions then
      WriteLn('[SUPPLIES] Consume timer up and out of potions - heading to bank')
    else if Self.OutOfFood and Self.HadFoodAtStart then
      WriteLn('[SUPPLIES] HP low and out of food - heading to bank')
    else if Self.OutOfPrayer and Self.HadPrayerAtStart then
      WriteLn('[SUPPLIES] Prayer low and out of prayer potions - heading to bank');

    Self.HandleBanking();

    // After banking attempt, always walk back to MR CRAB
    WL.Activity.Restart();

    if Self.HasSupplies then
    begin
      WriteLn('[BANK] Successfully restocked supplies - continuing script');
      Self.OutOfPotions := False;
      Self.OutOfFood := False;
      Self.OutOfPrayer := False;
      if Bank.IsOpen() then
        Bank.Close();
    end
    else
    begin
      WriteLn('[BANK] Failed to restock all supplies, continuing.');
      if Bank.IsOpen() then
        Bank.Close();
    end;

    WriteLn('[NAVIGATION] Walking to north after banking...');

    // Try to walk to north with retry attempts
    for attempts := 1 to 5 do
    begin
      WriteLn('[NAVIGATION] Attempt ', attempts, '/5: Walking to north crab spawn...');

      if Map.Walker.WebWalk(Point(996, 37738), 20, 0.2) then
      begin
        WriteLn('[NAVIGATION] Successfully walked to north crab spawn on attempt ', attempts);
        WL.Activity.Restart();
        Self.InCombat := False;
        Self.IsAttacking := False;
        Exit;
      end
      else
      begin
        WriteLn('[NAVIGATION] Failed to walk to north crab spawn on attempt ', attempts, '/5');

        if attempts < 5 then
        begin
          WriteLn('[NAVIGATION] Retrying to walk to north crab spawn...');
        end;
      end;
    end;

    WriteLn('[NAVIGATION] Failed to walk to north crab spawn after 5 attempts - continuing from current location');
  end;

  if Self.IsInCombat() then
  begin
    if not Self.HandleCombat() then
    begin
      WriteLn('Combat ended, resetting combat state');
      Self.InCombat := False;
      Self.IsAttacking := False;
    end;
  end
  else
  begin
    if Self.ShouldDrinkPrayer() and Self.HadPrayerAtStart then
    begin
      WriteLn('[PRAYER] Prayer below threshold outside combat - drinking prayer potion');
      Self.TryConsumeAnyPrayer();
    end;

    if Self.ShouldEatFood() and Self.HadFoodAtStart then
    begin
      WriteLn('[FOOD] HP below threshold outside combat - eating food');
      Self.TryConsumeAnyFood();
    end;

    if USEDHAROKS and not Self.InitializeDharoks() then
    begin
      WriteLn('Failed to initialize Dharoks - disabling Dharoks mode');
      USEDHAROKS := False;
    end;

    BossFound := Self.FindGemStoneCrab();

    if BossFound then
    begin
      WriteLn('Found and attacked Gemstone Crab!');
      Wait(Random(3000, 5000));
    end
  end;

  if not Self.InCombat then
  begin
    Self.DoAntiban(True, True);
    
    // Hop AFTER we break/sleep etc
    if Self.ShouldHopWorld() then
      Self.DoWorldHop();
  end;
end;

function GemStoneCrabSlayer.GetCurrentActivity(): String;
begin
  if Self.FarmRunInProgress then
    Result := 'Farm Run'
  else if Self.OutOfFood or Self.OutOfPotions or Self.OutOfPrayer then
    Result := 'Banking'
  else if Self.InCombat then
    Result := 'In Combat'
  else if Self.IsAttacking then
    Result := 'Attacking'
  else if USEBOOSTS and Self.ShouldRepot() then
    Result := 'Preparing to Repot'
  else if Self.ShouldEatFood() and Self.HadFoodAtStart then
    Result := 'Need Food'
  else if Self.ShouldDrinkPrayer() and Self.HadPrayerAtStart then
    Result := 'Need Prayer'
  else if Self.ShouldUseSpecialAttack() then
    Result := 'Using Special'
  else if Self.ConsecutiveFailedAttacks > 5 then
    Result := 'Finding Target'
  else
    Result := 'Searching for crab';
end;

function GemStoneCrabSlayer.GetFarmRunTimeRemaining(): String;
var
  timeRemaining: UInt64;
begin
  if not ENABLEFARMRUNS then
  begin
    Result := 'Disabled';
    Exit;
  end;

  if Self.FarmRunInProgress then
  begin
    Result := 'In Progress';
    Exit;
  end;

  if Self.FarmRun.ReadyTimer.IsFinished then
  begin
    Result := 'READY!';
    Exit;
  end;

  timeRemaining := Self.FarmRun.ReadyTimer.TimeRemaining();
  Result := SRL.MsToTime(timeRemaining, Time_Bare);
end;

procedure GemStoneCrabSlayer.DrawUIOverlay(drawBox: TBox; title, status, runtime, xpRate, revision: String; useHeaderColor: Boolean = False);
var
  yPos, lineSpacing, headerSpacing: Int32;
  headerColor: TColor;
begin
  {$IFNDEF SRL_DISABLE_REMOTEINPUT}
  if not Self.UIEnabled then
    Exit;

  lineSpacing := Self.UIFontSize + 2;
  headerSpacing := Self.UIFontSize + 4;

  if useHeaderColor then
    headerColor := $00D4FF
  else
    headerColor := Self.UITextColor;

  RSClient.Image().DrawBoxFilled(drawBox, False, Self.UIBackgroundColor);
  RSClient.Image().DrawBoxFilled(drawBox.Expand(1), False, Self.UITextColor);
  RSClient.Image().DrawBoxFilled(drawBox, False, Self.UIBackgroundColor);

  RSClient.Image().SetFontName('Arial');
  RSClient.Image().SetFontSize(Self.UIFontSize);

  yPos := drawBox.Y1 + 6;

  RSClient.Image().SetFontSize(Self.UIFontSize + 1);
  RSClient.Image().DrawText(title, Point(drawBox.X1 + 3, yPos), headerColor);
  yPos += headerSpacing;

  RSClient.Image().SetFontSize(Self.UIFontSize - 1);
  RSClient.Image().DrawText('Status: ' + status, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  yPos += lineSpacing;
  RSClient.Image().DrawText('Runtime: ' + runtime, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  yPos += lineSpacing;
  RSClient.Image().DrawText('XP/HR: ' + xpRate, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  yPos += lineSpacing;
  
  if ENABLEFARMRUNS then
  begin
    RSClient.Image().DrawText('Farm Runs Completed: ' + IntToStr(Self.FarmRun.RunsComplete), Point(drawBox.X1 + 4, yPos), Self.UITextColor);
    yPos += lineSpacing;
    RSClient.Image().DrawText('Next Farm Run: ' + Self.GetFarmRunTimeRemaining(), Point(drawBox.X1 + 4, yPos), Self.UITextColor);
    yPos += lineSpacing;
  end;
  
  //RSClient.Image().DrawText('SRL: v' + srlVer, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  //yPos += lineSpacing;
  //RSClient.Image().DrawText('Wasp: v' + waspVer, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  //yPos += lineSpacing;
  RSClient.Image().DrawText('Script Revision: ' + revision, Point(drawBox.X1 + 3, yPos), Self.UITextColor);
  yPos += lineSpacing;
  {$ENDIF}
end;

procedure GemStoneCrabSlayer.DrawStatusOverlay(isPreviewMode: Boolean = False; previewBox: TBox = [0, 0, 0, 0]);
var
  statusBox: TBox;
  currentActivity, title: String;
  srlVersion, wasplibVersion: String;
  xpPerHour: Int32;
  runtime: String;
  fontSize: Int32;
  bgColor, textColor: TColor;
  lineSpacing, headerSpacing: Int32;
  requiredHeight, requiredWidth: Int32;
  adjustedBox: TBox;
  tempScript: GemStoneCrabSlayer;
begin
  if not Self.UIEnabled then
    Exit;

  if isPreviewMode then
  begin
    if previewBox.X1 = 0 then Exit;

    fontSize := StrToIntDef(Config.UIFontSizeInput.GetText(), 11);

    case Config.UIBackgroundColorCombo.GetItemIndex() of
      0: bgColor := $2D2D30;
      1: bgColor := $000000;
      2: bgColor := $FFFFFF;
      3: bgColor := $0000FF;
      4: bgColor := $00FF00;
      5: bgColor := $FF0000;
      6: bgColor := StrToIntDef('$' + Config.UIBackgroundColorHexInput.GetText(), $2D2D30);
      else bgColor := $2D2D30;
    end;

    case Config.UITextColorCombo.GetItemIndex() of
      0: textColor := $FFFFFF;
      1: textColor := $000000;
      2: textColor := $C0C0C0;
      3: textColor := $0000FF;
      4: textColor := $00FF00;
      5: textColor := $FF0000;
      6: textColor := $00FFFF;
      7: textColor := StrToIntDef('$' + Config.UITextColorHexInput.GetText(), $FFFFFF);
      else textColor := $FFFFFF;
    end;

    if fontSize < 6 then fontSize := 6;
    if fontSize > 20 then fontSize := 20;

    lineSpacing := fontSize + 2;
    headerSpacing := fontSize + 4;

    if Assigned(Config.EnableFarmRunsCheckBox) and Config.EnableFarmRunsCheckBox.IsChecked() then
      requiredHeight := 12 + headerSpacing + (lineSpacing * 5) + fontSize - 2
    else
      requiredHeight := 12 + headerSpacing + (lineSpacing * 4) + fontSize - 2;

    requiredWidth := Round(fontSize * 12) + 20;
    adjustedBox := Box(previewBox.X1, previewBox.Y1, previewBox.X1 + requiredWidth, previewBox.Y1 + requiredHeight);

    tempScript.UIEnabled := True;
    tempScript.UIFontSize := fontSize;
    tempScript.UIBackgroundColor := bgColor;
    tempScript.UITextColor := textColor;

    if Assigned(Config.EnableFarmRunsCheckBox) then
      ENABLEFARMRUNS := Config.EnableFarmRunsCheckBox.IsChecked()
    else
      ENABLEFARMRUNS := False;

    tempScript.DrawUIOverlay(adjustedBox, 'GemStone Crab Slayer', 'Attacking Boss', '1h 23m',
                             FormatRoundedNumber(45000), {$MACRO SCRIPT_REVISION}, True);
  end
  else
  begin
    fontSize := Self.UIFontSize;
    if fontSize < 6 then fontSize := 6;
    if fontSize > 20 then fontSize := 20;

    lineSpacing := fontSize + 2;
    headerSpacing := fontSize + 4;

    if ENABLEFARMRUNS then
      requiredHeight := 12 + headerSpacing + (lineSpacing * 5) + fontSize - 2
    else
      requiredHeight := 12 + headerSpacing + (lineSpacing * 3) + fontSize - 2;

    requiredWidth := Round(fontSize * 12) + 20;

    statusBox := Box(Self.UIPosition.X, Self.UIPosition.Y,
                     Self.UIPosition.X + requiredWidth, Self.UIPosition.Y + requiredHeight);

    currentActivity := Self.GetCurrentActivity();
    srlVersion := Self.SRLTVersion;
    wasplibVersion := Self.WaspLibVersion;
    xpPerHour := Round(Self.GainedXP / (Self.RunningTime.ElapsedTime / 3600000));

    if not Self.HasAccess then
      title := 'GemStone Crab Slayer.'
    else
      title := 'GemStone Crab Slayer';

    runtime := SRL.MsToTime(GetTimeRunning(), Time_Short);

    Self.DrawUIOverlay(statusBox, title, currentActivity, runtime,
                       FormatRoundedNumber(xpPerHour),
                       {$MACRO SCRIPT_REVISION}, True);
  end;
end;

procedure GemStoneCrabSlayer.DrawStatusDisplay();
begin
  Self.DrawStatusOverlay();
end;

procedure GemStoneCrabSlayer.Report();
var
  Runtime: Integer;
  XPPerHour, XPPerHourExcludingBreaks: Integer;
  CurrentTime: UInt64;
  NextBreakTime: Double;
  i: Integer;
begin
  CurrentTime := GetTickCount();

  if (CurrentTime - Self.LastReportTime) < 3000 then
    Exit;

  Self.LastReportTime := CurrentTime;

  // Check for updates every 24 hours
  Self.CheckForUpdates(False);

  if (not DEBUGMODE) and (GetTimeRunning() > 600000) and ((GetTimeRunning() - Self.LastClearDebugTime) >= 600000) then
  begin
    ClearDebug();
    Self.LastClearDebugTime := GetTimeRunning();
  end;

  CurrentXP := Self.SafeReadXPBar();
  Self.GainedXP := CurrentXP - Self.StartXP;
  Runtime := GetTimeRunning();

  XPBar.EarnedXP();

  XPPerHour := Round((Self.GainedXP) / (RunningTime.ElapsedTime / 3600000));
  XPPerHourExcludingBreaks := Round((Self.GainedXP) / (ActiveTimer.ElapsedTime / 3600000));

  if not APIClient.IsSetup or APIClient.Timer.IsFinished() then
    APIClient.SubmitStats(APIClient.GetUUID());

  WriteLn('========================================');
  WriteLn('    BigAussies Gemstone Crab Slayer   ');
  WriteLn('========================================');
  WriteLn('   Runtime: ' + SRL.MsToTime(Runtime, Time_Short));
  WriteLn('   XP Gained: ' + FormatRoundedNumber(Self.GainedXP));
  WriteLn('   XP/Hour (Active): ' + FormatRoundedNumber(XPPerHourExcludingBreaks));
  WriteLn('   XP/Hour (Total): ' + FormatRoundedNumber(XPPerHour));
  if ENABLEWORLDHOPPING then
  begin
    WriteLn('   Hops Completed: ' + IntToStr(Self.WorldHopsCompleted));
    if Self.NextWorldHopTime > GetTickCount() then
      WriteLn('   Next Hop: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short))
    else
      WriteLn('   Next Hop: READY!');
  end

  if USEBOOSTS then
  begin
    if Self.NextRepotTime > GetTickCount() then
      WriteLn('   Next Boost: ' + SRL.MsToTime(Self.NextRepotTime - GetTickCount(), Time_Short))
    else
      WriteLn('   Next Boost: READY!');
  end

  if USEDHAROKS then
  begin
    WriteLn('   Dharoks Mode: (Target: ' + IntToStr(DHAROKSTARGETHPS) + ' HP)');
  end

  if ENABLEFARMRUNS then
  begin
    WriteLn('   Farm Runs Completed: ' + IntToStr(Self.FarmRun.RunsComplete));
    WriteLn('   Next Farm Run: ' + Self.GetFarmRunTimeRemaining());
  end

  NextBreakTime := 0;
  for i := 0 to High(Antiban.Breaks) do
  begin
    if Antiban.Breaks[i].NextAtTime > NextBreakTime then
      NextBreakTime := Antiban.Breaks[i].NextAtTime;
  end;

  if OVERRIDEBREAKS then
  begin
    if NextBreakTime > GetTimeRunning() then
      WriteLn('   Next Custom Break: ' + SRL.MsToTime(Round(NextBreakTime - GetTimeRunning()), Time_Short))
    else
      WriteLn('   Next Custom Break: READY!');
  end
  else
  begin
    if NextBreakTime > GetTimeRunning() then
      WriteLn('   Next Wasplib Break: ' + SRL.MsToTime(Round(NextBreakTime - GetTimeRunning()), Time_Short))
    else
      WriteLn('   Next Wasplib Break: READY!');
  end

  if Self.SystemUpdateWarningShown then
    WriteLn('   WARNING: System update detected! Will logout when combat ends.');

  WriteLn('========================================');
  if Self.HasAccess then
    WriteLn('    BigAussies Gemstone Crab Slayer   ')
  else
    WriteLn('    BigAussies Gemstone Crab Slayer.   ');
  WriteLn('    Revision: ' + {$MACRO SCRIPT_REVISION});

  if Self.UpdateAvailable then
    WriteLn('    *** Script Update Available: v' + ToStr(Self.LatestRevision) + ' ***');

  WriteLn('    Libraries: SRL-T v' + Self.SRLTVersion + ' | WaspLib v' + Self.WaspLibVersion);
  WriteLn('========================================');
end;

procedure GemStoneCrabSlayer.Init(MaxActions: UInt32; MaxTime: UInt64); override;
begin
  inherited;

  try
    if RSClient.RemoteInput.IsSetup() then
      RSClient.Image().Clear();
  except
  end;

  // Check library versions before start as varlmore maps are new and need latest libs
  Self.SRLTVersion := GetPackageVersion('SRL-T');
  Self.WaspLibVersion := GetPackageVersion('WaspLib');

  if (CompareVersions(Self.SRLTVersion, '7.21.1') < 0) then
  begin
    WriteLn('[FAILSAFE] ERROR: SRL-T version ', Self.SRLTVersion, ' is below required version 7.21.1');
    WriteLn('Please update SRL-T to version 7.21.1 or higher using WaspLauncher');
    TerminateScript('SRL-T version too old');
  end;

  if (CompareVersions(Self.WaspLibVersion, '20.3.8') < 0) then
  begin
    WriteLn('ERROR: WaspLib version ', Self.WaspLibVersion, ' is below required version 20.3.8');
    WriteLn('Please update WaspLib to version 20.3.8 or higher using WaspLauncher');
    TerminateScript('WaspLib version too old');
  end;

  WriteLn('[FAILSAFE] Library versions check passed - SRL-T: ', Self.SRLTVersion, ', WaspLib: ', Self.WaspLibVersion);

  // Failsafe for no worlds.
  if Length(Login.GetPlayer().Worlds) = 0 then
  begin
    writeln('Worlds: ', Length(Login.GetPlayer().Worlds));
    WriteLn('[FAILSAFE] ERROR: The worlds list is empty!');
    WriteLn('Please add at least one world to your worlds list.');
    TerminateScript('Worlds list is empty');
  end;

  if (RSClient.Mode <> ERSClientMode.FIXED) then
  begin
    WriteLn('[FAILSAFE] ERROR: You are not using the FIXED CLASSIC screen mode. FIXED CLASSIC mode is the only supported mode for this script.');
    TerminateScript('Screen mode not supported');
  end;

  writeln('[MAP]Setting up map');
  Map.SetupChunkEx([18, 49, 27, 47], [0, 1, 2]);
  Self.SetupObjects();
  Objects.Setup(Map.Objects(), @Map.Walker);
  Npcs.Setup(Map.NPCs(), @Map.Walker);
  Self.RSW.Setup();


  // Ensure ALL_CHAT or GAME_CHAT is selected for out of ammo detection
  if (not ChatButtons.IsActive(ERSChatButton.ALL_CHAT)) and (not ChatButtons.IsActive(ERSChatButton.GAME_CHAT)) then
    ChatButtons.Open(ERSChatButton.ALL_CHAT);

  if ENABLEWEBHOOKS then
   Discord.Setup(WEBHOOKURL);

  if SENDSESSIONSUMMARYMSG and ENABLEWEBHOOKS then
    AddOnTerminate(@Self.SendTerminationNotification);

  APIClient.TimeStamp := GetTickCount();

  Self.StartXP := Self.SafeReadXPBar();
  Self.PrevXP := Self.StartXP;
  Self.LastHourlyReportTime := 0;

  Self.InCombat := False;
  Self.IsAttacking := False;
  Self.LastHealthCheck := GetTickCount();

  Self.AttackOptionChecked := False;
  Self.CurrentBossHealth := 0;

  Self.ConsecutiveFailedAttacks := 0;
  Self.LastFailedAttackTime := 0;
  Self.LastSuccessfulClick := False;

  Self.LastCaveExitTime := 0;

  Self.ConsecutiveBlockedCaveAttempts := 0;

  Self.NextRepotTime := 0;
  Self.LastRepotTime := 0;

  Self.UseFallbackMode := False;

  Self.LastHPReduction := 0;
  Self.DharoksInitialized := False;

  Self.PrayFlickEnabled := False;

  if USEDHAROKS and ENABLEPRAYERFLICK then
  begin
    if not USEQUICKPRAYERSGUI then
    begin
      if Stats.GetLevel(ERSSkill.PRAYER) > 21 then
      begin
        Self.HadPrayerAtStart := Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]);
        Self.PrayFlickEnabled := True;
        Self.PrayFlickTimer.Setup(RandomRange(40000, 50000));
        WriteLn('[PRAYER] Prayer flicking enabled - will flick Rapid Heal to prevent HP regeneration');
        QuickPrayer.SelectPrayer(ERSPrayer.RAPID_HEAL);
      end
      else
      begin
        WriteLn('[PRAYER] Prayer flicking disabled - prayer level too low');
        Self.PrayFlickEnabled := False;
      end;
    end
    else if USEQUICKPRAYERSGUI then
    begin
      Self.HadPrayerAtStart := Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]);
      Self.PrayFlickEnabled := True;
      Self.PrayFlickTimer.Setup(RandomRange(40000, 50000));
      WriteLn('[PRAYER] Prayer flicking enabled - will flick Rapid Heal to prevent HP regeneration');
    end;
  end
  else
  begin
    WriteLn('[PRAYER] Prayer flicking disabled');
    Self.PrayFlickEnabled := False;
  end;

  Self.DragonBattleaxeSlot := -1;
  Self.LastDragonBattleaxeUse := 0;
  Self.NextDragonBattleaxeUse := 1;

  Self.LastBoltEnchantTime := 0;

  Self.UseDragonBattleaxe := USEDRAGONBATTLEAXEGUI and Inventory.ContainsItem('Dragon battleaxe');
  if Self.UseDragonBattleaxe then
  begin
    WriteLn('Dragon Battleaxe enabled - special attack boost enabled!');
  end
  else if USEDRAGONBATTLEAXEGUI then
  begin
    WriteLn('Dragon Battleaxe enabled but no item found in inventory - disabled');
  end;

  Self.SpecialAttackEnabled := USESPECIALATTACKSGUI and not USEDRAGONBATTLEAXEGUI;
  Self.SpecialAttackCost := 0;
  Self.SpecialAttackDiscovered := False;
  Self.LastSpecialAttackTime := 0;
  Self.NextSpecialAttackThreshold := 0;

  Self.UseQuickPrayers := USEQUICKPRAYERSGUI;

  if Self.UseQuickPrayers then
  begin
    WriteLn('[PRAYER] Quick prayers enabled - Checking for prayer potions.');
    Self.HadPrayerAtStart := Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]);
  end;

  if USEDRAGONBATTLEAXEGUI then
  begin
    Self.SpecialAttackEnabled := False;
    WriteLn('[SPECIAL] Special attacks disabled - using Dragon Battleaxe mode');
  end
  else if USESPECIALATTACKSGUI then
  begin
    WriteLn('[SPECIAL] Special attack weapon detected - special attacks enabled');
  end
  else
  begin
    Self.SpecialAttackEnabled := False;
  end;

  // Check spellbook for bolt enchanting
  if ENABLEBOLTENCHANTING then
  begin
    if not Magic.IsSpellBook(ERSSpellBook.Standard) then
    begin
      WriteLn('ERROR: Bolt enchanting enabled but not on standard spellbook!');
      WriteLn('Please switch to the standard spellbook to use bolt enchanting.');
      ENABLEBOLTENCHANTING := False;
    end
    else
    begin
      WriteLn('Bolt enchanting enabled - will enchant bolts during combat');
    end;
  end;

  Self.RunningTime.Start();
  Self.ActiveTimer.Start();

  Self.WorldHopsCompleted := 0;
  Self.LastWorldHopTime := 0;
  Self.SetupWorldHopping();
  Self.LastReportTime := 0;
  Self.LastImageClear := GetTickCount;
  Self.LastSystemUpdateCheck := 0;
  Self.LastClearDebugTime := 0;
  Self.SystemUpdateWarningShown := False;

  Self.HasSupplies := True;
  Self.BankingDisabled := False;
  Self.OutOfPotions := False;
  Self.OutOfFood := False;
  Self.OutOfPrayer := False;
  Self.HadFoodAtStart := Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.FOOD]);

  Self.FoodHPThreshold := 11;
  Self.PrayerThreshold := 50;

  Self.FailedBankItems := [];
  Self.ConsecutiveXPFailures := 0;
  Self.SetupLoadouts();

  if not Self.ConsumableHandler.IsSetup then
    Self.ConsumableHandler.DiscoverSetup();

  if ENABLEFARMRUNS then
  begin
    if not Magic.IsSpellBook(ERSSpellBook.STANDARD) then
    begin
      WriteLn('[FARM] You must be on the standard spellbook to use farm runs');
      ENABLEFARMRUNS := False;
      exit;
    end;

    // Check equipment and infinite runes for farm runs
    Self.ArdyCloakEquipped := (Self.ArdyCloakName <> '') and Equipment.ContainsItem(Self.ArdyCloakName);
    Self.FarmingCapeEquipped := Equipment.ContainsAny(['Farming cape', 'Farming cape(t)']);
    Self.ConstructionCapeEquipped := Equipment.ContainsAny(['Construct. cape', 'Construct. cape(t)']);

    Self.InfiniteWater := Equipment.ContainsItem('Tome of water');
    Self.InfiniteFire := Equipment.ContainsItem('Tome of fire');
    Self.InfiniteEarth := Equipment.ContainsItem('Tome of earth');

    WriteLn('[FARM] Equipment check - Ardy Cloak: ', Self.ArdyCloakEquipped, ', Farming Cape: ', Self.FarmingCapeEquipped, ', Construction Cape: ', Self.ConstructionCapeEquipped);
    WriteLn('[FARM] Infinite runes - Water: ', Self.InfiniteWater, ', Fire: ', Self.InfiniteFire, ', Earth: ', Self.InfiniteEarth);

    WriteLn('[FARM] Setting up farm runs... Please wait...');
    Self.FarmRunInProgress := False;
    Self.LastFarmRunTime := 0;

    Self.FarmRunSetup();

    // Configure farm run settings
    Self.FarmRun.CompostMethod := ECompostMethod(FARMCOMPOSTTYPE);
    Self.FarmRun.CleanHerbs := FARMCLEANHERBS;
    WriteLn('[FARM] Finalising farm run setup... Please wait...');
    Self.FarmRun.Init();
    WriteLn('[FARM] Farm runs setup completed.');
  end
  else
  begin
    WriteLn('[FARM] Farm runs disabled');
  end;

  try
    Self.HasAccess := WaspClient.HasAccess({$MACRO SCRIPT_ID}, {$MACRO SCRIPT_REVISION});
  except
    Self.HasAccess := False;
  end;

  //Options.SetZoomLevel(RandomRange(5, 15));

  Self.DrawStatusDisplay();

  if STARTWITHFARMRUN and ENABLEFARMRUNS then
  begin
    WriteLn('[FARM] Doing first farm run...');
    Self.FarmRunInProgress := True;
    Self.DrawStatusDisplay();
    Self.FarmRun.ReadyTimer.Init(0);
    Self.FarmRun.DoFarmRun();
    Self.FarmRunInProgress := False;
    WriteLn('[FARM] First farm run completed');
  end;
end;

procedure GemStoneCrabSlayer.FarmRunSetup();
var
  ArdyDiary, LumbyDiary: Int32;
  I: Int32;
begin
  WriteLn('[FARM] Setting up farm patches.');

  Self.BankItems := [];

  Self.CompostNeeded := 0;

  ArdyDiary := 0;
  LumbyDiary := 0;
  // Need retry logic for diary levels as sometimes fail to read
  for I := 1 to 3 do
  begin
    ArdyDiary := Achievements.GetDiaryLevel(ERSAchievementDiary.ARDOUGNE);
    if ArdyDiary > 0 then
      Break;

    WriteLn('[FARM] Ardougne diary level read as 0 (attempt ' + ToStr(I) + '/3), retrying...');
    Wait(1000 + Random(1000));
  end;

  for I := 1 to 3 do
  begin
    LumbyDiary := Achievements.GetDiaryLevel(ERSAchievementDiary.LUMBRIDGE_AND_DRAYNOR);
    if LumbyDiary > 0 then
      Break;

    WriteLn('[FARM] Lumbridge diary level read as 0 (attempt ' + ToStr(I) + '/3), retrying...');
    Wait(1000 + Random(1000));
  end;

  WriteLn('[FARM] Achievement Diary Levels - Ardougne: ', ArdyDiary, ', Lumbridge: ', LumbyDiary);

  Self.ArdyCloakName := '';
  Self.LumbyRingName := '';

  if ArdyDiary > 0 then
  begin
    Self.ArdyCloakName := 'Ardougne cloak ' + ToStr(ArdyDiary);
    WriteLn('[FARM] Ardougne cloak name set to: ', Self.ArdyCloakName);
  end
  else
  begin
    WriteLn('[FARM] Warning: Ardougne diary level is 0 - no cloak will be withdrawn');
  end;

  if LumbyDiary > 0 then
  begin
    Self.LumbyRingName := 'Explorer''s ring ' + ToStr(LumbyDiary);
    WriteLn('[FARM] Explorer''s ring name set to: ', Self.LumbyRingName);
  end
  else
  begin
    WriteLn('[FARM] Warning: Lumbridge diary level is 0 - no ring will be withdrawn');
  end;

  // Weiss Herb Patch
  if FARMWEISSHERB then
  begin
    Self.FarmRun.AddPatch(EFarmPatch.WEISS_HERB, ETravelMethod.ICY_BASALT, GetHerbSeedName(FARMHERBSEED));
    Inc(Self.CompostNeeded, 1);
  end;

  // Stronghold Herb Patch
  if FARMSTRONGHOLDHERB then
  begin
    Self.FarmRun.AddPatch(EFarmPatch.STRONGHOLD_HERB, ETravelMethod.STONY_BASALT, GetHerbSeedName(FARMHERBSEED));
    Inc(Self.CompostNeeded, 1);
  end;

  // Ardougne Herb Patch
  if FARMARDOUGNEHERB then
  begin
    if ArdyDiary >= 4 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_HERB, ETravelMethod.ARDY_CLOAK_4, GetHerbSeedName(FARMHERBSEED));
    end
    else
    if ArdyDiary >= 3 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_HERB, ETravelMethod.ARDY_CLOAK_3, GetHerbSeedName(FARMHERBSEED));
    end
    else
    if ArdyDiary >= 2 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_HERB, ETravelMethod.ARDY_CLOAK_2, GetHerbSeedName(FARMHERBSEED));
    end
    else
    begin
      WriteLn('[FARM] Warning: Ardougne diary level too low for herb patch teleport');
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Ardougne Flower Patch
  if FARMARDOUGNEFLOWER then
  begin
    if ArdyDiary >= 4 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_FLOWER, ETravelMethod.ARDY_CLOAK_4, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    if ArdyDiary >= 3 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_FLOWER, ETravelMethod.ARDY_CLOAK_3, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    if ArdyDiary >= 2 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.ARDY_FLOWER, ETravelMethod.ARDY_CLOAK_2, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    begin
      WriteLn('[FARM] Warning: Ardougne diary level too low for flower patch teleport');
    end;
  end;

  // Falador Herb Patch
  if FARMFALADORHERB then
  begin
    if LumbyDiary >= 4 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_HERB, ETravelMethod.EXPLORERS_RING_4, GetHerbSeedName(FARMHERBSEED));
    end
    else
    if LumbyDiary >= 3 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_HERB, ETravelMethod.EXPLORERS_RING_3, GetHerbSeedName(FARMHERBSEED));
    end
    else
    if LumbyDiary >= 2 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_HERB, ETravelMethod.EXPLORERS_RING_2, GetHerbSeedName(FARMHERBSEED));
    end
    else
    begin
      WriteLn('[FARM] Warning: Lumbridge diary level too low for Falador herb patch teleport');
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Falador Flower Patch
  if FARMFALADORFLOWER then
  begin
    if LumbyDiary >= 4 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_FLOWER, ETravelMethod.EXPLORERS_RING_4, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    if LumbyDiary >= 3 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_FLOWER, ETravelMethod.EXPLORERS_RING_3, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    if LumbyDiary >= 2 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.FALLY_FLOWER, ETravelMethod.EXPLORERS_RING_2, GetFlowerSeedName(FARMFOWERSEED));
    end
    else
    begin
      WriteLn('[FARM] Warning: Lumbridge diary level too low for Falador flower patch teleport');
    end;
  end;

  // Catherby Herb Patch
  if FARMCATHERBYHERB then
  begin
    case FARMCATHERBYTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_HERB, ETravelMethod.CAMELOT_TELEPORT, GetHerbSeedName(FARMHERBSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_HERB, ETravelMethod.CAMELOT_TABLET, GetHerbSeedName(FARMHERBSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_HERB, ETravelMethod.CATHERBY_TABLET, GetHerbSeedName(FARMHERBSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Catherby Flower Patch
  if FARMCATHERBYFLOWER then
  begin
    case FARMCATHERBYTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_FLOWER, ETravelMethod.CATHERBY_TELEPORT, GetFlowerSeedName(FARMFOWERSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_FLOWER, ETravelMethod.CAMELOT_TABLET, GetFlowerSeedName(FARMFOWERSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_FLOWER, ETravelMethod.CATHERBY_TABLET, GetFlowerSeedName(FARMFOWERSEED));
    end;
  end;

  // Catherby North Allotment Patch
  if FARMCATHERBYALLOTMENTN then
  begin
    case FARMCATHERBYTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_N, ETravelMethod.CAMELOT_TELEPORT, GetAllotmentSeedName(FARMALLOTMENTSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_N, ETravelMethod.CATHERBY_TELEPORT, GetAllotmentSeedName(FARMALLOTMENTSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_N, ETravelMethod.CAMELOT_TABLET, GetAllotmentSeedName(FARMALLOTMENTSEED));
      4: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_N, ETravelMethod.CATHERBY_TABLET, GetAllotmentSeedName(FARMALLOTMENTSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Catherby South Allotment Patch
  if FARMCATHERBYALLOTMENTS then
  begin
    case FARMCATHERBYTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_S, ETravelMethod.CAMELOT_TELEPORT, GetAllotmentSeedName(FARMALLOTMENTSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_S, ETravelMethod.CATHERBY_TELEPORT, GetAllotmentSeedName(FARMALLOTMENTSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_S, ETravelMethod.CAMELOT_TABLET, GetAllotmentSeedName(FARMALLOTMENTSEED));
      4: Self.FarmRun.AddPatch(EFarmPatch.CATHERBY_ALLOT_S, ETravelMethod.CATHERBY_TABLET, GetAllotmentSeedName(FARMALLOTMENTSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Port Phasmatys Herb Patch
  if FARMPORTPHASMATYSHERB then
  begin
    Self.FarmRun.AddPatch(EFarmPatch.PHASMATYS_HERB, ETravelMethod.ECTOPHIAL, GetHerbSeedName(FARMHERBSEED));
    Inc(Self.CompostNeeded, 1);
  end;

  // Hosidius Herb Patch
  if FARMHOSIDIUSHERB then
  begin
    case FARMHOSIDIUSTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.XERICS_TALISMAN, GetHerbSeedName(FARMHERBSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.HOSIDIOUS_TABLET, GetHerbSeedName(FARMHERBSEED));
      3, 4: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.HOUSE_TELEPORT, GetHerbSeedName(FARMHERBSEED));
      5, 6: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.CON_CAPE_HOSIDIUS, GetHerbSeedName(FARMHERBSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Hosidius Flower Patch
  if FARMHOSIDIUSFLOWER then
  begin
    case FARMHOSIDIUSTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.XERICS_TALISMAN, GetFlowerSeedName(FARMFOWERSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.HOSIDIOUS_TABLET, GetFlowerSeedName(FARMFOWERSEED));
      3, 4: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.HOUSE_TELEPORT, GetFlowerSeedName(FARMFOWERSEED));
      5, 6: Self.FarmRun.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.CON_CAPE_HOSIDIUS, GetFlowerSeedName(FARMFOWERSEED));
    end;
  end;

  // Ardougne Whiteberry Patch (Monastery Bush)
  if FARMKANDARINBUSH then
  begin
    if ArdyDiary >= 4 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.MONESTARY_BUSH, ETravelMethod.ARDY_CLOAK_4_BUSH, 'Whiteberry seed');
    end
    else
    if ArdyDiary >= 3 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.MONESTARY_BUSH, ETravelMethod.ARDY_CLOAK_3_BUSH, 'Whiteberry seed');
    end
    else
    if ArdyDiary >= 2 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.MONESTARY_BUSH, ETravelMethod.ARDY_CLOAK_2_BUSH, 'Whiteberry seed');
    end
    else
    if ArdyDiary >= 1 then
    begin
      Self.FarmRun.AddPatch(EFarmPatch.MONESTARY_BUSH, ETravelMethod.ARDY_CLOAK_1_BUSH, 'Whiteberry seed');
    end
    else
    begin
      WriteLn('[FARM] Warning: Ardougne diary level too low for monastery bush patch teleport');
    end;
  end;

  // Farming Guild Herb Patch
  if FARMFARMGUILDHERB then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_HERB, ETravelMethod.SKILLS_NECKLACE, GetHerbSeedName(FARMHERBSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_HERB, ETravelMethod.FARMING_CAPE, GetHerbSeedName(FARMHERBSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_HERB, ETravelMethod.FARMING_CAPE, GetHerbSeedName(FARMHERBSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Farming Guild Flower Patch
  if FARMFARMGUILDFLOWER then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_FLOWER, ETravelMethod.SKILLS_NECKLACE, GetFlowerSeedName(FARMFOWERSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_FLOWER, ETravelMethod.FARMING_CAPE, GetFlowerSeedName(FARMFOWERSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_FLOWER, ETravelMethod.FARMING_CAPE, GetFlowerSeedName(FARMFOWERSEED));
    end;
  end;

  // Farming Guild Whiteberry Patch (Bush)
  if FARMFARMGUILDBUSH then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_BUSH, ETravelMethod.SKILLS_NECKLACE, 'Whiteberry seed');
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_BUSH, ETravelMethod.FARMING_CAPE, 'Whiteberry seed');
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_BUSH, ETravelMethod.FARMING_CAPE, 'Whiteberry seed');
    end;
  end;

  // Farming Guild North Allotment Patch
  if FARMFARMGUILDALLOTMENTN then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_N, ETravelMethod.SKILLS_NECKLACE, GetAllotmentSeedName(FARMALLOTMENTSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_N, ETravelMethod.FARMING_CAPE, GetAllotmentSeedName(FARMALLOTMENTSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_N, ETravelMethod.FARMING_CAPE, GetAllotmentSeedName(FARMALLOTMENTSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Farming Guild South Allotment Patch
  if FARMFARMGUILDALLOTMENTS then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_S, ETravelMethod.SKILLS_NECKLACE, GetAllotmentSeedName(FARMALLOTMENTSEED));
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_S, ETravelMethod.FARMING_CAPE, GetAllotmentSeedName(FARMALLOTMENTSEED));
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_ALLOT_S, ETravelMethod.FARMING_CAPE, GetAllotmentSeedName(FARMALLOTMENTSEED));
    end;
    Inc(Self.CompostNeeded, 1);
  end;

  // Farming Guild Cactus Patch
  if FARMFARMGUILDCACTUS then
  begin
    case FARMFARMGUILDTP of
      1: Self.FarmRun.AddPatch(EFarmPatch.GUILD_CACTUS, ETravelMethod.SKILLS_NECKLACE, 'Potato cactus seed');
      2: Self.FarmRun.AddPatch(EFarmPatch.GUILD_CACTUS, ETravelMethod.FARMING_CAPE, 'Potato cactus seed');
      3: Self.FarmRun.AddPatch(EFarmPatch.GUILD_CACTUS, ETravelMethod.FARMING_CAPE, 'Potato cactus seed');
    end;
  end;

  // Giant Seaweed North Patch
  if FARMGIANTSEAWEEDN then
  begin
    Self.FarmRun.AddPatch(EFarmPatch.GIANT_SEAWEED_NORTH, ETravelMethod.DIGSITE_TO_SEAWEED, 'Seaweed spore');
    Inc(Self.CompostNeeded, 1);
  end;

  // Giant Seaweed South Patch
  if FARMGIANTSEAWEEDS then
  begin
    Self.FarmRun.AddPatch(EFarmPatch.GIANT_SEAWEED_SOUTH, ETravelMethod.DIGSITE_TO_SEAWEED, 'Seaweed spore');
    Inc(Self.CompostNeeded, 1);
  end;

  WriteLn('[FARM] Patch setup complete... Compost needed: ', Self.CompostNeeded);
end;

// Calculate total rune requirements for all selected patches
function TFarmRun.CalculateRuneRequirements(): TRuneRequirements;
var
  totalAirRunes, totalLawRunes, totalEarthRunes, totalFireRunes: Int32;
  catherbyPatches, hosidiusPatches: Boolean;
begin
  totalAirRunes := 0;
  totalLawRunes := 0;
  totalEarthRunes := 0;
  totalFireRunes := 0;
  
  catherbyPatches := FARMCATHERBYHERB or FARMCATHERBYFLOWER or FARMCATHERBYALLOTMENTN or FARMCATHERBYALLOTMENTS;
  hosidiusPatches := FARMHOSIDIUSHERB or FARMHOSIDIUSFLOWER;
  
  // Catherby teleport runes (Camelot teleport: 5 Air + 1 Law)
  if catherbyPatches and (FARMCATHERBYTP = 1) then
  begin
    Inc(totalAirRunes, 5);
    Inc(totalLawRunes);
    WriteLn('[FARM] Catherby patches selected - adding 5 Air + 1 Law rune (Camelot teleport)');
  end;
  
  // Hosidius teleport runes (Earth + Law + Air)
  if ((FARMHOSIDIUSTP = 4)) and hosidiusPatches then
  begin
    if not GemStoneCrabBot.InfiniteEarth then
    begin
      Inc(totalEarthRunes);
      WriteLn('[FARM] Hosidius patches selected - adding 1 Earth rune');
    end;
    Inc(totalLawRunes);
    Inc(totalAirRunes);
    WriteLn('[FARM] Hosidius patches selected - adding 1 Law + 1 Air rune');
  end;
  
  // Return to Civitas Illa Fortis runes (always needed)
  Inc(totalLawRunes, 2);
  WriteLn('[FARM] Return to Civitas Illa Fortis - adding 2 Law runes');
  if not GemStoneCrabBot.InfiniteEarth then
  begin
    Inc(totalEarthRunes);
    WriteLn('[FARM] Return to Civitas Illa Fortis - adding 1 Earth rune');
  end;
  if not GemStoneCrabBot.InfiniteFire then
  begin
    Inc(totalFireRunes);
    WriteLn('[FARM] Return to Civitas Illa Fortis - adding 1 Fire rune');
  end;
  
  Result.AirRunes := totalAirRunes;
  Result.LawRunes := totalLawRunes;
  Result.EarthRunes := totalEarthRunes;
  Result.FireRunes := totalFireRunes;
end;

procedure TFarmRun.OnStart(); override;
var
  bankTimeout: TCountdown;
  I: Int32;
  runeReqs: TRuneRequirements;
begin
  WriteLn('[FARM] OnStart: Opening nearest bank...');

  // Pause antiban tasks during farm run
  for I := 0 to High(Antiban.tasks) do
    Antiban.Tasks[I].Countdown.Pause;

  Banks.WalkOpen();

  bankTimeout.Init(45000);
  while not bankTimeout.IsFinished() and not Bank.IsOpen() do
  begin
    //poll misclick check
    if RSInterface.IsOpen() then
      RSInterface.Close();

    Wait(1000);
    Banks.WalkOpen();
  end;

  if not Bank.IsOpen() then
  begin
    WriteLn('[FARM] Error: Could not open bank after timeout');
    Exit;
  end;

  WriteLn('[FARM] OnStart: Depositing all items...');
  Bank.DepositAll();
  
  // Wait until inventory is empty (28 empty slots)
  if not WaitUntil(Inventory.CountEmptySlots() = 28, 65, 5000) then
  begin
    WriteLn('[FARM] Inventory is not empty after deposit???');
  end;

  WriteLn('[FARM] OnStart: Withdrawing farm run items...');

  // Withdraw basic tools
  if not FARMBARBDIBBER then
    GemStoneCrabBot.WithdrawHelper('Seed dibber', 1);

  GemStoneCrabBot.WithdrawHelper('Spade', 1);

  if FARMMAGICSECATEURS and not GemStoneCrabBot.MagicSecsEquipped then
    GemStoneCrabBot.WithdrawHelper('Magic secateurs', 1);

  // Withdraw basalt teleport items
  if FARMWEISSHERB then
    GemStoneCrabBot.WithdrawHelper('Icy basalt', 1);

  if FARMSTRONGHOLDHERB then
    GemStoneCrabBot.WithdrawHelper('Stony basalt', 1);

  // Withdraw Ardougne Cloak for Ardougne patches
  if (FARMARDOUGNEHERB or FARMARDOUGNEFLOWER or FARMKANDARINBUSH) and (not GemStoneCrabBot.ArdyCloakEquipped) and (GemStoneCrabBot.ArdyCloakName <> '') then
    GemStoneCrabBot.WithdrawHelper(GemStoneCrabBot.ArdyCloakName, 1);

  // Withdraw Farming Guild teleport items
  if FARMFARMGUILDHERB or FARMFARMGUILDFLOWER or FARMFARMGUILDBUSH or FARMFARMGUILDALLOTMENTN or FARMFARMGUILDALLOTMENTS or FARMFARMGUILDCACTUS then
  begin
    case FARMFARMGUILDTP of
      1: // Skills necklace
        if not Inventory.ContainsAny(['Skills necklace(6)', 'Skills necklace(5)', 'Skills necklace(4)', 'Skills necklace(3)', 'Skills necklace(2)', 'Skills necklace(1)']) then
        begin
          if not GemStoneCrabBot.Transport.withdrawTeleportItem(RSTeleports.FARMING_GUILD) then
            TerminateScript('Could not find the skills necklace');
        end;
      2: // Farming cape UNTRIMMED
        if not GemStoneCrabBot.FarmingCapeEquipped then
          GemStoneCrabBot.WithdrawHelper('Farming cape', 1);
      3: // Farming cape TRIMMED
        if not GemStoneCrabBot.FarmingCapeEquipped then
          GemStoneCrabBot.WithdrawHelper('Farming cape(t)', 1);
    end;
  end;

  // Withdraw Explorer's Ring for Falador patches
  if (FARMFALADORHERB or FARMFALADORFLOWER) and (not GemStoneCrabBot.LumbyRingEquipped) and (GemStoneCrabBot.LumbyRingName <> '') then
    GemStoneCrabBot.WithdrawHelper(GemStoneCrabBot.LumbyRingName, 1);

  // Withdraw Catherby teleport items
  if (FARMCATHERBYHERB or FARMCATHERBYFLOWER or FARMCATHERBYALLOTMENTN or FARMCATHERBYALLOTMENTS) then
  begin
    case FARMCATHERBYTP of
      //1: // Catherby teleport
      //  GemStoneCrabBot.WithdrawHelper('Catherby teleport', -1);
      2: // Camelot tablet
        GemStoneCrabBot.WithdrawHelper('Camelot teleport', -1);
      3: // Catherby tablet
        GemStoneCrabBot.WithdrawHelper('Catherby teleport', -1);
    end;
  end;

  // Withdraw Ectophial for Port Phasmatys
  if FARMPORTPHASMATYSHERB then
    GemStoneCrabBot.WithdrawHelper('Ectophial', 1);

  // Withdraw rune pouch
  case FARMRUNEPOUCH of
    1: // Rune pouch
      GemStoneCrabBot.WithdrawHelper('Rune pouch', 1);
    2: // Divine rune pouch
      GemStoneCrabBot.WithdrawHelper('Divine rune pouch', 1);
  end;

  // Withdraw Hosidius teleport items
  if (FARMHOSIDIUSHERB or FARMHOSIDIUSFLOWER) then
  begin
    case FARMHOSIDIUSTP of
      1: // Xeric's talisman
        if not GemStoneCrabBot.XericTaliEquipped then
          GemStoneCrabBot.WithdrawHelper('Xeric''s talisman', 1);
      2: // Hosidius tablet
        GemStoneCrabBot.WithdrawHelper('Hosidius teleport', -1);
      3: // House teleport tablet
        GemStoneCrabBot.WithdrawHelper('Teleport to house', -1);
      4: // House teleport runes
      begin
        // Runes are handled by the calculate total runes
        case FARMRUNEPOUCH of
          0: // Not using/use runes
          begin
            // Runes withdrawn by with calculated totals
          end;
        end;
      end;
      5: // Construction cape UNTRIMMED
        if not GemStoneCrabBot.ConstructionCapeEquipped then
          GemStoneCrabBot.WithdrawHelper('Construct. cape', 1);
      6: // Construction cape TRIMMED
        if not GemStoneCrabBot.ConstructionCapeEquipped then
          GemStoneCrabBot.WithdrawHelper('Construct. cape(t)', 1);
    end;
  end;

  // Withdraw compost based on type
  if GemStoneCrabBot.CompostNeeded > 0 then
  begin
    case FARMCOMPOSTTYPE of
      0: // Compost
        GemStoneCrabBot.WithdrawHelper('Compost', GemStoneCrabBot.CompostNeeded);
      1: // Supercompost
        GemStoneCrabBot.WithdrawHelper('Supercompost', GemStoneCrabBot.CompostNeeded);
      2: // Ultracompost
        GemStoneCrabBot.WithdrawHelper('Ultracompost', GemStoneCrabBot.CompostNeeded);
      3: // Bottomless compost bucket
        GemStoneCrabBot.WithdrawHelper('Bottomless compost bucket', 1);
    end;
  end;

  // Withdraw seeds
  if FARMWEISSHERB or FARMSTRONGHOLDHERB or FARMARDOUGNEHERB or FARMFALADORHERB or FARMCATHERBYHERB or FARMPORTPHASMATYSHERB or FARMHOSIDIUSHERB or FARMFARMGUILDHERB then
    GemStoneCrabBot.WithdrawHelper(GetHerbSeedName(FARMHERBSEED), -1);

  if FARMARDOUGNEFLOWER or FARMFALADORFLOWER or FARMCATHERBYFLOWER or FARMHOSIDIUSFLOWER or FARMFARMGUILDFLOWER then
    GemStoneCrabBot.WithdrawHelper(GetFlowerSeedName(FARMFOWERSEED), -1);

  if FARMCATHERBYALLOTMENTN or FARMCATHERBYALLOTMENTS or FARMFARMGUILDALLOTMENTN or FARMFARMGUILDALLOTMENTS then
    GemStoneCrabBot.WithdrawHelper(GetAllotmentSeedName(FARMALLOTMENTSEED), -1);

  if FARMGIANTSEAWEEDN or FARMGIANTSEAWEEDS then
  begin
    GemStoneCrabBot.WithdrawHelper('Seaweed spore', -1);

    if not Inventory.ContainsAny(['Digsite pendant (5)', 'Digsite pendant (4)', 'Digsite pendant (3)', 'Digsite pendant (2)', 'Digsite pendant (1)']) and not FARMJUSTGIANTSEAWEED then
    begin
      if not GemStoneCrabBot.Transport.withdrawTeleportItem(RSTeleports.DIGSITE) then
        TerminateScript('Could not find the digsite pendant');
    end;
  end;

  // Calculate total rune requirements selected patches
  runeReqs := Self.CalculateRuneRequirements();
  
  WriteLn('[FARM] OnStart: Calculated rune requirements - Air: ', runeReqs.AirRunes, ', Law: ', runeReqs.LawRunes, ', Earth: ', runeReqs.EarthRunes, ', Fire: ', runeReqs.FireRunes);

  // Withdraw runes for teleport methods
  case FARMRUNEPOUCH of
    0: // None - withdraw individual runes
    begin
      // Withdraw calculated total runes needed
      if runeReqs.AirRunes > 0 then
        GemStoneCrabBot.WithdrawHelper('Air rune', runeReqs.AirRunes);
      if runeReqs.LawRunes > 0 then
        GemStoneCrabBot.WithdrawHelper('Law rune', runeReqs.LawRunes);
      if runeReqs.EarthRunes > 0 then
        GemStoneCrabBot.WithdrawHelper('Earth rune', runeReqs.EarthRunes);
      if runeReqs.FireRunes > 0 then
        GemStoneCrabBot.WithdrawHelper('Fire rune', runeReqs.FireRunes);
    end;
  end;

  WriteLn('[FARM] OnStart: Farm run preparation complete');
end;

procedure TFarmRun.OnComplete(); override;
const
  CIVITAS_TELEPORT_TIMEOUT = 10000;
  RENU_TRAVEL_TIMEOUT = 10000;
  MAX_TELEPORT_ATTEMPTS = 3;
  MAX_RENU_ATTEMPTS = 5;
  MAX_BANK_ATTEMPTS = 5;
  CIVITAS_BOX: TBox = [2572, 37822, 2756, 37930];
  TAL_TEKLAN_BOX: TBox = [776, 38038, 848, 38094];
var
  teleportAttempts, renuAttempts, bankAttempts: Int32;
  teleportSuccess, renuSuccess, bankSuccess: Boolean;
  GreenTPA: TPointArray;
begin
  WriteLn('[FARM] OnComplete: Farm run completed - returning to mr crabs');

  teleportSuccess := False;
  for teleportAttempts := 1 to MAX_TELEPORT_ATTEMPTS do
  begin
    WriteLn('[FARM] Teleport attempt ', teleportAttempts, '/', MAX_TELEPORT_ATTEMPTS);

    if Magic.CastSpell(ERSSpell.CIVITAS_ILLA_FORTIS_TELEPORT) then
    begin
      if WaitUntil(Map.Position.InBox(CIVITAS_BOX), 65, CIVITAS_TELEPORT_TIMEOUT) then
      begin
        teleportSuccess := True;
        WriteLn('[FARM] Successfully teleported to Civitas Illa Fortis');
        Break;
      end
      else
        WriteLn('[FARM] Teleport completed but position not in box - attempt ', teleportAttempts);
    end
    else
      WriteLn('[FARM] Failed to cast teleport spell - attempt ', teleportAttempts);

    if teleportAttempts < MAX_TELEPORT_ATTEMPTS then
      Wait(Random(1000, 2000));
  end;

  if not teleportSuccess then
  begin
    WriteLn('[FARM] ERROR: Failed to teleport to Civitas Illa Fortis after ', MAX_TELEPORT_ATTEMPTS, ' attempts');
    TerminateScript('Teleport failure - unable to return from farm run');
  end;

  if Map.Position.InBox(TAL_TEKLAN_BOX) then
  begin
    WriteLn('[FARM] Already in Tal Teklan - skipping Renu interaction');
    renuSuccess := True;
  end
  else
  begin
    if not Map.Position.InBox(CIVITAS_BOX) then
    begin
      WriteLn('[FARM] ERROR: Not in Civitas Illa Fortis - cannot interact with Renu');
      Map.DebugPosition();
      TerminateScript('Location error - Please send this debug on Discord to BigAussie');
    end;

    renuSuccess := False;
    for renuAttempts := 1 to MAX_RENU_ATTEMPTS do
    begin
      WriteLn('[FARM] Renu interaction attempt ', renuAttempts, '/', MAX_RENU_ATTEMPTS);

      try
        if GemStoneCrabBot.Renu.WalkSelectOption(['Last-destination']) then
        begin
          WriteLn('[FARM] Successfully selected Last-destination on Renu');

          if WaitUntil(Map.Position.InBox(TAL_TEKLAN_BOX), 65, RENU_TRAVEL_TIMEOUT) then
          begin
            renuSuccess := True;
            WriteLn('[FARM] Successfully traveled back to Tal Teklan');
            Break;
          end
          else
            WriteLn('[FARM] Renu interaction succeeded but position verification failed - attempt ', renuAttempts);
        end
        else
          WriteLn('[FARM] Failed to interact with Renu - attempt ', renuAttempts);
      except
        WriteLn('[FARM] Exception during Renu interaction - attempt ', renuAttempts);
      end;

      // If we misclick, this should select the travel option
      SRL.FindColors(GreenTPA, CTS2(7828822, 3, 0.03, 0.02), Mainscreen.Bounds);
      if GreenTPA.Len > 0 then
      begin
        WriteLn('[FARM] Misclicked when trying to select Last-destination');
        Mouse.Move(GreenTPA.Mean);
        if MainScreen.IsUpText(['Tal Teklan']) then
        begin
          Mouse.Click(MOUSE_LEFT);
          WriteLn('[FARM] Clicked travel interface - waiting for arrival at Tal Teklan');
          if WaitUntil(Map.Position.InBox(TAL_TEKLAN_BOX), 65, RENU_TRAVEL_TIMEOUT) then
          begin
            renuSuccess := True;
            WriteLn('[FARM] Successfully completed manual flight to Tal Teklan');
            Break;
          end
          else
            WriteLn('[FARM] Failed to travel to Tal Teklan - attempt ', renuAttempts);
        end
        else
          WriteLn('[FARM] Travel interface found but no valid uptext?? - attempt ', renuAttempts);
      end;

      // Check if we're already in Tal Teklan
      if Map.Position.InBox(TAL_TEKLAN_BOX) then
      begin
        renuSuccess := True;
        WriteLn('[FARM] Successfully traveled back to Tal Teklan');
        Break;
      end;

      if renuAttempts < MAX_RENU_ATTEMPTS then
        Wait(Random(1000, 2000));
    end;
  end;

  if not renuSuccess then
  begin
    WaitUntil(Map.Position.InBox(TAL_TEKLAN_BOX), 65, RENU_TRAVEL_TIMEOUT);
    if not Map.Position.InBox(TAL_TEKLAN_BOX) then
    begin
      Map.DebugPosition();
      WriteLn('[FARM] ERROR: Failed to travel back to Tal Teklan after ', MAX_RENU_ATTEMPTS, ' attempts');
      TerminateScript('Renu travel failure');
    end
    else
    begin
      WriteLn('[FARM] Successfully traveled back to Tal Teklan');
    end;
  end;

  WriteLn('[FARM] OnComplete: Successfully returned - farm run complete');

  WriteLn('[FARM] Opening bank after farm run.');
  bankSuccess := False;
  for bankAttempts := 1 to MAX_BANK_ATTEMPTS do
  begin
    WriteLn('[FARM] Bank opening attempt ', bankAttempts, '/', MAX_BANK_ATTEMPTS);
    
    if Banks.WalkOpen() then
    begin
      bankSuccess := True;
      WriteLn('[FARM] Bank opened successfully on attempt ', bankAttempts);
      Break;
    end;
    
    if bankAttempts < MAX_BANK_ATTEMPTS then
    begin
      WriteLn('[FARM] Bank opening failed, rotating camera and retrying...');
      Antiban.RandomRotate();
    end;
  end;
  
  if not bankSuccess then
  begin
    WriteLn('[FARM] ERROR: Failed to open bank after ', MAX_BANK_ATTEMPTS, ' attempts - going back to fight crab');
    GemStoneCrabBot.BankingDisabled := True;
    Exit;
  end;

  WriteLn('[FARM] Bank opened successfully - depositing all items');

  if Bank.DepositAll() then
  begin
    WriteLn('[FARM] Successfully deposited all inventory items');
  end
  else
  begin
    WriteLn('[FARM] WARNING: Failed to deposit all items - continuing anyway');
  end;

  Wait(700, 1000);

  WriteLn('[FARM] Withdrawing normal loadout using HandleBankItems...');

  GemStoneCrabBot.HandleBankItems();

  WriteLn('[FARM] Farm run complete - returning to fight CRAB');
end;

function GemStoneCrabSlayer.SafeReadXPBar(): Integer;
var
  XPValue: Integer;
  AttemptCount: Int32;
  ValidReading: Boolean;
  PreviousValidXP: Integer;
  XPDifference: Integer;
  TimeSinceLastRead: UInt64;
  MaxPossibleGain: Integer;
begin
  if (not RSClient.IsLoggedIn) then
    Exit(Self.PrevXP);

  if RSInterface.IsOpen() then
    RSInterface.Close();

  Result := Self.PrevXP;
  ValidReading := False;
  AttemptCount := 0;

  if Self.PrevXP > 0 then
    PreviousValidXP := Self.PrevXP
  else
    PreviousValidXP := Self.StartXP;

  while (not ValidReading) and (AttemptCount < 5) do
  begin
    Inc(AttemptCount);

    // Check if XP bar is open because it was randomly closing??
    if not XPBar.IsOpen() then
    begin
      WriteLn('XP bar not open, attempting to open...');
      XPBar.Open();
      Wait(500 + Random(500));
    end;

    XPValue := XPBar.Read();

    if XPValue <= 0 then
    begin
      WriteLn('Invalid XP reading: ', XPValue, ' (zero or negative)');
      //Self.TakeScreenshot('XP_Invalid_Zero_Negative_' + IntToStr(XPValue));
    end
    else if XPValue < 10000 then
    begin
      WriteLn('Invalid XP reading: ', XPValue, ' (too low)');
      //Self.TakeScreenshot('XP_Invalid_TooLow_' + IntToStr(XPValue));
    end
    else if (PreviousValidXP > 0) then
    begin
      XPDifference := XPValue - PreviousValidXP;
      TimeSinceLastRead := GetTickCount() - Self.LastHealthCheck;

      MaxPossibleGain := Round((TimeSinceLastRead / 1000.0) * 100);
      if MaxPossibleGain < 1000 then MaxPossibleGain := 1000;

      if XPDifference > MaxPossibleGain then
      begin
        WriteLn('Invalid XP reading: ', XPValue, ' (impossible gain of ', XPDifference, ' XP in ', Round(TimeSinceLastRead/1000), 's)');
        //Self.TakeScreenshot('XP_Invalid_ImpossibleGain_' + IntToStr(XPDifference) + 'XP');
      end
      else if XPDifference < -1000 then
      begin
        WriteLn('Invalid XP reading: ', XPValue, ' (impossible loss of ', Abs(XPDifference), ' XP)');
        //Self.TakeScreenshot('XP_Invalid_ImpossibleLoss_' + IntToStr(Abs(XPDifference)) + 'XP');
      end
      else
      begin
        ValidReading := True;
        Result := XPValue;
      end;
    end
    else
    begin
      ValidReading := True;
      Result := XPValue;
    end;

    if not ValidReading then
    begin
      if AttemptCount < 3 then
      begin
        WriteLn('Rotating camera for xp bar. Is your XP bar visible?!?!');
        Antiban.RandomRotate();
        Wait(500 + Random(1000));
      end
      else
      begin
        WriteLn('Waiting before retry...');
        Wait(1000 + Random(2000));
      end;
    end;
  end;

  if not ValidReading then
  begin
    Inc(Self.ConsecutiveXPFailures);
    WriteLn('Failed to get valid XP reading after 5 attempts. Consecutive failures: ', Self.ConsecutiveXPFailures);

    if Self.ConsecutiveXPFailures >= 10 then
    begin
      WriteLn('CRITICAL ERROR: XP bar reading failed!');
      WriteLn('XP bar setup must be wrong. Please check your XP bar configuration.');
      WriteLn('Ensure you have run settings searcher and your XP Bar is setup correctly.');
      WriteLn('Terminating script.');
      Self.TakeScreenshot('XP_Bar_Setup_Error');
      TerminateScript();
    end;

    Result := PreviousValidXP;
  end
  else
  begin
    Self.ConsecutiveXPFailures := 0;
  end;
end;

procedure GemStoneCrabSlayer.Run(MaxActions: UInt32; MaxTime: UInt64);
begin
  // Just incase someone starts the script with quick prayers open lets close that shit
  if QuickPrayer.IsOpen() then
    QuickPrayer.Close();

  Self.Init(MaxActions, MaxTime);

  Self.DrawStatusDisplay();

  repeat
  if (not RSClient.IsLoggedIn) then
    if Login.GetPlayer.User <> '' then
      Login.LoginPlayer
    else
    begin
      Exit;
    end;

    if (GetTickCount() - Self.LastImageClear) >= 30000 then
    begin
      RSClient.Image.Clear;
      DrawStatusDisplay();
      Self.LastImageClear := GetTickCount();
    end;

    Self.CheckHourlyReport();
    Self.CheckSystemUpdate();

    if (not ChatButtons.IsActive(ERSChatButton.ALL_CHAT)) and (not ChatButtons.IsActive(ERSChatButton.GAME_CHAT)) then
      ChatButtons.Open(ERSChatButton.ALL_CHAT);

    // Check for death
    if (Chat.FindMessage('you are dead', [CHAT_COLOR_BLACK])) then
    begin
      Self.TakeScreenshot('_PlayerDeath');
      WaitUntil(Minimap.PercentBlack() < 20, 65, 10000);
      WriteLn('PLAYER HAS DIED! Terminating script');

      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**PLAYER DEATH** :skull: Script detected player death and is terminating.';
          Discord.SendScreenshot(False);
        except
          WriteLn('[Discord] Failed to send death notification');
        end;
      end;
      Logout.ClickLogout();
      TerminateScript('Player death detected');
    end;

    // Check for out of ammo
    if Self.IsOutOfAmmo() then
    begin
      WriteLn('OUT OF AMMO DETECTED! Terminating script');
      Self.TakeScreenshot('_OutOfAmmo');

      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**OUT OF AMMO** :warning: Script detected ammo depletion and is terminating.';
          Discord.SendScreenshot(False);
        except
          WriteLn('[Discord] Failed to send out of ammo notification');
        end;
      end;
      Logout.ClickLogout();
      TerminateScript('Out of ammo detected');
    end;

    // Check for Dharoks armour degradation
    if Self.CheckForDegradation() then
    begin
      Exit;
    end;

    Self.DoAction();

    // Check for farm run
    if ENABLEFARMRUNS and (not Self.FarmRunInProgress) then
    begin
      if Self.FarmRun.ReadyTimer.IsFinished then
      begin
        InCombat := False;
        IsAttacking := False;
        WriteLn('[FARM] Starting farm run...');
        Self.FarmRunInProgress := True;
        Self.DrawStatusDisplay();

        Self.FarmRun.DoFarmRun();

        Self.FarmRunInProgress := False;
        WriteLn('[FARM] Farm run completed');
      end;
    end;

    if (GetTimeRunning() mod 2000) < 1000 then
      Self.DrawStatusDisplay();

    if Self.InCombat or Self.IsAttacking then
    begin
      Self.DoAntiban(True, False); // Allow break in combat but not sleep (logout chance removed in TakeBreak override)
    end
    else
    begin
      Self.DoAntiban(True, True); // Allow breaks when not in combat
    end;

    if (GetTimeRunning() mod 10000) < 1000 then
      Self.Report();

    if WL.Activity.IsFinished() then
      begin
      WriteLn('No activity detected in 5 minutes! Shutting down.');
      TerminateScript('No activity detected in 5 minutes');
    end;

  until Self.ShouldStop();

  Self.Report();
  if ENABLEWEBHOOKS then
  begin
    try
      Discord.Webhook.Content := '';
      Discord.Webhook.Content += '**Script finished normally** :checkered_flag: Runtime: ' + SRL.MsToTime(GetTimeRunning(), Time_Short);
      Discord.Send();
    except
      WriteLn('[Discord] Failed to send completion notification');
    end;
  end;
end;

function GemStoneCrabSlayer.TryEnterCave(): Boolean;
var
  StartTime: UInt64;
  CurrentPos: TPoint;
  NorthDistance, EastDistance, SouthDistance: Double;
  ClosestCave: TRSObjectV2;
  CaveName: String;
  ClosestDistance: Double;
begin
  Result := False;

  WriteLn('Finding nearest cave entrance...');

  CurrentPos := Map.Position;
  WriteLn('Current position: ', CurrentPos.X, ', ', CurrentPos.Y);

  // Calculate distances to each cave
  NorthDistance := CurrentPos.DistanceTo(Point(1020, 37758));
  EastDistance := CurrentPos.DistanceTo(Point(1312, 37934));
  SouthDistance := CurrentPos.DistanceTo(Point(892, 38286));

  WriteLn('Cave distances - North: ', FloatToStr(NorthDistance), ', East: ', FloatToStr(EastDistance), ', South: ', FloatToStr(SouthDistance));

  // Find the closest cave
  if (NorthDistance <= EastDistance) and (NorthDistance <= SouthDistance) then
  begin
    ClosestCave := CaveNorth;
    CaveName := 'North';
    ClosestDistance := NorthDistance;
    WriteLn('North cave is closest (', FloatToStr(NorthDistance), ' tiles)');
  end
  else if (EastDistance <= NorthDistance) and (EastDistance <= SouthDistance) then
  begin
    ClosestCave := CaveEast;
    CaveName := 'East';
    ClosestDistance := EastDistance;
    WriteLn('East cave is closest (', FloatToStr(EastDistance), ' tiles)');
  end
  else
  begin
    ClosestCave := CaveSouth;
    CaveName := 'South';
    ClosestDistance := SouthDistance;
    WriteLn('South cave is closest (', FloatToStr(SouthDistance), ' tiles)');
  end;

  // Attempt to enter the closest cave
  WriteLn('Attempting to enter ', CaveName, ' cave...');

  if ClosestCave.WalkSelectOption(['Cave']) then
  begin
    WriteLn('Successfully clicked ', CaveName, ' cave entrance');
    StartTime := GetTickCount();

    repeat
      if Chat.HasContinue() then
      begin
        // We need to CHECK the message because walker misclicks the rocks for mining
        if 'blockage' in Chat.GetChat() then
        begin
          WriteLn('Cave is blocked!');
          Self.ConsecutiveBlockedCaveAttempts := Self.ConsecutiveBlockedCaveAttempts + 1;
          WriteLn('Consecutive blocked cave attempts: ', Self.ConsecutiveBlockedCaveAttempts);
          Chat.ClickContinue();
          Wait(15000, 20000);

          // FTerminate script if we've tried 3 times in a row
          if Self.ConsecutiveBlockedCaveAttempts >= 3 then
          begin
            WriteLn('FAILSAFE TRIGGERED: 3 consecutive blocked cave attempts detected!');
            TerminateScript();
          end;

          Exit(False);
        end
        else
        begin
          WriteLn('Clicked wrong object, retrying cave');
          Chat.ClickContinue();
          if ClosestCave.WalkSelectOption(['Cave']) then
          begin
            WriteLn('Retried clicking ', CaveName, ' cave entrance');
            StartTime := GetTickCount();
          end
          else
          begin
            WriteLn('Failed to retry click ', CaveName, ' cave entrance');
            Exit(False);
          end;
        end;
      end;

      if Minimap.PercentBlack() > 80 then
      begin
        WriteLn('Entering cave...');
        // Reset our cave count for people with entity hider
        Self.ConsecutiveBlockedCaveAttempts := 0;
        Exit(True);
      end;

    until (GetTickCount() - StartTime) > 20000;

    WriteLn('Cave timed out');
    Exit(False);
  end
  else
  begin
    WriteLn('Failed to click ', CaveName, ' cave entrance');
    Exit(False);
  end;
end;

function GemStoneCrabSlayer.GetRandomRepotTime(): UInt64;
var
  BaseInterval: UInt64;
  RandomVariation: Integer;
begin
  BaseInterval := REPOTINTERVAL * 60000;

  RandomVariation := Random(-15, 15);
  Result := BaseInterval + Round(BaseInterval * (RandomVariation / 100.0));

  if Result < 60000 then
    Result := 60000;

end;

function GemStoneCrabSlayer.ShouldRepot(): Boolean;
begin
  if not USEBOOSTS then
    Exit(False);

  Result := GetTickCount() >= Self.NextRepotTime;
end;

function GemStoneCrabSlayer.TryRepot(): Boolean;
begin
  Result := False;

  if not USEBOOSTS then
    Exit;

  if not Self.ShouldRepot() then
    Exit;

  if not Self.InCombat then
    Exit;

  WriteLn('Time to boost!');

  if Self.TryConsumeAnyBoost() then
  begin
    Self.LastRepotTime := GetTickCount();
    Self.NextRepotTime := GetTickCount() + Self.GetRandomRepotTime();
    Result := True;
  end
end;

procedure TConsumableHandler.DiscoverSetup();
var
  consumable: ERSConsumable;
  foundAny: Boolean;
begin
  for consumable := Low(ERSConsumable) to High(ERSConsumable) do
  begin
    HandleConsumables[consumable] := Inventory.ContainsAny(CONSUMABLE_ARRAYS[consumable]);
    if HandleConsumables[consumable] then
    begin
      CONSUMABLE_HANDLER_ARRAY[consumable]^.Setup(consumable);
      foundAny := True;
    end;
  end;
  Self.IsSetup := foundAny;
end;

// Remove Tors wait after consuming
function TRSInventory.Consume(consumableType: ERSConsumable; out slots: TIntegerArray): Boolean; override;
var
  consumableHandler: PConsumableHandler;
  foundConsumables: TRSConsumableArray;
  startingPoints: Int32;
  //trashSlots: TIntegerArray;
  slotBox: TBox;
begin
  consumableHandler := TConsumableHandler.GetHandler(consumableType);

  case consumableType of
    ERSConsumable.FOOD:
      startingPoints := Minimap.GetHPLevel();
    ERSConsumable.PRAYER:
      startingPoints := Minimap.GetPrayerLevel();
    ERSConsumable.ENERGY:
      startingPoints := Minimap.GetRunEnergy();
  end;

  slots := Self.FindConsumable(consumableType, foundConsumables);
  if slots.Len() = 0 then
    Exit;

  if not Antiban.BioDice(EBioBehavior.CONSUME_IN_BANK) and
     RSInterface.IsOpen() then
     RSInterface.Close();

  slotBox := Self.GetSlotBox(slots[0]);
  Result := Self.ClickSlot(slots[0], ['Eat', 'Drink', 'Invigorate']);

  if Result then
  begin
    case consumableType of
      ERSConsumable.FOOD:
        Result := WaitUntil(startingPoints < Minimap.GetHPLevel(), 100, 3000);
      ERSConsumable.PRAYER:
        Result := WaitUntil(startingPoints < Minimap.GetPrayerLevel(), 100, 3000);
      ERSConsumable.ENERGY:
        Result := WaitUntil(startingPoints < Minimap.GetRunEnergy(), 100, 3000);
      else
        Result := (SRL.PercentShift(slotBox, 150) >= 25);
    end;
      // Removes dropping of vials/jugs, no need as we arent looting we can just bank
    {if Self.FindItems(TRASH_ARRAY, trashSlots) then
    begin
      if Bank.IsOpen() then
        Bank.DepositSlot([trashSlots[0], -1], False)
      else
        Self.ShiftDrop(trashSlots.Intersection(Self.RandomPattern()));
      slots := slots.Difference(trashSlots);
    end;}
  end;
end;

function GemStoneCrabSlayer.TryConsumeAnyBoost(): Boolean;
const
  BOOST_TYPES = [ERSConsumable.BOOST, ERSConsumable.STRENGTH_BOOST, ERSConsumable.ATTACK_BOOST,
                 ERSConsumable.DEFENCE_BOOST, ERSConsumable.RANGING_BOOST, ERSConsumable.MAGIC_BOOST];
var
  consumable: ERSConsumable;
  retryAttempts: Int32;
begin
  Result := False;

  if not USEBOOSTS then
    Exit;

  WriteLn('[POTIONS] Attempting to consume boost potions');

  if not Inventory.IsOpen() then
    Inventory.Open();

  for consumable in BOOST_TYPES do
  begin
    if not Inventory.ContainsAny(CONSUMABLE_ARRAYS[consumable]) then
      Continue;

    WriteLn('[POTIONS] Found ', consumable, ' - attempting consumption');

    for retryAttempts := 1 to 3 do
    begin
      if Inventory.Consume(consumable) then
      begin
        WriteLn('[POTIONS] Successfully consumed ', consumable);
        Self.IsAttacking := False;
        Self.InCombat := False;
        Result := True;
        Self.OutOfPotions := False;
        Exit;
      end;

      WriteLn('[POTIONS] Consumption failed, retry ', retryAttempts, '/3');
      Wait(500, 800);
      Inventory.Open();
      Wait(200, 400);

      if not Inventory.ContainsAny(CONSUMABLE_ARRAYS[consumable]) then
      begin
        WriteLn('[POTIONS] ', consumable, ' no longer in inventory');
        Break;
      end;
    end;
  end;

  Self.OutOfPotions := True;
  for consumable in BOOST_TYPES do
  begin
    if Inventory.ContainsAny(CONSUMABLE_ARRAYS[consumable]) then
    begin
      Self.OutOfPotions := False;
      Break;
    end;
  end;

  if Self.OutOfPotions then
    WriteLn('[POTIONS] No boost potions found in inventory')
  else
    WriteLn('[POTIONS] Boost potions available but consumption failed????');
end;

function GemStoneCrabSlayer.ShouldEatFood(): Boolean;
var
  currentHP: Int32;
begin
  if USEDHAROKS then
    Exit(False);

  if not RSClient.IsLoggedIn() then
    Exit(False);

  Result := False;

  currentHP := Minimap.GetHPLevel();

  if currentHP <= 0 then
  begin
    WriteLn('Current HP: ', currentHP);
    Exit(False);
  end;

  if currentHP <= Self.FoodHPThreshold then
  begin
    Result := True;
    Exit;
  end;
end;

function GemStoneCrabSlayer.ShouldDrinkPrayer(): Boolean;
var
  currentPrayerPercent: Int32;
  randomThreshold: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit(False);

  if not Self.HadPrayerAtStart then
    Exit(False);

  if not Self.UseQuickPrayers or Self.PrayFlickEnabled then
    Exit(False);

  Result := False;

  currentPrayerPercent := Minimap.GetPrayerPercent();

  if currentPrayerPercent <= 0 then
    Exit(False);

  if currentPrayerPercent <= 10 then
  begin
    WriteLn('[PRAYER] Prayer low: ', currentPrayerPercent, '% - force drink potions');
    Result := True;
    Exit;
  end;

  randomThreshold := Random(Self.PrayerThreshold, currentPrayerPercent);

  if currentPrayerPercent <= Self.PrayerThreshold then
  begin
    WriteLn('[PRAYER] Prayer below user threshold (', Self.PrayerThreshold, '%): ', currentPrayerPercent, '% - will drink potions until above 70%');
    Result := True;
    Exit;
  end;
end;

function GemStoneCrabSlayer.TryConsumeAnyFood(): Boolean;
var
  retryAttempts: Int32;
begin
  if USEDHAROKS then
    Exit(False);

  if Self.OutOfFood then
    Exit(False);

  Result := False;

  if not Inventory.IsOpen() then
    Inventory.Open();

  WriteLn('[FOOD] Attempting to consume food');

  for retryAttempts := 1 to 3 do
  begin
    if Inventory.Consume(ERSConsumable.FOOD) then
    begin
      WriteLn('[FOOD] Successfully consumed food');
      Result := True;
      Self.IsAttacking := False;
      Self.InCombat := False;
      Self.OutOfFood := False;
      Exit;
    end;

    WriteLn('[FOOD] Consumption failed, retry ', retryAttempts, '/3');
    Wait(500, 800);
    Inventory.Open();
    Wait(200, 400);

    if not Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.FOOD]) then
    begin
      WriteLn('[FOOD] Food no longer in inventory');
      Break;
    end;
  end;

  WriteLn('[FOOD] Food consumption failed after all retry attempts');
  Self.OutOfFood := True;
end;

function GemStoneCrabSlayer.TryConsumeAnyPrayer(): Boolean;
var
  retryAttempts: Int32;
  currentPrayerPercent: Int32;
  potionsConsumed: Int32;
begin
  if Self.OutOfPrayer then
    Exit(False);

  Result := False;
  potionsConsumed := 0;

  if not Inventory.IsOpen() then
    Inventory.Open();

  while (Minimap.GetPrayerPercent() < 70) and (Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER])) do
  begin
    currentPrayerPercent := Minimap.GetPrayerPercent();
    WriteLn('[PRAYER] Current prayer: ', currentPrayerPercent, '% - drinking potion to reach above 70%');

    for retryAttempts := 1 to 3 do
    begin
      if Inventory.Consume(ERSConsumable.PRAYER) then
      begin
        Inc(potionsConsumed);
        WriteLn('[PRAYER] Successfully consumed prayer potion #', potionsConsumed, ' (Prayer: ', Minimap.GetPrayerPercent(), '%)');
        Self.OutOfPrayer := False;
        Result := True;

        Wait(500, 800);
        Break;
      end;

      WriteLn('[PRAYER] Consumption failed, retry ', retryAttempts, '/3');
      Wait(500, 800);
      Inventory.Open();
      Wait(200, 400);

      if not Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]) then
      begin
        WriteLn('[PRAYER] Prayer potion no longer in inventory');
        Break;
      end;
    end;

    if not Result then
      Break;

  end;

  currentPrayerPercent := Minimap.GetPrayerPercent();
  if currentPrayerPercent >= 80 then
  begin
    WriteLn('[PRAYER] Successfully reached target prayer level: ', currentPrayerPercent, '% (consumed ', potionsConsumed, ' potions)');
  end
  else if not Inventory.ContainsAny(CONSUMABLE_ARRAYS[ERSConsumable.PRAYER]) then
  begin
    WriteLn('[PRAYER] Out of prayer potions - final prayer level: ', currentPrayerPercent, '%');
    Self.OutOfPrayer := True;
  end
  else
  begin
    WriteLn('[PRAYER] Prayer potion consumption failed - final prayer level: ', currentPrayerPercent, '%');
    Self.OutOfPrayer := True;
  end;
end;

function GemStoneCrabSlayer.ShouldUseSpecialAttack(): Boolean;
var
  currentSpec: Int32;
  requiredSpec: Int32;
begin
  Result := False;

  if not Self.SpecialAttackEnabled then
    Exit;

  if Self.UseDragonBattleaxe then
    Exit;

  if not Minimap.IsSpecWeapon() then
  begin
    WriteLn('[SPECIAL] Not using special attack - not a spec weapon');
    Exit;
  end;

  if not (Self.InCombat and Self.IsAttacking) then
    Exit;

  currentSpec := Minimap.GetSpecLevel();

  if Self.SpecialAttackDiscovered then
  begin
    requiredSpec := Self.SpecialAttackCost;

    if currentSpec >= Self.NextSpecialAttackThreshold then
    begin
      WriteLn('[SPECIAL] Special attack ready: ', currentSpec, '% >= ', Self.NextSpecialAttackThreshold, '% (cost: ', requiredSpec, '%)');
      Result := True;
    end;
  end
  else
  begin
    if currentSpec >= 100 then
    begin
      WriteLn('[SPECIAL] First special attack ready at 100% - will discover special attack cost during combat');
      Result := True;
    end;
  end;
end;

function GemStoneCrabSlayer.ShouldUseDragonBattleaxe(): Boolean;
var
  CurrentTime: UInt64;
  MinDelay, MaxDelay: UInt64;
begin
  Result := False;

  if not Self.UseDragonBattleaxe then
    Exit;

  if Minimap.GetSpecLevel() < 100 then
    Exit;

  if not Inventory.ContainsItem('Dragon battleaxe') then
    Exit;

  if not (Self.InCombat or Self.IsAttacking) then
    Exit;

  CurrentTime := GetTickCount();

  if Self.NextDragonBattleaxeUse = 0 then
  begin
    MinDelay := 0;
    MaxDelay := 90000;
    Self.NextDragonBattleaxeUse := CurrentTime + Random(MinDelay, MaxDelay);
    Exit(False);
  end;

  if CurrentTime >= Self.NextDragonBattleaxeUse then
  begin
    Result := True;
    Self.NextDragonBattleaxeUse := 0;
  end;
end;

function GemStoneCrabSlayer.UseSpecialAttack(): Boolean;
var
  specBefore, specAfter: Int32;
begin
  Result := False;

  WriteLn('[SPECIAL] Using special attack');

  specBefore := Minimap.GetSpecLevel();

  if Self.SpecialAttackDiscovered then
  begin
    if not Minimap.EnableSpec(Self.SpecialAttackCost) then
    begin
      WriteLn('[SPECIAL] Failed to enable special attack (required: ', Self.SpecialAttackCost, '%)');
      Exit;
    end;
  end
  else
  begin
    if not Minimap.EnableSpec(100) then
    begin
      Exit;
    end;
  end;

  Wait(700, 800);

  specAfter := Minimap.GetSpecLevel();

  if specAfter < specBefore then
  begin
    if not Self.SpecialAttackDiscovered then
    begin
      Self.SpecialAttackCost := specBefore - specAfter;
      Self.SpecialAttackDiscovered := True;
      WriteLn('[SPECIAL] Special attack cost discovered: ', Self.SpecialAttackCost, '%');
    end;

    Self.LastSpecialAttackTime := GetTickCount();

    Self.NextSpecialAttackThreshold := Random(Self.SpecialAttackCost + 1, 100);
    WriteLn('[SPECIAL] Next threshold set to: ', Self.NextSpecialAttackThreshold, '%');
    Result := True;
  end
  else
  begin
    Result := False;
  end;
end;

function GemStoneCrabSlayer.UseDragonBattleaxeSpecial(): Boolean;
var
  CurrentSpec: Int32;
  Attempts: Int32;
  ReEquipAttempts: Int32;
  FinalCheckAttempts: Int32;
begin
  Result := False;

  WriteLn('Dragon Battleaxe: Using special attack');

  if not Inventory.IsOpen() then
    Inventory.Open();

  if not Inventory.FindItem('Dragon battleaxe', Self.DragonBattleaxeSlot) then
  begin
    WriteLn('Dragon Battleaxe: Could not find Dragon battleaxe in inventory - disabling');
    Self.UseDragonBattleaxe := False;
    Exit;
  end;

  WriteLn('Dragon Battleaxe: Found Dragon battleaxe in slot ', Self.DragonBattleaxeSlot);

  if not Inventory.ClickSlot(Self.DragonBattleaxeSlot) then
  begin
    WriteLn('Dragon Battleaxe: Failed to equip Dragon battleaxe');
    Exit;
  end;

  Wait(2000, 2400); // Need a wait here because axe goes to fast sometimes

  if not WaitUntil(not Inventory.ContainsItem('Dragon battleaxe'), 65, 3000) then
  begin
    WriteLn('Dragon Battleaxe: Timeout waiting for Dragon battleaxe to be equipped');
    Exit;
  end;

  WriteLn('Dragon Battleaxe: Successfully equipped, activating special attack');

  CurrentSpec := Minimap.GetSpecLevel();

  Attempts := 0;
  while (Attempts < 3) and (Minimap.GetSpecLevel() >= 100) do
  begin
    Inc(Attempts);

    if Minimap.EnableSpec(100) then
    begin
      WriteLn('Dragon Battleaxe: Special attack activated (attempt ', Attempts, ')');
      Wait(1000, 1200);
      Break;
    end
    else
    begin
      WriteLn('Dragon Battleaxe: Failed to activate special attack (attempt ', Attempts, ')');
      Wait(1000, 1200);
    end;
  end;

  if WaitUntil(Minimap.GetSpecLevel() < CurrentSpec, 65, 3000) then
  begin
    WriteLn('Dragon Battleaxe: Special attack used!');
    Wait(800, 1200);

    if Inventory.IsSlotUsed(Self.DragonBattleaxeSlot) then
    begin
      WriteLn('Dragon Battleaxe: Re-equipping original weapon from slot ', Self.DragonBattleaxeSlot);

      ReEquipAttempts := 0;
      while (ReEquipAttempts < 5) and (not Inventory.ContainsItem('Dragon battleaxe')) do
      begin
        Inc(ReEquipAttempts);
        WriteLn('Dragon Battleaxe: Re-equip attempt ', ReEquipAttempts, ' of 5');

        if Inventory.ClickSlot(Self.DragonBattleaxeSlot) then
        begin
          if WaitUntil(Inventory.ContainsItem('Dragon battleaxe'), 65, 3000) then
          begin
            WriteLn('Dragon Battleaxe: Successfully re-equipped original weapon on attempt ', ReEquipAttempts);
            Self.LastDragonBattleaxeUse := GetTickCount();
            Result := True;
            Break;
          end
          else
          begin
            WriteLn('Dragon Battleaxe: Timeout waiting for Dragon battleaxe to return to inventory (attempt ', ReEquipAttempts, ')');
            Wait(1200, 1600);
          end;
        end
        else
        begin
          WriteLn('Dragon Battleaxe: Failed to click original weapon slot (attempt ', ReEquipAttempts, ')');
          Wait(1200, 1600);
        end;
      end;

      if not Inventory.ContainsItem('Dragon battleaxe') then
      begin
        WriteLn('Dragon Battleaxe: Warning - failed to re-equip original weapon after 5 attempts');
        Self.LastDragonBattleaxeUse := GetTickCount();
        Result := True;
      end;
    end
    else
    begin
      WriteLn('Dragon Battleaxe: Warning - original weapon slot is empty');
      Self.LastDragonBattleaxeUse := GetTickCount();
      Result := True;
    end;
  end
  else
  begin
    WriteLn('Dragon Battleaxe: Special attack may not have worked we shouldnt be here???');
    Self.LastDragonBattleaxeUse := GetTickCount();
  end;

  WriteLn('Dragon Battleaxe: Performing final check...');
  FinalCheckAttempts := 0;
  while (FinalCheckAttempts < 3) and (not Inventory.ContainsItem('Dragon battleaxe')) do
  begin
    Inc(FinalCheckAttempts);
    WriteLn('Dragon Battleaxe: Final check attempt ', FinalCheckAttempts, ' of 3 - Dragon battleaxe not found in inventory');
    Wait(1000, 1500);

    if not Inventory.IsOpen() then
      Inventory.Open();
  end;

  if not Inventory.ContainsItem('Dragon battleaxe') then
  begin
    WriteLn('Dragon Battleaxe: Dragon battleaxe is missing from inventory after special attack!');
    Logout.ClickLogout();
    TerminateScript('Dragon battleaxe missing from inventory after special attack');
  end
  else
  begin
    WriteLn('Dragon Battleaxe: Final check passed - Dragon battleaxe confirmed in inventory');
  end;

  WL.Activity.Restart();
end;

function GemStoneCrabSlayer.ShouldFlickPrayer(): Boolean;
begin
  Result := False;

  if not USEDHAROKS then
    Exit;

  if not ENABLEPRAYERFLICK then
    Exit;

  if not Self.PrayFlickEnabled then
    Exit;

  if Minimap.GetPrayerPercent() <= 0 then
  begin
    WriteLn('Prayer flicking: Disabled - no prayer points remaining');
    Exit;
  end;

  Result := Self.PrayFlickTimer.IsFinished();
end;

function GemStoneCrabSlayer.FlickPrayer(): Boolean;
begin
  Result := False;

  if not USEDHAROKS or not ENABLEPRAYERFLICK then
    Exit;

  WriteLn('Prayer flicking: Toggling Rapid Heal prayer');

  if USEQUICKPRAYERSGUI then
  begin
    if not Prayer.Open() then
    begin
      WriteLn('Prayer flicking: Failed to open prayer tab');
      Exit;
    end;

    if Prayer.ActivatePrayer(ERSPrayer.RAPID_HEAL) then
    begin
      WriteLn('Prayer flicking: Activated Rapid Heal prayer');

      if WaitUntil(Prayer.IsPrayerActive(ERSPrayer.RAPID_HEAL), 35, 2000) then
      begin
        Wait(600, 1000);
        if Prayer.DisablePrayer(ERSPrayer.RAPID_HEAL) then
        begin
          WriteLn('Prayer flicking: Deactivated Rapid Heal prayer');
          Result := True;
        end
        else
        begin
          WriteLn('Prayer flicking: Failed to deactivate Rapid Heal prayer');
        end;
      end
      else
      begin
        WriteLn('Prayer flicking: Timeout waiting for Rapid Heal prayer to activate');
      end;
    end
    else
    begin
      WriteLn('Prayer flicking: Failed to activate Rapid Heal prayer');
    end;
  end
  else
  begin
    if Minimap.IsPrayerEnabled() then
    begin
      Result := Minimap.DisablePrayer();
      WriteLn('Prayer flicking: Disabled prayer');
    end
    else
    begin
      if Minimap.EnablePrayer() then
      begin
        if WaitUntil(Minimap.IsPrayerEnabled(), 65, 2000) then
        begin
          Result := Minimap.DisablePrayer();
          Wait(800, 1000);
          WriteLn('Prayer flicking: Enabled then disabled prayer');
        end
        else
        begin
          WriteLn('Prayer flicking: Timeout waiting for prayer to enable');
          Result := True;
        end;
      end;
    end;
  end;

  if Result then
  begin
    Self.PrayFlickTimer.Restart(-20000);
    WriteLn('Prayer flicking: Timer restarted');
  end;
end;

function TRSInventory.DiscoverItem(Slot: Int32): TRSItem;
var
  DiscoveredItems: TRSItemArray;
  Item: TRSItem;
begin
  if not Self.Open() then
    Exit;

  DiscoveredItems := Self.Discover(Slot);
  if Length(DiscoveredItems) = 0 then
    Exit;

  if Length(DiscoveredItems) = 1 then
    Exit(DiscoveredItems[0]);

  for Item in DiscoveredItems do
    if Self.ContainsItem(Item) then
      Exit(Item);
end;

function TRSInventory.DiscoverAllItems(): TRSItemArray;
var
  i: Int32;
  item: TRSItem;
begin
  for i := Inventory.LOW_SLOT to Inventory.HIGH_SLOT do
  begin
    item := Inventory.DiscoverItem(i);
    if assigned(item) and (item <> '') then
      Result += item;
  end;
end;

function GemStoneCrabSlayer.SetupLoadouts: Boolean;
var
  inventoryItems: TRSItemArray;
  i: Int32;
begin
  // Setup invent (stolen from vard & TAZE)
  inventoryItems := Inventory.DiscoverAllItems();
  inventoryItems := inventoryItems.Unique();

  WriteLn('[INVENTORY] DiscoverAllItems found ', Length(inventoryItems), ' unique items');
  SetLength(Self.InventoryLoadout, Length(inventoryItems));

  for i := 0 to High(inventoryItems) do
  begin
    Self.InventoryLoadout[i].Item := inventoryItems[i];

    Self.InventoryLoadout[i].Quantity := Inventory.CountItem(inventoryItems[i]);
    Self.InventoryLoadout[i].Noted := False;

    WriteLn('[INVENTORY] Captured item: ', inventoryItems[i], ' (quantity: ', Self.InventoryLoadout[i].Quantity, ')');
  end;

  WriteLn('[INVENTORY] Successfully captured ', Length(Self.InventoryLoadout), ' items for banking');
  WriteLn('[INVENTORY] Inventory loadout contains ', Length(Self.InventoryLoadout), ' items');
  Result := True;
end;

function GemStoneCrabSlayer.GetItemsToWithdraw(): TRSBankItemArray;
var
  loadoutItem: TRSBankItem;
  currentQuantity, neededQuantity: Int32;
  isPotion: Boolean;
begin
  Result := [];

  WriteLn('[BANK] Checking which items need to be withdrawn...');

  for loadoutItem in Self.InventoryLoadout do
  begin
    if Self.FailedBankItems.Contains(loadoutItem.Item) then
    begin
      WriteLn('[BANK] Skipping "', loadoutItem.Item, '" - previously failed to withdraw from bank');
      Continue;
    end;

    currentQuantity := Inventory.CountItem(loadoutItem.Item);
    neededQuantity := loadoutItem.Quantity - currentQuantity;

    if neededQuantity > 0 then
    begin
      // Check if this is a potion
      isPotion := (Pos('prayer', LowerCase(loadoutItem.Item)) > 0) and (Pos('potion', LowerCase(loadoutItem.Item)) > 0) or
                  (Pos('potion', LowerCase(loadoutItem.Item)) > 0) or
                  (Pos('brew', LowerCase(loadoutItem.Item)) > 0) or
                  (Pos('barbarian', LowerCase(loadoutItem.Item)) > 0);

      if isPotion then
      begin
        // For prayer potions, withdraw only our snapshot amount
        if (Pos('prayer', LowerCase(loadoutItem.Item)) > 0) and (Pos('potion', LowerCase(loadoutItem.Item)) > 0) then
        begin
          WriteLn('[BANK] Need to withdraw ', neededQuantity, 'x "', loadoutItem.Item, '" prayer potions (have ', currentQuantity, ', need ', loadoutItem.Quantity, ')');
          Result += [TRSBankItem.Setup(loadoutItem.Item, neededQuantity, loadoutItem.Noted)];
        end
        // For other potions, withdraw ALL
        else
        begin
          WriteLn('[BANK] Need to withdraw ALL "', loadoutItem.Item, '" potions (have ', currentQuantity, ', withdrawing all available)');
          Result += [TRSBankItem.Setup(loadoutItem.Item, Bank.QUANTITY_ALL, loadoutItem.Noted)];
        end;
      end
      else
      begin
        WriteLn('[BANK] Need to withdraw ', neededQuantity, 'x "', loadoutItem.Item, '" (have ', currentQuantity, ', need ', loadoutItem.Quantity, ')');
        Result += [TRSBankItem.Setup(loadoutItem.Item, neededQuantity, loadoutItem.Noted)];
      end;
    end
    else
    begin
      WriteLn('[BANK] Already have enough "', loadoutItem.Item, '" (', currentQuantity, '/', loadoutItem.Quantity, ')');
    end;
  end;

  WriteLn('[BANK] Found ', Length(Result), ' items that need to be withdrawn');
end;

function TBaseBankScript.Withdraw(items: TRSBankItemArray): Boolean; overload;
var
  item: TRSBankItem;
begin
  for item in items do
    Result := Self.Withdraw(item);
end;

function GemStoneCrabSlayer.HandleBankItems: Boolean;
var
  itemsToWithdraw: TRSBankItemArray;
  item: TRSBankItem;
  i: Int32;
  withdrawalSuccess: Boolean;
  retryAttempt: Int32;
  maxRetries: Int32;
begin
  if not Bank.IsOpen() then
    Exit(False);

  itemsToWithdraw := Self.GetItemsToWithdraw();

  if Length(itemsToWithdraw) = 0 then
  begin
    if Length(Self.FailedBankItems) >= Length(Self.InventoryLoadout) then
    begin
      WriteLn('[BANK] All items have been flagged as failed - disabling banking');
      Self.BankingDisabled := True;
      USEBOOSTS := False;
      Result := False;
    end
    else
    begin
      WriteLn('[BANK] No items need to be withdrawn - inventory is complete');
      Result := True;
    end;
  end
  else
  begin
    WriteLn('[BANK] Withdrawing ', Length(itemsToWithdraw), ' missing items...');

    withdrawalSuccess := True;
    maxRetries := 3;
    
    for i := 0 to High(itemsToWithdraw) do
    begin
      item := itemsToWithdraw[i];
      WriteLn('[BANK] Attempting to withdraw ', item.Quantity, 'x "', item.Item, '"');

      retryAttempt := 0;
      while retryAttempt < 2 do
      begin
        if Bank.WithdrawItem(item, True) then
        begin
          if not WaitUntil(Inventory.ContainsItem(item.Item), 65, 4000) then
          begin
            WriteLn('[BANK] WARNING: Item "', item.Item, '" did not appear in inventory after withdrawal (Attempt ', retryAttempt + 1, '/2)');
            Inc(retryAttempt);
            if retryAttempt < 2 then
            begin
              WriteLn('[BANK] Retrying withdrawal of "', item.Item, '"...');
              Wait(RandomRange(500, 1000));
            end;
          end
          else
          begin
            WriteLn('[BANK] Successfully withdrew "', item.Item, '"');
            Break;
          end;
        end
        else
        begin
          WriteLn('[BANK] Failed to withdraw "', item.Item, '" (Attempt ', retryAttempt + 1, '/2)');
          Inc(retryAttempt);
          if retryAttempt < 2 then
          begin
            WriteLn('[BANK] Retrying withdrawal of "', item.Item, '"...');
            Wait(RandomRange(500, 1000));
          end;
        end;
      end;
      
      if retryAttempt >= 2 then
      begin
        WriteLn('[BANK] Moving on after 2 failed attempts to withdraw "', item.Item, '"');
        Self.FailedBankItems += [item.Item];
        withdrawalSuccess := False;
      end;
    end;

    Result := withdrawalSuccess;

    if not withdrawalSuccess then
    begin
      WriteLn('[BANK] Withdrawal failed - disabling banking for future attempts');
      Self.BankingDisabled := True;
    end;
  end;

  if Result then
    Bank.Close();
end;

procedure GemStoneCrabSlayer.HandleBanking();
var
  attempts: Int32;
  maxAttempts: Int32;
  bankingSuccess: Boolean;
  fallbackAttempts: Int32;
  usedFallback: Boolean;
begin
  if Self.UseQuickPrayers and Minimap.IsPrayerEnabled() then
  begin
    WriteLn('[PRAYER] Disabling quick prayers during banking');
    Minimap.DisablePrayer();
  end;

  maxAttempts := 5;
  attempts := 0;
  fallbackAttempts := 0;
  usedFallback := False;

  while attempts < maxAttempts do
  begin
    Inc(attempts);

    if not Bank.IsOpen() then
    begin
      // Sometimes we got poll by accident, so lets check
      if RSInterface.IsOpen() then
      begin
        WriteLn('[BANK] Non-bank interface detected - closing it before opening bank');
        RSInterface.Close(True);
        Wait(800, 1200);
      end;

      if not Banks.WalkOpen() then
      begin
        WriteLn('[BANK] Failed to open bank (attempt ', attempts, '/', maxAttempts, ')');

        if (attempts = 3) and (not usedFallback) then
        begin
          WriteLn('[BANK] 3 attempts failed - using WalkBlind to get closer to bank');
          Map.Walker.WalkBlind(Point(876, 3794), 4);
          usedFallback := True;

          attempts := 0;
          maxAttempts := 5;
          Continue;
        end
        else if attempts >= maxAttempts then
        begin
          if usedFallback then
            WriteLn('[BANK] Failed to open bank after 5 additional attempts from closer position - disabling banking')
          else
            WriteLn('[BANK] Failed to open bank after ', maxAttempts, ' attempts - disabling banking');
          Self.BankingDisabled := True;
          Exit;
        end;
        Continue;
      end;

      if not WaitUntil(Bank.IsOpen(), 35, 9000) then
      begin
        WriteLn('[BANK] Bank did not open after Banks.WalkOpen (attempt ', attempts, '/', maxAttempts, ')');

        if (attempts = 3) and (not usedFallback) then
        begin
          WriteLn('[BANK] 3 attempts failed - using WalkBlind to get closer to bank');
          Map.Walker.WalkBlind(Point(876, 3794), 4);
          usedFallback := True;

          attempts := 0;
          maxAttempts := 5;
          Continue;
        end
        else if attempts >= maxAttempts then
        begin
          if usedFallback then
            WriteLn('[BANK] Failed to open bank after 5 additional attempts from closer position - disabling banking')
          else
            WriteLn('[BANK] Failed to open bank after ', maxAttempts, ' attempts - disabling banking');
          Self.BankingDisabled := True;
          Exit;
        end;
        Continue;
      end;
    end;

    Break;
  end;

  Self.DepositVials();

  bankingSuccess := Self.HandleBankItems;

  if bankingSuccess then
  begin
    Bank.Close();
    Self.HasSupplies := True;
    Self.OutOfPotions := False;
    Self.OutOfFood := False;
    Self.InCombat := False;
    Self.IsAttacking := False;
    WriteLn('[BANK] Successfully handled banking');
  end
  else
  begin
    Bank.Close();
    Self.InCombat := False;
    Self.IsAttacking := False;
    WriteLn('[BANK] Failed to withdraw correct supplies');
  end;
end;

procedure GemStoneCrabSlayer.DepositVials();
var
  vialsDeposited: Int32;
  totalVials: Int32;
  vialItem: TRSBankItem;
begin
  if not Bank.IsOpen() then
  begin
    WriteLn('[VIALS] Bank not open - cannot deposit vials');
    Exit;
  end;

  if Inventory.ContainsItem('Vial') then
  begin
    totalVials := Inventory.CountItem('Vial');
    WriteLn('[VIALS] Found ', totalVials, ' empty vials in inventory - depositing them at bank');

    vialItem.Item := 'Vial';
    vialItem.Quantity := Bank.QUANTITY_ALL;

    if Bank.DepositItem(vialItem, True) then
    begin
      vialsDeposited := totalVials;
      WriteLn('[VIALS] Successfully deposited all ', vialsDeposited, ' empty vials at bank!');
    end
    else
    begin
      WriteLn('[VIALS] Failed to deposit vials with bulk deposit - attempting individual deposits');

      vialsDeposited := 0;
      while Inventory.ContainsItem('Vial') do
      begin
        vialItem.Quantity := 1;
        if Bank.DepositItem(vialItem, True) then
        begin
          Inc(vialsDeposited);
          Wait(600, 800);
        end;
      end;

      if Inventory.ContainsItem('Vial') then
      begin
        WriteLn('[VIALS] WARNING: Some vials may not have been deposited, attempting again...');
        while Inventory.ContainsItem('Vial') do
        begin
          vialItem.Quantity := 1;
          if Bank.DepositItem(vialItem, True) then
          begin
            Inc(vialsDeposited);
            Wait(600, 800);
          end
          else
          begin
            WriteLn('[VIALS] ERROR: Failed to deposit remaining vials on second attempt');
            Break;
          end;
        end;
      end;

      if not Inventory.ContainsItem('Vial') then
        WriteLn('[VIALS] Successfully deposited all ', vialsDeposited, ' empty vials at bank!')
      else
        WriteLn('[VIALS] ERROR: Failed to deposit all vials after second attempt');
    end;
  end
  else
  begin
    WriteLn('[VIALS] No empty vials found in inventory - proceeding with banking');
  end;
end;

procedure GemStoneCrabSlayer.WalkToCrabSpawn();
var
  CurrentPos: TPoint;
  Closest: record Location: String; SpawnPoint: TPoint; Distance: Double; end;
  TargetPosition: TPoint;
  DirectionVector: TPoint;
  RandomDistance: Int32;
begin
  WriteLn('Walking closer to crab boss spawn...');

  CurrentPos := Map.Position;
  WriteLn('Current position: ', CurrentPos.X, ', ', CurrentPos.Y);

  Closest := Self.GetClosestCrabInfo();

  DirectionVector.X := Closest.SpawnPoint.X - CurrentPos.X;
  DirectionVector.Y := Closest.SpawnPoint.Y - CurrentPos.Y;

  if Closest.Distance > 0 then
  begin
    DirectionVector.X := Round(DirectionVector.X / Closest.Distance);
    DirectionVector.Y := Round(DirectionVector.Y / Closest.Distance);
  end;

  RandomDistance := Random(5, 8);
  TargetPosition.X := Closest.SpawnPoint.X - (DirectionVector.X * RandomDistance);
  TargetPosition.Y := Closest.SpawnPoint.Y - (DirectionVector.Y * RandomDistance);

  TargetPosition.X := TargetPosition.X + Random(-3, 3);
  TargetPosition.Y := TargetPosition.Y + Random(-3, 3);

  WriteLn('Walking to ', Closest.Location, ' spawn area, at position: ', TargetPosition.X, ', ', TargetPosition.Y);

  if Map.Walker.WebWalk(TargetPosition, 30, 0.2) then
  begin
    WriteLn('Successfully walked closer to ', Closest.Location, ' spawn area');
  end
  else
  begin
    WriteLn('Failed to walk closer to ', Closest.Location, ' spawn area - continuing anyway');
  end;
end;

var
  WarningStartTime: Int64;
  WarningContinueButton: TButton;

procedure CloseForm(Sender: TObject);
begin
  if not DirectoryExists('Configs') then
    CreateDirectory('Configs');

  WriteINI('Warnings', 'GemStoneCrabSlayer_RuneliteWarningShown', 'true', 'Configs/BASettings.ini');

  TForm(TButton(Sender).GetParent()).Close;
end;

procedure ExitScript(Sender: TObject);
begin
  TForm(TButton(Sender).GetParent()).Close;
  TerminateScript('User stopped script due to Runelite plugin requirements not being met.');
end;

procedure UpdateCountdown({$H-}sender: TObject);{$H+}
var
  TimeRemaining: Int32;
begin
  TimeRemaining := 10 - Trunc((GetSystemTime() - WarningStartTime)/1000);

  if TimeRemaining <= 0 then
  begin
    WarningContinueButton.SetCaption('Accept');
    WarningContinueButton.SetEnabled(True);
    TTimer(Sender).SetEnabled(False);
  end else
    WarningContinueButton.SetCaption('Accept (' + ToStr(TimeRemaining) + ' seconds)');
end;

procedure CheckRuneliteWarnings();
var
  warningForm: TForm;
  detProbMsg: TLabel;
  pluginWarningMsg, settingSearcherMsg, warningMsg: TMemo;
  nextTop: Integer;
  continueButton, exitButton: TButton;
  countdownTimer: TTimer;
  oneTimeMsg: TLabel;
begin
  try
    if not DirectoryExists('Configs') then
      CreateDirectory('Configs');

    if FileExists('Configs/BASettings.ini') and (ReadINI('Warnings', 'GemStoneCrabSlayer_RuneliteWarningShown', 'Configs/BASettings.ini') = 'true') then
      Exit;

    with warningForm do
    begin
      Init(nil);
      SetCaption('!!! RUNELITE WARNING !!!');
      SetBounds(0,0,TControl.AdjustToDPI(700),TControl.AdjustToDPI(540));
      SetPosition(poScreenCenter);
      GetFont.SetStyle([fsBold]);
      GetFont.SetColor($8B0000); // Dark red
    end;

    with detProbMsg do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetLeft(TControl.AdjustToDPI(5));
      SetTop(TControl.AdjustToDPI(0));
      GetFont().SetSize(18);
      SetCaption('IMPORTANT: Runelite Plugin Requirements');
      GetFont().SetStyle([fsBold]);
      GetFont().SetColor($2F4F4F); // Dark gray
    end;

    nextTop := detProbMsg.GetTop + detProbMsg.GetHeight + TControl.AdjustToDPI(25);

    with pluginWarningMsg do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetBounds(TControl.AdjustToDPI(5), nextTop, warningForm.GetWidth - TControl.AdjustToDPI(10), TControl.AdjustToDPI(180));
      GetFont().SetSize(13);
      GetFont().SetStyle([fsBold]);
      GetFont().SetColor($8B0000); // Dark red
      SetCaption('PLUGINS MUST BE DISABLED: This script only works with Runelite when ALL plugins are disabled, ' +
                 'or when using the "Wasp" profile plugin. Most Runelite plugins will interfere with the script ' +
                 'and cause it to fail. Please ensure you have either:' + LineEnding + LineEnding +
                 '1. Disabled ALL Runelite plugins, OR' + LineEnding +
                 '2. Are using the "Wasp" profile plugin (recommended)');
      SetReadOnly(True);
      nextTop := nextTop + pluginWarningMsg.GetHeight + TControl.AdjustToDPI(10);
    end;

    with settingSearcherMsg do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetBounds(TControl.AdjustToDPI(5), nextTop, warningForm.GetWidth - TControl.AdjustToDPI(10), TControl.AdjustToDPI(100));
      GetFont().SetSize(13);
      GetFont().SetStyle([fsBold]);
      GetFont().SetColor($0066CC);
      SetCaption('SETTING SEARCHER REQUIRED: You must have run the "Setting Searcher" script from the Wasp Launcher ' +
                 'at least once before running this script. This ensures your settings are correct and ' +
                 'prevents script failures. If you haven''t done this, please stop now and run Setting Searcher first.');
      SetReadOnly(True);
      nextTop := nextTop + settingSearcherMsg.GetHeight + TControl.AdjustToDPI(10);
    end;

    with warningMsg do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetBounds(TControl.AdjustToDPI(5), nextTop, warningForm.GetWidth - TControl.AdjustToDPI(10), TControl.AdjustToDPI(80));
      GetFont().SetSize(13);
      GetFont().SetStyle([fsBold]);
      GetFont().SetColor($556B2F);
      SetCaption('By continuing with this script, you acknowledge that these requirements must be met ' +
                 'or the script will fail. When asking for help, post a screenshot with Simba & Runescape Client FULLY visible.');
      SetReadOnly(True);
      nextTop := nextTop + warningMsg.GetHeight + TControl.AdjustToDPI(15);
    end;



    with continueButton do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetName('continueButton');
      SetBounds(TControl.AdjustToDPI(5), nextTop, TControl.AdjustToDPI(294), TControl.AdjustToDPI(62));
      GetFont.SetSize(18);
      GetFont.SetStyle([fsBold]);
      GetFont.SetColor($FFFFFF);
      SetCaption('Accept (10 seconds)');
      SetEnabled(False);
      SetOnClick(@CloseForm);
    end;

    WarningContinueButton := continueButton;

    with exitButton do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetBounds(warningForm.GetWidth - TControl.AdjustToDPI(299), nextTop, TControl.AdjustToDPI(294), TControl.AdjustToDPI(62));
      GetFont.SetSize(18);
      GetFont.SetStyle([fsBold]);
      GetFont.SetColor($FFFFFF);
      SetCaption('Stop Script');
      SetOnClick(@ExitScript);
    end;

    nextTop := nextTop + exitButton.GetHeight + TControl.AdjustToDPI(15);

    with oneTimeMsg do
    begin
      Init(warningForm);
      SetParent(warningForm);
      SetLeft(TControl.AdjustToDPI(200));
      SetTop(nextTop);
      GetFont().SetSize(11);
      GetFont().SetStyle([fsItalic]);
      SetCaption('This warning will only be shown once');
      SetColor($696969);
    end;

    WarningStartTime := GetSystemTime();

    with countdownTimer do
    begin
      Init(warningForm);
      SetOnTimer(@UpdateCountdown);
      SetInterval(1000);
      SetEnabled(True);
    end;

    warningForm.ShowModal;
  except
    WriteLn('Warning: Failed to show Runelite warning popup. Continuing anyway...');
  end;
end;

begin
  Sync(@CheckRuneliteWarnings); 

  {$IFDEF SCRIPT_GUI}
  Sync(@Config.Run);
  {$ENDIF}

  GemStoneCrabBot.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.
