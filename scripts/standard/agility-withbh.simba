{$DEFINE SCRIPT_ID := 'eedfc292-6c08-40a3-a5ec-c8d9d25df87c'}
{$DEFINE SCRIPT_REVISION := '14'}
program agility;
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
{$I WaspLib/optional/handlers/discord.simba}
{$IFNDEF ANDREW_MUSHTREE_INCLUDED}
  {$I WaspLib/optional/interfaces/mainscreen/mushtree.simba}
{$ENDIF}
{$IFNDEF SKUNK_UNIVERSAL_TRANSPORT}
  {$I WaspLib/optional/handlers/teleports/transport.simba}
{$ENDIF}

(*
  File contains handling farm runs and birdhouse runs
  Original Birdhouse Runner by CanadianJames
  Original Farming Run include by XJ and Student
  Modified by n0ll
*)

type
  ECourse = (DRAYNOR_ROOF, VARROCK_ROOF, FALADOR_ROOF, SEERS_ROOF, ARDOUGNE_ROOF);

  TAgilityGUI = record
    Form: TScriptForm;
    BirdhouseCheckbox, SleepCheckbox, FarmRunNowCheckbox,
    BlockInputCheckbox, FarmCheckbox, HourlyReportCheckbox,
    SessionSummaryCheckbox, PlannedBreaksCheckbox: TLabeledCheckBox;
    BreakForInput, BreakAfterInput, BankTabInput, WebhookInput: TLabeledEdit;
    FoodInput, CourseInput, HerbSeedCombo, FlowerSeedCombo: TLabeledCombobox;
    MagicSecateursCheckbox, CatherbyHerbCheckbox, HosidiusHerbCheckbox,
    CatherbyFlowerCheckbox, HosidiusFlowerCheckbox, CompostFlowersCheckbox,
    BarbarianDibberCheckbox,
    RunePouchCheckbox: TLabeledCheckBox;
    ScriptInfo, ScriptTitle, AntibanNote: TLabel;
    CompostInput: TLabeledCombobox;
  end;

  TAgilityStatusHud = record
    Enabled: Boolean;
    FontSize: Int32;
    BackgroundColor, BorderColor, TextColor: TColor;
    Position: TPoint;
    Padding, Width: Int32;
    Runtime: TStopWatch;
  end;

procedure AgilityStatusHud_Init(var Display: TAgilityStatusHud);
procedure AgilityStatusHud_Update(var Display: TAgilityStatusHud);
procedure AgilityStatusHud_Clear();

procedure AgilityGUI_LoadSettings();
function AgilityGUI_GetActiveUsername(): String;
procedure AgilityGUI_SaveSettingsToIni();
procedure AgilityGUI_FormCloseHandler(Sender: TObject; var CloseAction: TCloseAction);
procedure AgilityGUI_OnBirdhouseRunCheckboxChanged(Sender: TObject);
procedure AgilityGUI_OnFarmRunCheckboxChanged(Sender: TObject);
function AgilityGUI_CreateFarmRunSettings(): TTabSheet;
procedure AgilityGUI_Run();
procedure AgilityGUI_StartScript(Sender: TObject);

  TObstacle = record
    Tile, WalkTile: TPoint;
    UpText: TStringArray;
    Area: TBox;
    Height, Wait: Int32;
  end;

  EFarmPatch = (WEISS_HERB, STRONGHOLD_HERB, CATHERBY_HERB, CATHERBY_FLOWER, CATHERBY_ALLOT_N,
                CATHERBY_ALLOT_S, ARDY_HERB, ARDY_FLOWER, HOSIDIOUS_HERB, HOSIDIOUS_FLOWER,
                FALLY_HERB, FALLY_FLOWER, PHASMATYS_HERB, GUILD_HERB, GUILD_FLOWER,
                GUILD_ALLOT_N, GUILD_ALLOT_S, GUILD_BUSH, GUILD_CACTUS, MONESTARY_BUSH,
                GIANT_SEAWEED_NORTH, GIANT_SEAWEED_SOUTH);

  ETravelMethod = (ICY_BASALT, STONY_BASALT, CATHERBY_TABLET, CATHERBY_TELEPORT, CAMELOT_TELEPORT,
                   CAMELOT_TABLET, ARDY_CLOAK_2, ARDY_CLOAK_3, ARDY_CLOAK_4, ARDY_CLOAK_1_BUSH,
                   ARDY_CLOAK_2_BUSH, ARDY_CLOAK_3_BUSH, ARDY_CLOAK_4_BUSH, XERICS_TALISMAN,
                   HOSIDIOUS_TABLET, HOUSE_TELEPORT, CON_CAPE_HOSIDIUS, EXPLORERS_RING_2,
                   EXPLORERS_RING_3, EXPLORERS_RING_4, FENKENSTRAIN_TELEPORT, ECTOPHIAL,
                   FARMING_CAPE, SKILLS_NECKLACE, NONE, DIGSITE_TO_SEAWEED,
                   CON_CAPE_SPIRIT_TREE_GUILD, HOUSE_TAB_SPIRIT_TREE_GUILD, HOUSE_TELE_SPIRIT_TREE_GUILD);

  ECompostMethod = (REGULAR, SUPER, ULTRA, BOTTOMLESS, FERTILE_SOIL);
  EPatchType = (HERB, FLOWER, BUSH, ALLOTMENT, CACTUS, SEAWEED);

  EPatchState = (TELEPORT_TO, DEAD, DISEASED, HARVEST, PLANT, COMPOST, NOTE_ITEMS,
                 FAILED, COMPLETE, SKIP, HARVEST_WHITEBERRIES, HARVEST_CACTUS, HARVEST_SEAWEED);

  TPatchData = record
    BorderColor, SoilColor, LeprechaunColor: TCTS2Color;
    Coords, LeprechaunCoords: TPoint;
    PatchType: EPatchType;
    MapCoords: TBox;
    Name: String;
  end;

  TFarmPatch = record
    EmptyUpText, PlantedUpText, HarvestUpText: String;
    TravelMethod: ETravelMethod;
    Data: TPatchData;
    TPA: TPointArray;
    SearchBox: TBox;
    Seed: TRSItem;
    Complete, Skip: Boolean;
  end;

  TFarmRun = record
    PatchesCompleted, PatchesSkipped, MaxRuns, RunsComplete, XPGained, LastXPRead: Int32;
    ResurrectCrop, DoReport, DoBreak, CleanHerbs: Boolean;
    BoatyShore, BoatyIsland, BargeAttendant: TRSObject;
    InactivityTimer, ReadyTimer: TCountdown;
    HarvestQuantities: TIntegerArray;
    LeprechaunItems: TRSItemArray;
    CompostMethod: ECompostMethod;
    CompostFlowers: Boolean;
    Patches: array of TFarmPatch;
    CurrentPatch: TFarmPatch;
    Runtime: TStopWatch;
  end;

  ERSLogType = (REGULAR_LOGS, OAK_LOGS, WILLOW_LOGS, TEAK_LOGS, MAPLE_LOGS, MAHOGANY_LOGS, YEW_LOGS, MAGIC_LOGS, REDWOOD_LOGS);
  EScriptState = (DO_NOTHING, TELEPORTING, NAVIGATING, CLICK_MUSHROOM, USE_MUSHROOM, BUILD_BIRDHOUSE, INTERACT_BIRDHOUSES );
  EScriptAfterState = (NOTHING, WALK_BANK, WITHDRAW_NEXT_RUN, TAKING_BOAT, WALK_MUSHROOM, TELEPORT_MUSHROOM, FINISHED );
  ERSMushroomLocation = (VERD_VALLEY, HILL_HOUSE, SHROOM_MEADOW); //Names have been changed to protect the globals of the same name

  TBirdhouse = record
    BirdhouseObject : TRSObject;
    IsFilled : Boolean;
  end;

  TMushroom = record
    Mushroom : TRSObject;
    location : ERSMushroomLocation;
  end;

  CurrBirdhouse = ^TBirdhouse;

  TBirdHouseInclude = record
    LogType, SuggestedLogType : ERSLogType;
    Seed : TRSItem;
    BirdHousesFilled : Int8;
    //VerdValleySouthBirdHouse, VerdValleyNorthBirdHouse, MushMeadowBirdhouse, TarBirdHouse : TBirdhouse;

    TaskInterval : Uint32;

    CurrentBirdHouse : CurrBirdhouse;
    HasRunStarted, HasRunFinished,
    ShouldTeleport,
    AlwaysUseBestLog, IsDisabled, NeedClockworks, TerminateOnNoLogs, Initialized : Boolean;

    RSW : TRSWalker;
    ScriptIntervalTimer, NextRunSpewTimer : TCountdown;
    VerdValleyShroom, MushMeadowShroom, HouseHillShroom : TRSObject;
    MushIndex : Int8;
    RunsCompleted : Int32;
    NestsLooted : Int32;
    RunStartXp, TotalXPEarned : UInt64;
    Mushrooms : array of TMushroom;
    birdHouses : array of TBirdhouse;
    State : EScriptState;
    EndScriptState : EScriptAfterState;
  end;

const
  GRIMY_HERBS: TRSItemArray := ['Grimy guam leaf', 'Grimy marrentill', 'Grimy tarromin', 'Grimy harralander',
                                'Grimy ranarr weed', 'Grimy toadflax', 'Grimy irit leaf', 'Grimy avantoe',
                                'Grimy kwuarm', 'Grimy snapdragon', 'Grimy cadantine', 'Grimy lantadyme',
                                'Grimy dwarf weed', 'Grimy torstol'];

  AGILITY_INI_FILE = 'Configs/AgilityWithBH.ini';

  // Lightweight anti-ban profile tuning
  AB_REACT_MIN = 90;       // ms
  AB_REACT_MAX = 420;      // ms
  AB_ROTATE_CHANCE     = 15; // %
  AB_RIGHTCLICK_CHANCE = 8;  // %
  AB_KEYBOARD_CHANCE   = 8;  // %
  AB_LOSEFOCUS_CHANCE  = 14; // %

  // No-progress watchdog configuration
  NP_MINUTES_NO_PROGRESS = 6;     // reset if no progress in X minutes
  NP_SHORT_BREAK_MIN  = 15000;    // ms
  NP_SHORT_BREAK_MAX  = 45000;    // ms
  NP_LOG_EVERY        = 60000;    // ms throttle for console spam

  // BigAussie-style break defaults
  MINI_BREAK_CHANCE_PCT_DEFAULT = 40;        // % chance when window fires
  MINI_GAP_MIN_MS_DEFAULT       = 25 * ONE_MINUTE;
  MINI_GAP_MAX_MS_DEFAULT       = 55 * ONE_MINUTE;
  MINI_LEN_MIN_MS_DEFAULT       = 30000;     // 30s
  MINI_LEN_MAX_MS_DEFAULT       = 120000;    // 120s

  PLANNED_CADENCE_JITTER_PCT_DEFAULT = 10;   // ±10% cadence jitter
  PLANNED_LENGTH_JITTER_PCT_DEFAULT  = 20;   // ±20% duration jitter
  PLANNED_BREAK_RESUME_FUZZ_MS       = 5000; // add a small buffer when resuming timers

var
  Marks, WaitRand, Step, WaitTime, FarmRuns, BirdhouseRuns, BreakFor, BreakAfter, StartXP, CurrentXP, GainedXP, fc, gfc,
  LapsCompleted: Int32;
  BankTab: Int32 := 0;
  DoBirdhouseRuns, TakeSleeps, DoFarmRuns, UseRunePouch, HosidiusHerb, HosidiusFlower,
  FarmRunNow, UseMagicSecateurs, BarbarianDibber, CatherbyHerb, CatherbyFlower,
  CompostFlowers: Boolean;
  PlannedBreaksEnabled: Boolean := True;
  EnableStatusHud: Boolean := True;
  RealInputBlocked: Boolean := False;
  BlockInput: Boolean := True;
  SendHourlyReports: Boolean := True;
  SendSessionSummaryReports: Boolean := True;
  WebhookEnabled, SessionSummarySent: Boolean;
  ScriptCleanedUp: Boolean := False;
  InactivityTimer, ReportTimer, InfoTimer, HourlyReportTimer, RuntimeTimer: TStopwatch;
  ReturnItemAmounts, FarmItemAmounts: TIntegerArray;
  ReturnItems, FarmItems: TRSItemArray;
  Obstacles: Array of TObstacle;
  CompostMethod: ECompostMethod := ULTRA;
  AgilityRSW: TRSWalker;
  ReturnSpell: ERSSpell;
  BankBooth: TRSObject;
  Food, Seed, FlowerSeed: TRSItem;
  GUI: TAgilityGUI;
  Course: ECourse := DRAYNOR_ROOF;
  Farm: TFarmRun;
  AgilityHud: TAgilityStatusHud;
  Discord: TDiscordClient;
  WebhookURL: String := '';

  SavedHerbSeedName: String := 'Ranarr seed';
  SavedFlowerSeedName: String := 'Limpwurt seed';

  BirdHouseRunner : TBirdHouseInclude;
  BHWriteDebug : Boolean := true;
  BHIncludeGUILogType : ERSLogType := ERSLogType.MAPLE_LOGS;
  BHIncludeGUISeed : TRSItem := 'Barley seed';
  BHIncludeGUIRunIntervalMinutes : Int32 := 51;
  PatchData: array of TPatchData;

  NP_LastProgressTime, NP_LastLog: UInt64;
  ABNextCamJitterAt, ABNextBreakletAt: UInt64;
  NextMiniBreakAt, NextPlannedBreakAt: UInt64;
  MiniGapMinMs, MiniGapMaxMs, MiniLenMinMs, MiniLenMaxMs: UInt64;
  MiniBreakRemainingMs, PlannedBreakRemainingMs: UInt64;
  SystemUpdateCheckTimer: TCountdown;
  SystemUpdateWarningShown: Boolean;
  SystemUpdateHudMessage: String;
  PendingSystemUpdateLogout: Boolean;
  SystemUpdateThresholdMinutes: Int32;
  SystemUpdateLogoutDelayedLogged: Boolean;
  FarmRunActive, BirdhouseRunActive: Boolean;
  MiniBreakPaused, PlannedBreakPaused, LastBreakInProgress: Boolean;
  ABMouseSpeed, ABMouseGravity, ABMouseWind, ABMouseMiss: Int32;
  MiniBreakChancePct, PlannedCadenceJitterPct, PlannedLengthJitterPct: Int32;
  LastBreakEventSummary: String;
  LastBreakEventAt: UInt64;

procedure ReleaseRealInput(); forward;
procedure CleanupScript(); forward;
procedure CheckSystemUpdate(); forward;

function TMushroom.GetMushButton() : ERSMushTreeButton;
begin
  case Self.location of
    ERSMushroomLocation.HILL_HOUSE : Result := ERSMushTreeBUtton.VERDANT_VALLEY;
    ERSMushroomLocation.VERD_VALLEY : Result := ERSMushTreeBUtton.MUSHROOM_MEADOW;
    ERSMushroomLocation.SHROOM_MEADOW : Result := ERSMushTreeBUtton.HOUSE_ON_THE_HILL;
  end;
end;

function TRSMushTree.Click(mushroom : ERSMushTreeButton) : Boolean;
begin
  Result := Self.GetButton(mushroom).Click();
end;

function TBirdHouseInclude.GetNewRunInterval() : Uint64;
begin
  Result := Round(Random(Self.TaskInterval * 1.043598435, Self.TaskInterval * 1.35))
end;

procedure TBirdHouseInclude.DebugLn(message : string);
begin
  if not BHWriteDebug then
    Exit;

  WriteLn(SRL.TimeStamp() + ':[' + 'BirdhouseRunner' + ']: ' + message);
end;

function TBirdHouseInclude.GetBirdHouseSpace() : TPointArray;
const
  SPACE_COLOR : TCTS2Color := CTS2(9029, 1, 0.01, 0.01); //CTS2(1192279, 8, 0.17, 4.86);
var
  ATPA : T2DPointArray;
  msC : TPoint := Mainscreen.Center;
begin
  SRL.FindColors(Result, SPACE_COLOR, Mainscreen.Bounds);
  Result := Result.Grow(3);
  ATPA := Result.Cluster(10);
  ATPA := ATPA.SortFrom(msC);

  if ATPA.Len() < 1 then
    Result := []
  else
    Result := ATPA[0];
end;

function TBirdHouseInclude.GetLogString(log : ERSLogType) : string;
begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := "Logs";
    else
      Result := ToStr(Log).Before("_") + " logs";
  end;
end;

function TBirdHouseInclude.GetBirdhouseItem(log : ERSLogType) : TRSItem;
var
  baseBirdHouse : TRSItem := "Bird house";

begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := baseBirdHouse;
    else
      Result := ToStr(Log).Before("_") + " " + baseBirdHouse;
  end;
end;

function TBirdHouseInclude.GetWithdrawList() : TRSBankItemArray;
begin
  Result += TRSBankItem.Setup("Chisel", 1, false);
  Result += TRSBankItem.Setup("Hammer", 1, false);
  Result += TRSBankItem.Setup(Self.GetLogString(Self.LogType), 4, false);

  if Self.NeedClockworks then
    Result += TRSBankItem.Setup("Clockwork", 1, false);

  Result += TRSBankItem.Setup(Self.Seed, 40, false);
end;

function TRSBank.FindAll(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if not Self.FindItem(tempItem, tempBox) then
      Exit(false);
  end;

  Result := true;
end;

function TRSBankItemArray.ToItemArray() : TRSItemArray; constref;
var
  i : Int32;

begin
  for i := 0 to High(Self) do
  begin
    Result += Self[i].Item;
  end;
end;

function TBirdHouseInclude.HasTools() : Boolean;
var
  tools : TRSItemArray;
  i : Int32;
begin

  if (Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)))
  or (not Self.NeedClockworks and Inventory.ContainsItem(Self.GetLogString(Self.LogType))) then
    Exit(true);

  //Can't count seeds while the slot is selected.
  if Inventory.GetSelectedSlot() <> -1 then
    Exit(true);

  tools := ['Chisel', 'Hammer'];

  if (not Inventory.ContainsItem(Self.GetLogString(Self.LogType))
  or not Inventory.ContainsItem('Clockwork')) then
  begin
    Self.DebugLn("Missing birdhouse, log, or clockwork");
    Exit(false);
  end;

  for i := 0 to High(tools) do
  begin
    if not Inventory.ContainsItem(tools[i]) then
    begin
      Self.DebugLn("Missing item: " + ToStr(tools[i]));
      Exit(false);
    end;
  end;

  i := Inventory.CountItemStack(Self.Seed);
  Result :=  i >= 5;
  if not Result then
    Self.DebugLn("Seed count: " + ToStr(i));

end;

procedure TBirdHouseInclude.SetupBirdHouses();
var
  VVBHN, VVBHS, MMBHN, TARBH : TRSObject;
  commonFinder : TRSObjectFinder;

begin

  SetLength(Self.birdHouses, 4);

  //Regular
  commonFinder.ColorClusters += [CTS2(1789275, 5, 0.10, 0.69), CTS2(6201021, 8, 0.03, 1.40), 20];
  //Oak
  commonFinder.ColorClusters += [CTS2(5074823, 15, 0.05, 0.33), CTS2(8561589, 7, 0.04, 1.08), 20];
  //Willow
  commonFinder.ColorClusters += [CTS2(2314071, 7, 0.06, 0.42), CTS2(3366502, 7, 0.06, 1.61), 20];
  //Teak
  commonFinder.ColorClusters += [CTS2(3495271, 9, 0.12, 0.20), CTS2(6848914, 4, 0.31, 0.40), 20];
  //Maple
  commonFinder.ColorClusters += [CTS2(2378868, 8, 0.14, 0.18), CTS2(2710661, 5, 0.08, 0.36), 20];
  //Mahogany
  commonFinder.ColorClusters += [CTS2(1065831, 3, 0.15, 1.31), CTS2(3425125, 4, 0.10, 0.33), 20];
  //Yew
  commonFinder.ColorClusters += [CTS2(11332, 3, 0.08, 0.01), CTS2(476757, 7, 0.19, 2.44), 20];
  //Magic
  commonFinder.ColorClusters += [CTS2(7962919, 9, 0.03, 0.29), CTS2(10922399, 14, 0.12, 0.17), 20];
  //Redwood
  commonFinder.ColorClusters += [CTS2(604522, 8, 0.22, 2.05), CTS2(4154261, 6, 0.05, 0.13), 20];
  commonFinder.ClusterDistance := 10;

  with VVBHN do
  begin
    SetupCoordinates([ [9471, 1252] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with VVBHS do
  begin
    SetupCoordinates([ [9446, 1276] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with MMBHN do
  begin
    SetupCoordinates([ [9107, 769] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with TARBH do
  begin
    SetupCoordinates([ [9114, 1034] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  Self.birdHouses[0] := [VVBHN, false];
  Self.birdHouses[1] := [VVBHS, false];
  Self.birdHouses[2] := [MMBHN, false];
  Self.birdHouses[3] := [TARBH, false];
end;

function TBirdHouseInclude.GetHouseOnHillRegion() : TBox;
begin
  Result := Box(10024, 865, 10314, 1114)
end;

function TBirdHouseInclude.GetNearestUnfilledBirdHouse(myPos : TPoint; out bestIndex : Int32) : Boolean;
var
  dist : Int32;
  bestDist : Int32;
  i : Int8;
begin
  bestDist := 99999;
  Result := False;
  bestIndex := -1;
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      continue;

    dist := Distance(Self.birdHouses[i].BirdhouseObject.Coordinates[0], myPos);

    if dist < bestDist then
    begin
      bestDist := dist;
      bestIndex := i;
      Result := true;
    end;
  end;
end;

procedure TBirdHouseInclude.Init();
var
  VerdValleyShroom, MushMeadowShroom, HouseHillShroom : TMushroom;
begin

  if Self.IsDisabled then
    Exit;

  Writeln("Birdhouse runner init!");
  Self.RSW.SetupRegions([RSRegions.FOSSIL_ISLAND, Self.GetHouseOnHillRegion()]);
  Self.RSW.AdaptiveWalk := true;
  RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES := Point(Random(6, 12), Random(6, 12));

  with HouseHillShroom.Mushroom do
  begin
    Setup(16, [ [10158, 948] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with VerdValleyShroom.Mushroom do
  begin
    Setup(16, [[9426, 1272]]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with MushMeadowShroom.Mushroom do
  begin
    Setup(16, [ [9106, 812] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  HouseHillShroom.location := ERSMushroomLocation.HILL_HOUSE;
  VerdValleyShroom.location := ERSMushroomLocation.VERD_VALLEY;
  MushMeadowShroom.location := ERSMushroomLocation.SHROOM_MEADOW;

  Self.Mushrooms := [HouseHillShroom, VerdValleyShroom, MushMeadowShroom];
  Self.MushIndex := 0;

  Self.ShouldTeleport := true;

  Self.SetupBirdHouses();
  Self.Initialized := true;

  Self.DebugLn("Birdhouse Run initialized");
  Self.DebugLn("Log: " + ToStr(Self.LogType));
  Self.DebugLn("Seed: " + ToStr(Self.Seed));
  Self.DebugLn("UseBestLog? : " + ToStr(Self.AlwaysUseBestLog));
  Self.DebugLn("Need Clockworks : " + ToStr(Self.NeedClockworks));
  Self.DebugLn("Interval: " + SRL.MsToTime(Self.TaskInterval, TTimeFormat.Time_Formal));

  Self.NestsLooted := 0;

  if Self.ScriptIntervalTimer.Length < 100 then
  begin
    Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
    Self.DebugLn("Started timer from Init");
  end;
end;

function TBirdHouseInclude.GetClosestObject(evalObjects : TRSObjectArray; position : TPoint ) : TRSObject;
var
  bestDist, dist : Int32;
  i : Int8;
begin
  Result := evalObjects[0];
  bestDist := Distance(position, Result.Coordinates[0]);

  for i := 0 to High(evalObjects) do
  begin
    dist := Distance(position, evalObjects[i].Coordinates[0]);

    if dist < bestDist then
    begin
      bestDist := dist;
      Result := evalObjects[i];
    end;
  end;
end;

function TBirdHouseInclude.ConfirmUptext(textToCheck : TStringArray) : Boolean;
const
  TEXT_COLOR : TCTS0Color := CTS0(14014992, 20);
var
  tpa : TPointArray;
begin
  Result := (Mainscreen.IsUpText(textToCheck))
             and (SRL.FindColors(tpa, TEXT_COLOR, MainScreen.UpTextArea) > 0);
end;

function TBirdHouseInclude.DismantleBirdhouse(out shouldSkip : Boolean) : Boolean;
var
  birdhouseATPA : T2DPointArray;
  dismantleTimeout, xpTimeout : TCountDown;
  chatTitle : string;
begin

  shouldSkip := False;
  Self.DebugLn("Moving");
  if not WaitUntil(Self.RSW.WalkBlind(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0], 20), 150, 5000) then
    Exit(False);

  WaitUntil(not Minimap.IsPlayerMoving(), 50, 5000);
  Self.DebugLn("Done Moving");

  if Self.NeedClockworks then
    if not Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)) then
    begin
      Self.BuildBirdHouseItem();
    end;

  dismantleTimeout.Init(6000);

  while not dismantleTimeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      Self.DebugLn("Failed to find bird house, rotating");
      Exit(False);
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(MainScreen.Center);

    Mouse.Move(birdHouseATPA[0].RandomValue());

    if not Self.ConfirmUptext(['nteract']) then
    begin
      Antiban.RandomRotate();
      Exit(False);
    end;

    Mouse.Click(MOUSE_RIGHT);
    Self.DebugLn("Dismantling birdhouse");

    if not WaitUntil(ChooseOption.IsOpen, 100, 1200) then
      Exit(False);

    if not ChooseOption.Select(['mpty'], MOUSE_LEFT, false, true) then
      Exit(False);

    xpTimeout.Init(8000);
    while not xpTimeout.IsFinished() do
    begin
      if XPBar.EarnedXP() then
        break;

      chatTitle := Chat.GetChatTitle();
      if chatTitle.Contains("will lose") then
      begin
        //Close the last one because it'll break other interactions.
        if Self.BirdHousesFilled = 3 then
        begin
          Wait(Random(327, 744)); //Looks more believable
          while chatTitle.Contains("will lose") do
          begin
            chatTitle := Chat.GetChatTitle();

            if SRL.Dice(15) then
              Chat.ClickOption("leave it be", 0, [CHAT_COLOR_BLACK])
            else
              PressKey(VK_ESCAPE);

            Wait(Random(137, 352));
          end;
        end;

        shouldSkip := true;
        Exit(false);
      end;

      Wait(120);
    end;

    Result := WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 2000);
    if Result then
    begin
      Self.DebugLn("Cleared this birdhouse");
      Exit(Result);
    end;
  end;

  Result := False;
end;

//At this point we should have a birdhouse in the inventory that we can use.
function TBirdHouseInclude.InteractWithBirdHouseSpace() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  birdHouseSpaceTPA : TPointArray;
  BirdSpaceTimeout : TCountDown;

begin

  Self.DebugLn("Interacting with space");

  BirdSpaceTimeout.Init(4000);
  while not BirdSpaceTimeout.IsFinished() do
  begin
    birdHouseSpaceTPA := Self.GetBirdHouseSpace();

    if birdHouseSpaceTPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Move(birdHouseSpaceTPA.RandomValue());

    if not Mainscreen.IsUpText(['uild', 'pace']) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Self.DebugLn("Found space");
    Mouse.Click(MOUSE_LEFT);

    if WaitUntil(not Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 200, 2300) then
    begin
      BirdSpaceTimeout.Pause();
      break;
    end;
  end;

  if BirdSpaceTimeout.IsFinished() then
    Exit(false);

  //If we click the space so we need to make sure we're not moving and we've found our current birdhouse.
  if WaitUntil(not Minimap.IsPlayerMoving()
      and ((Mainscreen.IsUpText(['eeds', 'mpty'])) or (Self.CurrentBirdHouse^.BirdhouseObject.Find(birdhouseATPA))), 75, 8000) then
    Result := true;
end;

function TBirdHouseInclude.FillBirdHouse() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  seedSlot, seedCount : Int32;
  timeout : TCountdown;
begin
  if not Inventory.FindItem(Self.Seed, seedSlot) then
  begin
    TerminateScript("No seeds!");
  end;

  seedCount := Inventory.CountItemStack(Self.Seed);

  while not Inventory.IsSlotSelected(seedSlot) do
  begin
    Inventory.SetSelectedSlot(-1);
    Inventory.SetSelectedSlot(seedSlot);
    Wait(100);
  end;

  timeOut.Init(6500);
  Self.DebugLn("Attempting to fill birdhouse");
  while not timeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(Mainscreen.Center);
    Mouse.Move(birdhouseATPA[0].RandomValue());

    if Self.ConfirmUptext(['mpty']) then
    begin
      timeout.Pause();
      Mouse.Click(MOUSE_LEFT);
      break;
    end;

    Antiban.RandomRotate();
    Wait(Random(110, 210));
  end;

  if timeout.IsFinished() then
  begin
    Writeln("Timed out on filling, skipping this birdhouse");
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Exit;
  end;

  Result := WaitUntil(seedCount > Inventory.CountItemStack(Self.Seed), 100, 6000);
end;

function TBirdHouseInclude.BuildBirdHouseItem() : Boolean;
var
  birdHouseItem : TRSItem := Self.GetBirdhouseItem(Self.LogType);

begin
  if not Inventory.ContainsItem('Clockwork')
  and not Inventory.ContainsItem(birdHouseItem) then
  begin
    Self.DebugLn("No clockwork or birdhouse in inventory, we can't continue!");
    Self.DebugLn("Ending run!");
    Self.BirdHousesFilled := 4;
    Exit(false);
  end;

  Result := Inventory.ContainsItem(birdHouseItem);

  if not Result then
  begin
    Self.DebugLn("No birdhouse in inventory, making one");

    if not Inventory.Use('Chisel', Self.GetLogString(Self.LogType)) then
    begin
      Self.DebugLn("Failed to use chisel");
      Exit;
    end;

    if WaitUntil(Make.IsOpen(), 100, 1200) then
    begin
      if not Make.Select(ToStr(birdHouseItem), Make.QUANTITY_ALL, Antiban.BioDice()) then
      begin
        Self.DebugLn("Failed to make birdHouse");
        Exit;
      end;
    end;

    if not WaitUntil(Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 100, 3000) then
    begin
      Self.DebugLn("Inventory has no birdHouse");
      Exit;
    end;

    Result := true;
  end;
end;

function TBirdHouseInclude.HandleBirdHouse() : Boolean;
var
  shouldSkip : Boolean;
begin
  //There's already a birdhouse there and should be ready for dismantling
  //Find our current birdhouse and interact with it.
  //Dismantle and return once there's a space.

  if Self.DismantleBirdhouse(shouldSkip) then
  begin
    Self.DebugLn("Dismantled our current birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 4000);
    if not Self.NeedClockworks
    and WaitUntil(Inventory.ContainsItem("Clockwork"), 10, 2000) then
    begin
      Wait(Random(150, 241)); //Prevent 1 ticking the build and the space click
      if not Self.BuildBirdHouseItem() then
        Exit;
    end;
  end;

  if shouldSkip then
  begin
    Self.DebugLn("Too early for this birdhouse, skipping.");
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Exit;
  end;

  Wait(Random(313, 523));

  //Check for a space and build a birdhouse there.
  if Self.InteractWithBirdHouseSpace() then
  begin
    Self.DebugLn("Built new birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
  end;

  Wait(Random(241, 456));

  if Self.FillBirdHouse() then
  begin
    Self.DebugLn("Filled birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Result := true;
  end;
end;

function TBirdHouseInclude.GetBirdhouseFillCount() : Int32;
var
  i : Int32;
begin
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      Inc(Result);
  end;
end;

procedure TBirdHouseInclude.Reset()
var
  i : Int32;

begin
  Self.MushIndex := 0;
  Self.BirdHousesFilled := 0;
  Self.CurrentBirdHouse := nil;
  Self.ShouldTeleport := true;

  for i := 0 to High(Self.birdHouses) do
  begin
    Self.birdHouses[i].IsFilled := false;
  end;
end;

function TBirdHouseInclude.GetState() : EScriptState;
var
  myPos : TPoint := Self.RSW.GetMyPos();
  bestBHIndex : Int32 := -1;

begin

  if Self.HasRunFinished then
  begin
    Exit(EScriptState.DO_NOTHING);
  end;

  if (Self.BirdHousesFilled >= 4) then
  begin
    Self.DebugLn("Run finished");
    Inc(Self.RunsCompleted);
    Self.TotalXPEarned += XPBar.Read() - Self.RunStartXp;
    Self.NestsLooted += Inventory.CountItem('Bird nest');
    if WaitUntil(Chat.HasContinue(), 150, 1400) then
      Chat.ClickContinue(true);

    Self.HasRunFinished := true;
    Self.Reset();
    Exit(EScriptState.DO_NOTHING);
    //TerminateScript("Finished run");
  end;

  //Check if we got our tools
  if not Self.HasTools() then
  begin
    Self.HasRunFinished := true;
    Self.Reset();
    Self.DebugLn("Ending run: Missing some tools");
    Exit(EScriptState.DO_NOTHING);
  end;

  if (Self.GetNearestUnfilledBirdHouse(myPos, bestBHIndex))
  and (bestBHIndex > -1 ) then
  begin
    Self.CurrentBirdHouse := @Self.birdHouses[bestBHIndex];

    if myPos.DistanceTo(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0]) < 100 then
    begin
      Self.ShouldTeleport := false;
      Exit(EScriptState.INTERACT_BIRDHOUSES);
    end;

    Self.ShouldTeleport := true;
  end;

  if Self.MushIndex = High(Self.Mushrooms) then
    Exit(EScriptState.NAVIGATING);

  if Self.ShouldTeleport then
  begin
    if Self.MushIndex < High(Self.Mushrooms) then
    begin
      Self.CurrentBirdHouse := nil;

      if MushTree.IsOpen() then
        Exit(EScriptState.USE_MUSHROOM);

      Exit(EScriptState.CLICK_MUSHROOM);
    end;
  end;
end;

function TBirdHouseInclude.WalkToMushroom(index : Int32 = -1) : Boolean;
var
  indexToUse : Int32;

begin
  WaitEx(2500, 500);

  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  if not Self.Mushrooms[indexToUse].Mushroom.WalkClick() then
    Self.Debugln("Failed to get to mushroom")
  else
    Result := WaitUntil(Mushtree.IsOpen(), 300, 10000);
end;

function TBirdHouseInclude.HandleMushroomTeleport(index : Int32 = -1) : Boolean;
var
  mushroomBox : TBox;
  indexToUse : Int32;
begin

  if not MushTree.IsOpen() then
    Exit;

  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  Mushtree.Click(Self.Mushrooms[indexToUse].GetMushButton());

  mushroomBox := Box(Self.Mushrooms[indexToUse].Mushroom.Coordinates[0], 100, 100);

  if WaitUntil(not mushroomBox.Contains(Self.RSW.GetMyPos()), 400, 6000) then
  begin
    Self.DebugLn("Successfully teleported to mushroom");
    Result := true;
    if index = -1 then
      Self.MushIndex := Min(MushIndex + 1, High(Self.Mushrooms));

    Self.DebugLn("Mush index now: " + ToStr(Self.MushIndex));
    //Basically waiting for screen to fade in.
    Wait(Random(1400, 2200));
  end;
end;

function TBirdHouseInclude.HandleCave : Boolean;
const
  CAVE_FLOOR_COL : TCTS2Color := CTS2(4474118, 3, 0.30, 5.83);
  ROPE_COL : TCTS2Color := CTS2(6717077, 11, 0.09, 0.47);
var
  tpa : TPointArray;
  ropeClicked : Boolean;
  attempt: Int32;

begin
  if SRL.FindColors(tpa, CAVE_FLOOR_COL, Mainscreen.Bounds) < 1000 then
  begin
    Writeln("Not in cave!");
    Exit(true);
  end;

  for attempt := 0 to 5 do
  begin
    if SRL.FindColors(tpa, ROPE_COL, Mainscreen.Bounds) < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    tpa := tpa.Cluster(5).Biggest();

    Mouse.Move(tpa);
    if not Mainscreen.IsUpText(['up', 'xit' ]) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Click(MOUSE_LEFT);
    if ropeClicked := Mainscreen.DidRedClick(300) then
      break;
  end;

  if not ropeClicked then
    Exit(false);

  Result := WaitUntil(SRL.CountColor(CAVE_FLOOR_COL, Mainscreen.Bounds) < 1000, Random(250, 600), 10000);
end;

function TBirdHouseInclude.HandleNavigating() : Boolean;
begin
  Self.RSW.ScreenWalk := false;
  Self.RSW.AdaptiveWalk := false;

  try
    if not Self.RSW.WebWalk(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0], 10) then
    begin
      Self.DebugLn("We may have entered the cave. Trying to handle it...");
      if not HandleCave() then
      begin
        Self.DebugLn("Couldn't recover. Terminating.");
        TerminateScript('Birdhouse runner failed to recover from cave navigation.');
      end
      else
        Self.DebugLn("Recovered!");
    end;
  except
    begin
      Self.DebugLn("Web walker caused an exception, may have entered the cave. Trying to handle it...");
      if not HandleCave() then
      begin
        Self.DebugLn("Couldn't recover. Terminating.");
        TerminateScript('Birdhouse runner failed to recover after walker exception.');
      end
      else
        Self.DebugLn("Recovered!");
    end;
  end;

  Self.RSW.ScreenWalk := true;
  Self.RSW.AdaptiveWalk := true;
  Result := true;
end;

function TBirdHouseInclude.GetLogForHunterLevel(level : Int32) : ERSLogType;
var
  craftLevel : Int32 := Stats.GetLevel(ERSSkill.CRAFTING, false);

begin
  Self.DebugLn("Detected hunter level: " + ToStr(level) + " detected crafting level: " + ToStr(craftLevel));
  if (level >= 89) and (craftLevel >= 90) then
    Result := ERSLogType.REDWOOD_LOGS
  else if (level >= 74) and (craftLevel >= 75) then
    Result := ERSLogType.MAGIC_LOGS
  else if (level >= 59) and (craftLevel >= 60) then
    Result := ERSLogType.YEW_LOGS
  else if (level >= 49) and (craftLevel >= 50) then
    Result := ERSLogType.MAHOGANY_LOGS
  else if (level >= 44) and (craftLevel >= 45) then
    Result := ERSLogType.MAPLE_LOGS
  else if (level >= 34) and (craftLevel >= 35) then
    Result := ERSLogType.TEAK_LOGS
  else if (level >= 24) and (craftLevel >= 25) then
    Result := ERSLogType.WILLOW_LOGS
  else if (level >= 14) and (craftLevel >= 15) then
    Result := ERSLogType.OAK_LOGS
  else
    Result := ERSLogType.REGULAR_LOGS;
end;

function TRSBank.FindAny(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if Self.FindItem(tempItem, tempBox) then
      Exit(true);
  end;
end;

function TBirdHouseInclude.GetNextBestLogInBank(currLog : ERSLogType) : ERSLogType;
var
  i : Int32;
  tempBox : TBox;
  foundBankItem : TRSBankItem;
begin
  if not Bank.IsOpen() then
    Exit(Self.LogType);

  for i := Ord(currLog) downto 0 do
  begin
    foundBankItem.Item := Self.GetLogString(ERSLogType(i));

    if Bank.FindItem(foundBankItem, tempBox) then
      Exit(ERSLogType(i));
  end;

  Self.DebugLn("Couldn't find any other logs");
  TerminateScript("Out of logs");
end;

function TBirdHouseInclude.WalkToIslandBank() : Boolean;
begin
  if Self.AlwaysUseBestLog then
    Self.SuggestedLogType := Self.GetLogForHunterLevel(Stats.GetLevel(ERSSkill.HUNTER, false));

  Result := Bank.WalkOpen(RSObjects.BankChestFossilIsland);
end;

//Function responsible for getting to a bank
//Probably switching gear
//Withdrawing the needed things
//Should return if it was successful
function TBirdHouseInclude.OnStart() : Boolean;
begin
  Exit(true);
end;

procedure TBirdHouseInclude.OnComplete();
begin
  Exit;
end;

function TBirdHouseInclude.HasAllItemsForRun() : Boolean;
var
  tools : TRSBankItemArray;
  i : Int32;
  itemStr : string;
begin

  tools := Self.GetWithdrawList();

  for i := 0 to High(tools) do
  begin
    itemStr := ToStr(tools[i].Item);
    if itemStr.Contains("seed") then
    begin
      if Inventory.CountItemStack(tools[i].Item) < 40 then
      begin
        Self.DebugLn("Cannot do run, missing some seeds");
        Exit(false);
      end;
    end
    else
    begin
      if Inventory.CountItem(tools[i].Item) < tools[i].Quantity then
      begin
        Self.DebugLn("Cannot do run, not enough of item: " + itemStr);
        Exit(false);
      end;
    end;
  end;

  Result := true;
end;

function TBirdHouseInclude.TeleportToIsland() : Boolean;
var
  transporter: TUniversalTransport;
begin
  Result := transporter.Run(RSTEleports.FOSSIL_ISLAND);
  if not Result then
    Self.DebugLn("Could not teleport");
end;

function TBirdHouseInclude.GetReportStrings() : TStringArray;
const
  spacingStart : string := "[";
    spacingEnd : string := "|]";
  var
  listOfStrings : TStringArray;
  i : Int32;
begin
  listOfStrings += spacingStart + "=================================" + spacingEnd;
  listOfStrings += "Birdhouse Include by CJ";
  listOfStrings += listOfStrings[0];
  listOfStrings += "Next run in " + SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Short);
  listOfStrings += "Runs Completed: " + ToStr(Self.RunsCompleted);
  listOfStrings += "XP Earned: " + ToStr(Self.TotalXPEarned);
  listOfStrings += "Nests Looted: " + ToStr(Self.NestsLooted);
  listOfStrings += listOfStrings[0];

  //Header text
  Result += listofStrings[0];
  Result += spacingStart + PadL(" ", 3, " ") + PadR(listofStrings[1], 30, " ") + spacingEnd;
  Result += listofStrings[2];

  for i := 3 to High(listOfStrings) - 1 do
  begin
    Result += spacingStart + PadL(" ", 3, " ") + PadR(listOfStrings[i], 30, " ") + spacingEnd;
  end;

  Result += listOfStrings[High(listOfStrings)];
end;

procedure TBirdHouseInclude.DisplayReport();
var
  report : TStringArray;
  i : Int32;
begin
  report := Self.GetReportStrings();
  for i := 0 to High(report) do
  begin
    Writeln(report[i]);
  end;
end;

//These 3 functions together look dumb
//But it's actually so authors can do something like
//procedure TBirdHouseInclude.PrintReport() override;
//PrintMainScriptReport()
//inherited;
//As a way to append it.
procedure TBirdHouseInclude.PrintReport();
begin
  Self.DisplayReport();
end;

procedure TBirdHouseInclude.BirdhouseRun();
var
  CachedWalker : PRSWalker;

begin
  CachedWalker := ScriptWalker;

  if not Self.Initialized then
  begin
    Self.Init();
  end;

  Self.DebugLn("Calling OnStart Method");
  if not Self.OnStart() then
    Exit;

  if (not GetHouseOnHillRegion().Contains(ScriptWalker^.GetMyPos()))
    and not (Self.TeleportToIsland()) then
  begin
    Writeln("Not in hill region!");
    Exit;
  end;

  ScriptWalker := @Self.RSW;

  Self.RunStartXp := XPBar.Read();

  while not Self.HasRunFinished do
  begin
    CheckSystemUpdate();

    //Re-log in during run
    if not RSClient.IsLoggedIn() then
    begin
      if not Login.LoginPlayer() then
      begin
        TerminateScript("Could not log in player");
      end;
    end;

    Self.State := Self.GetState();

    if Self.State <> EScriptState.DO_NOTHING then
      Self.DebugLn("SciptState: " + ToStr(Self.State));

    case Self.State of
      EScriptState.BUILD_BIRDHOUSE : Self.BuildBirdHouseItem();
      EScriptState.INTERACT_BIRDHOUSES : Self.HandleBirdHouse();
      EScriptState.CLICK_MUSHROOM : Self.WalkToMushroom();
      EScriptState.USE_MUSHROOM : Self.HandleMushroomTeleport();
      EScriptState.TELEPORTING : ;
      EScriptState.DO_NOTHING : ;
      EScriptState.NAVIGATING : Self.HandleNavigating();
    end;
  end;

  //Responsible for getting them back to their initial activity
  Self.DebugLn("Calling OnComplete Method");
  Self.OnComplete();
  Self.HasRunFinished := false;
  ScriptWalker := CachedWalker;
end;

function TBirdHouseInclude.CanDoBirdHouseRun() : Boolean;
begin

  if Self.IsDisabled then
    Exit(false);

  if not Self.ScriptIntervalTimer.IsFinished() then
  begin
    if (Self.NextRunSpewTimer.TimeRemaining = 0)
        or (Self.NextRunSpewTimer.IsFinished()) then
    begin
      NextRunSpewTimer.Init(5 * ONE_MINUTE);
      WriteLn('Next birdhouse run in ' + SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Short));
    end;

    Exit(false);
  end;

  Result := true;
end;

procedure TBirdHouseInclude.DoBirdHouseRun();
begin
  BirdhouseRunActive := True;
  PauseBreakTimers();
  try
    Self.BirdhouseRun();
  finally
    BirdhouseRunActive := False;
    ResumeBreakTimers();
    CheckSystemUpdate();
  end;

  if(Self.TaskInterval < (50 * ONE_MINUTE)) then
    Self.TaskInterval := 50 * ONE_MINUTE;

  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
  Self.PrintReport();
end;

function TBirdHouseInclude.WithdrawNextRun() : Boolean;
var
  itemList : TRSBankItemArray;
  i, itemNumNeeded : Int32;
  itemName : string;
  nextBestLog : ERSLogType;
  transporter: TUniversalTransport;

begin
  if not Bank.IsOpen() then
    Exit;

  if Self.AlwaysUseBestLog
  and not Self.TerminateOnNoLogs
  and (Self.LogType <> Self.SuggestedLogType) then
  begin
    if not Bank.FindAll([Self.GetLogString(Self.LogType), Self.GetLogString(Self.SuggestedLogType)]) then
    begin
      Self.DebugLn("Bank doesn't have our best choice or current choice, finding another");
      nextBestLog := Self.GetNextBestLogInBank(Self.LogType);
      Self.DebugLn("Next best log is: " + ToStr(nextBestLog) + " changing our current log: " + ToStr(Self.LogType) + " to this one");
      Self.LogType := nextBestLog;
    end
    else if Self.LogType <> Self.SuggestedLogType then
    begin
      Self.DebugLn("Updated current log type: " + ToStr(Self.LogType) + " to best type: " + ToStr(Self.SuggestedLogType));
      Self.LogType := Self.SuggestedLogType;
    end;
  end;

  itemList := Self.GetWithdrawList();

  for i := 0 to High(itemList) do
  begin
    itemName := ToStr(itemList[i].Item);
    if not itemName.Contains('seed') then
      itemNumNeeded := itemList[i].Quantity - Inventory.CountItem(itemList[i].Item)
    else
    begin
      itemNumNeeded := itemList[i].Quantity - Max(0, Inventory.CountItemStack(itemList[i].Item));
    end;

    if itemNumNeeded < 1 then
    begin
      Self.DebugLn("Skipping withdraw for item: " + ToStr(itemList[i].Item));
      continue;
    end;

    itemList[i].Quantity := itemNumNeeded;
    if not Bank.WithdrawItem(itemList[i], false) then
    begin
      Self.DebugLn('Bank is missing: ' + ToStr(itemList[i].Item));
      if Bank.GetCurrentTab() <> 0 then
      begin
        Self.DebugLn('Retrying withdraw on all items tab.');
        Bank.OpenTab(0);
      end;
      Exit(false);
    end;

    if not WaitUntil(Inventory.ContainsItem(itemList[i].Item), 100, 2000) then
    begin
      Self.DebugLn('Could not withdraw item: ' + ToStr(itemList[i].Item));
      if Bank.GetCurrentTab() <> 0 then
      begin
        Self.DebugLn('Retrying withdraw on all items tab.');
        Bank.OpenTab(0);
      end;
      Exit(false);
    end;
  end;

  if not transporter.withdrawTeleportItem(RSTeleports.FOSSIL_ISLAND) then
  begin
    Self.DebugLn("Could not get pendant");
    Exit(false);
  end;

  Result := true;
end;

//If you don't use the GUI's TScriptForm.CreateBirdhouseRunSettings
//Use this to set the values directly.
procedure TBirdHouseInclude.Setup(log : ERSLogType; seedItem : TRSItem; useBestLog : Boolean = false; interval : UInt32 = (50 * ONE_MINUTE); needClockwork : Boolean = true);
begin
  with Self do
  begin
    LogType := log;
    Seed := seedItem;
    AlwaysUseBestLog := useBestLog;
    NeedClockworks := needClockwork;
    TaskInterval := interval;
  end;

  Writeln("SETUP INTERVAL: ", ToStr(Self.TaskInterval));
  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
  Writeln("SETUP birdhouse run in: ", SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Formal_Long));
end;

//Weird name because it'll likely get used as a regular formutil at some point
procedure TComponent.CJTextField({$H-}sender: TObject;{$H+} var key: char);
begin
  if not (key in ['A'..'Z', 'a'..'z', #8]) then
    key := #0;
end;

function TScriptForm.CreateBirdhouseRunSettings(): TTabSheet;
  type TScriptForm = TScriptForm;

  procedure TScriptForm._OnCheckBoxChanged(sender: TObject);
  var
    checkBox : TCheckBox;
    isChecked : Boolean;
  begin
    checkBox := sender;
    isChecked := checkBox.IsChecked();
    case checkBox.getName() of
      'bh_extraclockworkcb_checkbox' : BirdHouseRunner.NeedClockworks := isChecked;
      'bh_bestlogcb_checkbox': BirdHouseRunner.AlwaysUseBestLog := isChecked;
    end;
  end;

  procedure TScriptForm._SeedChanged(sender: TObject);
  var
    comboBox: TComboBox;
    idx: Int32;
  begin
    comboBox := sender;
    idx := comboBox.getItemIndex();
    if (idx >= 0) and (idx < comboBox.getItems().getCount()) then
      BirdHouseRunner.Seed := comboBox.getItems().getStrings(idx);
  end;

  procedure TScriptForm._LogTypeChanged(sender: TObject);
  var
    combobox: TComboBox;
  begin
    combobox := sender;
    BirdHouseRunner.LogType := ERSLogType(comboBox.getItemIndex());
  end;

  procedure TScriptForm._BHIncludeOnRadioChanged(sender: TObject);
  var
    radio : TRadioButton;
  begin
    radio := sender;
    case radio.getName() of
      'bh_nowradio' : BirdHouseRunner.TaskInterval := 0;
      'bh_laterradio' : BirdHouseRunner.TaskInterval := BirdHouseRunner.TaskInterval := 50 * ONE_MINUTE;
    end;
  end;

const
  H_SPACING : Int32 := 50;
var
  logTypeCombo : TLabeledCombobox;
  nowRadio, laterRadio: TRadioButton;
  intervalLabel : TLabel;
  seedCombo  : TLabeledCombobox;
  seedIndex, fullWidth, w, space, y: Int32;

begin
  Self.AddTab('Birdhouse Settings');
  Result := Self.Tabs[High(Self.Tabs)];

  fullWidth := Self.Size.X;
  space := Floor(fullWidth * 0.1);
  w := fullWidth - (space * 2);
  y := Floor(Self.Size.Y/6);

  with logTypeCombo do
  begin
    Create(Result);
    SetCaption('Log type to use:');
    SetStyle(csDropDownList);
    AddItemArray(['Regular', 'Oak', 'Willow', 'Teak',
                  'Maple', 'Mahogany', 'Yew', 'Magic tree', 'Redwood']);
    SetLeft(TControl.AdjustToDPI(H_SPACING));
    SetTop(TControl.AdjustToDPI(15));
    BirdHouseRunner.LogType := BHIncludeGUILogType;
    SetItemIndex(Ord(BirdHouseRunner.LogType));
    Combobox.SetOnChange(@Self._LogTypeChanged);
  end;

  with seedCombo do
  begin
    Create(Result);
    SetTop(logTypeCombo.GetTop());
    SetLeft(logTypeCombo.GetRight() + TControl.AdjustToDPI(H_SPACING));
    SetWidth(250);
    SetCaption('Seed:');
    SetName('bh_seed');
    SetStyle(csDropDownList);
    AddItemArray(['Barley seed', 'Hammerstone seed', 'Asgarnian seed',
                  'Jute seed', 'Yanillian seed', 'Krandorian seed', 'Wildblood seed']);
    BirdHouseRunner.Seed := ToStr(BHIncludeGUISeed);
    seedIndex := ComboBox.getItems().IndexOf(ToStr(BirdHouseRunner.Seed));
    if seedIndex < 0 then
      seedIndex := 0;
    SetItemIndex(seedIndex);
    BirdHouseRunner.Seed := ComboBox.getItems().getStrings(seedIndex);
    ComboBox.SetOnChange(@Self._SeedChanged);
  end;

  with intervalLabel do
  begin
    Create(Result);
    SetCaption("When should the next run start?"
               + #13#10 + "Runs afterwards will continue every 50 - 60 minutes automatically.");
    SetLeft(logTypeCombo.GetLeft());
    SetTop(logTypeCombo.GetTop() + TControl.AdjustToDPI(60));
    SetFontSize(9);
  end;

  with nowRadio do
  begin
    Create(Result);
    SetName("bh_nowradio");
    SetLeft(intervalLabel.GetLeft());
    SetTop(intervalLabel.GetTop() + TControl.AdjustToDPI(33));
    SetCaption("Do a run now");
    SetOnClick(@Self._BHIncludeOnRadioChanged);
    SetFontSize(9);
  end;

  with laterRadio do
  begin
    Create(Result);
    SetName("bh_laterradio");
    SetCaption("Do a run later (in about 50 - 60 minutes)");
    SetLeft(nowRadio.getLeft());
    SetTop(nowRadio.getTop() + TControl.AdjustToDPI(25));
    SetOnClick(@Self._BHIncludeOnRadioChanged);
    SetFontSize(9);
  end;

  BirdHouseRunner.TaskInterval := BHIncludeGUIRunIntervalMinutes;

  if BHIncludeGUIRunIntervalMinutes > 0 then
  begin
    laterRadio.setState(TCheckBoxState.cbChecked);
    nowRadio.setState(TCheckBoxState.cbUnchecked);
    BirdHouseRunner.TaskInterval := 50 * ONE_MINUTE;
  end
  else
  begin
    laterRadio.setState(TCheckBoxState.cbUnchecked);
    nowRadio.setState(TCheckBoxState.cbChecked);
    BirdHouseRunner.TaskInterval := 0;
  end;
end;

begin
  PatchData += [
    CTS2(6520971, 8, 0.05, 0.27),
    CTS2(408653, 7, 0.11, 2.64),
    CTS2(3108159, 13, 0.08, 1.39),
    [6787, 710],
    [6785, 728],
    EPatchType.HERB,
    [6500, 600, 7000, 800],
    'Weiss herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(408653, 7, 0.11, 2.64),
    CTS2(3830139, 13, 0.03, 0.44),
    [6699, 1670],
    [6697, 1704],
    EPatchType.HERB,
    [6550, 1550, 6850, 1800],
    'Stronghold herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6646, 2594],
    [6653, 2583],
    EPatchType.HERB,
    [6286, 2351, 6910, 2850],
    'Catherby herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6626, 2594],
    [6653, 2583],
    EPatchType.FLOWER,
    [6286, 2351, 6910, 2850],
    'Catherby flower'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(3431524, 12, 0.05, 0.16),
    CTS2(3108159, 13, 0.08, 1.39),
    [6644, 2578],
    [6653, 2583],
    EPatchType.ALLOTMENT,
    [6286, 2351, 6910, 2850],
    'Catherby north allotment'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(3431524, 12, 0.05, 0.16),
    CTS2(3108159, 13, 0.08, 1.39),
    [6646, 2609],
    [6653, 2583],
    EPatchType.ALLOTMENT,
    [6286, 2351, 6910, 2850],
    'Catherby south allotment'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6075, 2949],
    [6080, 2923],
    EPatchType.HERB,
    [5855, 2792, 6286, 3070],
    'Ardy herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6058, 2949],
    [6080, 2923],
    EPatchType.FLOWER,
    [5855, 2792, 6286, 3070],
    'Ardy flower'
  ];

  PatchData += [
    CTS2(6127499, 6, 0.10, 0.71),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [2346, 2258],
    [2357, 2252],
    EPatchType.HERB,
    [2150, 2050, 2600, 2600],
    'Hosidious herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [2331, 2242],
    [2357, 2252],
    EPatchType.FLOWER,
    [2150, 2050, 2600, 2600],
    'Hosidious flower'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [7626, 3202],
    [7604, 3228],
    EPatchType.HERB,
    [7500, 3100, 7700, 3450],
    'Fally herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [7610, 3218],
    [7604, 3228],
    EPatchType.FLOWER,
    [7500, 3100, 7700, 3450],
    'Fally flower'
  ];

  PatchData += [
    CTS2(2646105, 4, 0.14, 0.45),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(2385461, 9, 0.09, 1.08),
    [9814, 2330],
    [9780, 2360],
    EPatchType.HERB,
    [9385, 2036, 10384, 2680],
    'Port Phasmatys herb'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [346, 1554],
    [336, 1532],
    EPatchType.HERB,
    [45, 1263, 648, 1721],
    'Farming Guild herb'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [434, 1558],
    [440, 1536],
    EPatchType.FLOWER,
    [45, 1263, 648, 1721],
    'Farming Guild herb'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [461, 1530],
    [440, 1536],
    EPatchType.ALLOTMENT,
    [45, 1263, 648, 1721],
    'Farming Guild north allotment'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [463, 1552],
    [440, 1536],
    EPatchType.ALLOTMENT,
    [45, 1263, 648, 1721],
    'Farming Guild south allotment'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [434, 1527],
    [440, 1536],
    EPatchType.BUSH,
    [45, 1263, 648, 1721],
    'Farming Guild bush'
  ];

  PatchData += [
    CTS2(5332322, 17, 0.14, 0.10),
    CTS2(2972511, 10, 0.53, 0.59),
    CTS2(2782782, 5, 0.13, 1.58),
    [450, 1470],
    [440, 1536],
    EPatchType.CACTUS,
    [45, 1263, 648, 1721],
    'Farming Guild cactus'
  ];

  PatchData += [
    CTS2(6127499, 7, 0.08, 0.61),
    CTS2(3497831, 7, 0.07, 0.20),
    CTS2(2782782, 5, 0.13, 1.58),
    [5864, 3546], [5846, 3544],
    EPatchType.BUSH,
    [5650, 3350, 6050, 3750],
    'Monestary bush'
  ];

  PatchData += [
    CTS2(4745297, 4, 1.30, 2.30),
    CTS2(5926241, 4, 0.92, 0.38),
    CTS2(6189902, 6, 0.52, 0.52),
    [1282, 5616],
    [1276, 5630],
    EPatchType.SEAWEED,
    [1129, 5407, 1769, 5824],
    'Giant seaweed north'
  ];

  PatchData += [
    CTS2(4745297, 4, 1.30, 2.30),
    CTS2(5926241, 4, 0.92, 0.38),
    CTS2(6189902, 6, 0.52, 0.52),
    [1282, 5640],
    [1276, 5630],
    EPatchType.SEAWEED,
    [1129, 5407, 1769, 5824],
    'Giant seaweed south'
  ];
end;

procedure TRSItemArray.Add(Items: TRSItemArray);
var
  Item: TRSItem;
begin
  for Item in Items do
    Self += Item;
end;

const
  HERB_SEEDS: TRSItemArray = ['Guam seed', 'Marrentill seed', 'Tarromin seed', 'Harralander seed',
                              'Ranarr seed', 'Toadflax seed', 'Irit seed', 'Avantoe seed',
                              'Kwuarm seed', 'Snapdragon seed', 'Cadantine seed', 'Lantadyme seed',
                              'Dwarf weed seed', 'Torstol seed'];

  FLOWER_SEEDS: TRSItemArray = ['Marigold seed', 'Rosemary seed', 'Nasturtium seed', 'Woad seed',
                                'Limpwurt seed', 'White lily seed'];

function GetSeedIndex(const Seeds: TRSItemArray; const Seed: TRSItem): Int32;
var
  i: Int32;
begin
  for i := 0 to High(Seeds) do
    if SameText(Seeds[i], Seed) then
      Exit(i);

  Result := -1;
end;

function EnsureSeedInList(const Seeds: TRSItemArray; const Seed, DefaultSeed: TRSItem): TRSItem;
begin
  if GetSeedIndex(Seeds, Seed) <> -1 then
    Exit(Seed);

  Result := DefaultSeed;
end;

function TFarmRun.GetNextTime(): Int32;
begin
  if Length(Self.Patches) = 2 then
    if ('seaweed' in Self.Patches[0].Data.Name) and ('seaweed' in Self.Patches[1].Data.Name) then
      Exit(Random(46*ONE_MINUTE, 55*ONE_MINUTE));

  Exit(Random(86*ONE_MINUTE, 97*ONE_MINUTE));
end;

function TRSInventory.Count(): Int32; override;
var
  Slot: Int32;
begin
  if not Self.Open() then
    Exit();

  for Slot := 0 to 27 do
    if Self.IsSlotUsed(Slot) then
      Inc(Result)
end;

procedure TFarmRun.AddPatch(Patch: EFarmPatch; Travel: ETravelMethod; Seed: TRSItem);
var
  EmptyUpText: TStringArray := ['Herb', 'Flower', 'Bush', 'Allotment', 'Cactus', 'Seaweed patch'];
  HarvestUpText: TStringArray := ['ick', 'ick', 'ick', 'arves', 'ick', 'ick'];
  Data: TPatchData := PatchData[Patch];
  TPA: TPointArray;
  SearchBox: TBox;
  Empty: String := EmptyUpText[Data.PatchType];
  Planted: String := ToStr(Seed).Before(' ');
  Harvest: String := HarvestUpText[Data.PatchType];
begin
  if Data.PatchType = EPatchType.HERB then
    Planted := 'Herb';

  Self.Patches += [Empty, Planted, Harvest, Travel, Data, TPA, SearchBox, Seed];
end;

function TFarmPatch.Find(Retry: Boolean = True): Boolean;
var
  Attempts: Int32;

  function F(): Boolean
  var
    FilterPt: TPoint := ScriptWalker^.GetTileMS(Self.Data.Coords).Mean();
    BorderTPA, SearchFiltered: TPointArray;
    BorderATPA: T2DPointArray;
    SearchPt: TPoint;
    i: Int32;
  begin
    if not (FilterPt in Mainscreen.Bounds) then
      Exit(False);

    if SRL.FindColors(BorderTPA, Self.Data.BorderColor, MainScreen.Bounds) = 0 then
      Exit(False);

    BorderATPA := BorderTPA.Cluster(Mainscreen.NormalizeDistance(32));
    for i := 0 to High(borderATPA) do
    begin
      Self.TPA := BorderATPA[i].ConvexHull.Connect();

      if SRL.PointInPoly(FilterPt, Self.TPA) then
      begin
        Self.TPA := Self.TPA.SortFrom(MainScreen.Center);
        SearchFiltered := Self.TPA.FilterDist(0, MainScreen.NormalizeDistance(140), Self.TPA[0].X, Self.TPA[0].Y);
        SearchFiltered := SearchFiltered.SortFrom(MainScreen.Center);
        SearchPt := SearchFiltered.Mean();
        Self.SearchBox := Box(SearchPt, MainScreen.NormalizeDistance(14), MainScreen.NormalizeDistance(14));
        Self.SearchBox.LimitTo(MainScreen.Bounds);
        RSClient.Image.Clear();

        //RSClient.Image.DrawRect(Self.TPA.MinAreaRect, CHAT_COLOR_LIGHT_PURPLE);
        //RSClient.Image.DrawBox(Self.SearchBox, CHAT_COLOR_MAROON);

        Exit(True);
      end;
    end;
    Self.SearchBox := [0, 0, 0, 0];
    Self.TPA := [];
    Result := False;
  end;

begin
  if not Retry then
    Exit(F());

  Result := False;
  for Attempts := 0 to 3 do
  begin
    if F() then
      Exit(True);

    try
    case attempts of
      0:
      begin
        if not ScriptWalker^.MakePointVisible(Self.Data.Coords) then
        begin
          ScriptWalker^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
          ScriptWalker^.MakePointVisible(Self.Data.Coords);
        end
      end;

      1: Antiban.RandomRotate();
      2:
      begin
        ScriptWalker^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
        ScriptWalker^.MakePointVisible(Self.Data.Coords);
      end;
      3:
      begin
        WriteLn('Failed to find patch.');
        Exit();
      end;
    end;
    except
      Exit();
    end;
  end;
end;

function TFarmPatch.IsDead(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(CTS2(6050153, 7, 2.73, 0.61), Self.SearchBox);
  Result := ColorCount > MainScreen.NormalizeDistance(24);

  if ColorCount > 0 then
    WriteLn('Found dead patch colors. Count: ', ColorCount);
end;

function TFarmPatch.IsDiseased(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(CTS2(1272942, 14, 0.03, 2.31), Self.SearchBox);
  Result := ColorCount > MainScreen.NormalizeDistance(40);

  if ColorCount > 0 then
    WriteLn('Found diseased patch colors. Count: ', ColorCount);
end;

function TFarmPatch.IsEmpty(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(Self.Data.SoilColor, Self.SearchBox);
  Result := ColorCount = Self.SearchBox.Area;
end;

function TFarmPatch.FindLeprechaun(out Point: TPoint; Retry: Boolean = True): Boolean;
var
  Attempts: Int32;

  function F(): Boolean;
  var
    SearchTPA, LeprechaunTPA: TPointArray;
    Cuboids: TCuboidExArray;
    FindBox: TBox;
  begin
    Cuboids := ScriptWalker^.GetCuboidArrayMS([Self.Data.LeprechaunCoords], [1.5, 1.5, 8], [0, 0]);

    if Length(Cuboids) = 0 then
      Exit();

    FindBox := Cuboids[0].Bounds();
    FindBox.LimitTo(MainScreen.Bounds);

    if SRL.FindColors(SearchTPA, Self.Data.LeprechaunColor, FindBox) = 0 then
      Exit();

    LeprechaunTPA := Cuboids[0].Filter(SearchTPA);

    if LeprechaunTPA.Len = 0 then
      Exit();

    Point := LeprechaunTPA.Mean();
    Result := True;
  end;

begin
  if not Retry then
    Exit(F());

  for Attempts := 0 to 3 do
  begin
    if F() then
      Exit(True);

    case Attempts of
      0, 2:
      begin
        if not ScriptWalker^.MakePointVisible(Self.Data.LeprechaunCoords) then
        begin
          ScriptWalker^.WebWalk([Self.Data.LeprechaunCoords.X + 4, Self.Data.LeprechaunCoords.Y + 4]);
          ScriptWalker^.MakePointVisible(Self.Data.LeprechaunCoords);
        end
      end;
      1: Antiban.RandomRotate();
      3: WriteLn('Failed to find leprechaun.');
    end;
  end;
end;

function TFarmPatch.GetState(): EPatchState;
label
  Inspect;
var
  Message: String;
  i: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit(EPatchState.FAILED);

  RSInterface.Close();
  Inventory.SetSelectedSlot(-1);

  if Self.Complete then
    Exit(EPatchState.COMPLETE);
  if Self.Skip then
    Exit(EPatchState.SKIP);

  if Minimap.InPOH then
    Exit(EPatchState.TELEPORT_TO);

  if not (ScriptWalker^.GetMyPos in Self.Data.MapCoords) then
    Exit(EPatchState.TELEPORT_TO);

  if not Self.Find then
    Exit(EPatchState.FAILED);

  if Self.Data.PatchType = EPatchType.BUSH then
    Exit(EPatchState.HARVEST_WHITEBERRIES);

  if Self.Data.PatchType = EPatchType.CACTUS then
    Exit(EPatchState.HARVEST_CACTUS);

  if Self.IsEmpty then
    Exit(EPatchState.PLANT);

  if Self.IsDiseased then
    Exit(EPatchState.DISEASED);

  if Self.IsDead then
    Exit(EPatchState.DEAD);

  if Inventory.IsFull then
    Exit(EPatchState.NOTE_ITEMS);

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.SearchBox))
  else
    Mouse.Move(Self.SearchBox);

  if Mainscreen.IsUpText(Self.HarvestUpText) then
    Exit(EPatchState.HARVEST);

  if Mainscreen.IsUpText('Dead') then
    Exit(EPatchState.DEAD);

  if Mainscreen.IsUpText('Cure') then
    Exit(EPatchState.DISEASED);

  if MainScreen.IsUpText('Inspect') then
  begin
    Mouse.Click(MOUSE_LEFT);
    goto Inspect;
  end;

  Mouse.Click(MOUSE_RIGHT);

  if ChooseOption.HasOption('Dead', True, False) then
    Exit(EPatchState.DEAD);

  if ChooseOption.HasOption(Self.HarvestUpText, True, False) then
    Exit(EPatchState.HARVEST);

  if ChooseOption.HasOption('Cure', True, False) then
    Exit(EPatchState.DISEASED);

  if ChooseOption.Select('Inspect') then
      goto inspect
  else
    Exit(EPatchState.FAILED);

  Inspect:
  if not WaitUntil(Chat.FindMessage('The soil'), 15, 10000) then
    Exit(EPatchState.FAILED);

  for i := 5 to 8 do
    Message += Chat.GetMessage(i);

  if Message.Contains('is empty') then
    Exit(EPatchState.PLANT);

  if Message.Contains('not been') then
  begin
    if (Self.Data.PatchType = EPatchType.FLOWER) and (not Farm.CompostFlowers) then
    begin
      WriteLn('Inspection shows un-composted flower patch at ' + Self.Data.Name + '; skipping per settings.');
      Self.Complete := True;
      Exit(EPatchState.COMPLETE);
    end;

    Exit(EPatchState.COMPOST);
  end;

  if Message.Contains('fully grown') then
    Exit(EPatchState.HARVEST);

  if Message.ContainsAll(['has been', 'growing in it']) then
    Exit(EPatchState.COMPLETE);

  if Message.Contains('dead') then
    Exit(EPatchState.DEAD);

  if Message.Contains('diseas') then
    Exit(EPatchState.DISEASED);

  Exit(EPatchState.FAILED);
end;

procedure TFarmRun.OnStart(); begin

end;

procedure TFarmRun.OnComplete(); begin

end;

function TRSChat.ChatUntilOptions(): Boolean;
var
  Timeout: TCountdown;
begin
  Timeout.Init(10000);

  while (not Timeout.IsFinished) and (not ('Select' in Self.GetChatTitle())) and Self.ClickContinue() do
    Wait(0, 2500, wdLeft);

  Result := 'Select' in Self.GetChatTitle();
end;

function TFarmRun.GetFarmRunesNeeded(): TRSItemArray;
var
  CanSBS, NeedsSBS: Boolean;
  SpellBook: ERSSpellBook;
  TmpRunes: TRSItemArray;
  i: Int32;
begin
  WriteLn('Getting runes needed for farm run.');
  WriteLn('Spellbook detected: ', SpellBook := Magic.GetSpellBook());

  CanSBS := (SpellBook = ERSSpellBook.LUNAR) and (Stats.GetLevel(ERSSkill.MAGIC) >= 96);

  if Self.CompostMethod = ECompostMethod.FERTILE_SOIL then
  begin
    if SpellBook <> ERSSpellBook.LUNAR then
      TerminateScript('Cannot use Fertile Spoil with your current spellbook.');

    if Stats.GetLevel(ERSSkill.MAGIC, True) < 83 then
      TerminateScript('You don''t have the required magic level for fertile soil.');

    TmpRunes += ['Nature rune', 'Astral rune', 'Earth rune'];
  end;

  if Self.ResurrectCrop then
  begin
    if not ((SpellBook = ERSSpellBook.ARCEUUS) or CanSBS) then
      TerminateScript('Cannot use Resurrect Crop with your current spellbook. Arceuss or Lunars and 96 magic required.');

    TmpRunes += ['Soul rune', 'Nature rune', 'Blood rune', 'Earth rune'];
    NeedsSBS := SpellBook = ERSSpellBook.LUNAR;
  end;

  for i := 0 to High(Self.Patches) do
  begin
    case Self.Patches[i].TravelMethod of
      ETravelMethod.CATHERBY_TELEPORT:
      begin
        if SpellBook <> ERSSpellBook.LUNAR then
          TerminateScript('Cannot use Catherby teleport with your current spellbook. Lunars required.');
        TmpRunes += ['Law rune', 'Astral rune', 'Water rune'];
      end;

      ETravelMethod.CAMELOT_TELEPORT:
      begin
        if not ((SpellBook = ERSSpellBook.STANDARD) or CanSBS) then
          TerminateScript('Cannot use Camelot teleport with your current spellbook. Standard or Lunars and 96 magic required.');

       TmpRunes += ['Law rune', 'Air rune'];
       NeedsSBS := SpellBook = ERSSpellBook.LUNAR;
      end;

      ETravelMethod.FENKENSTRAIN_TELEPORT:
      begin
        if not ((SpellBook = ERSSpellBook.ARCEUUS) or CanSBS) then
          TerminateScript('Cannot use Fenkenstrain teleport with your current spellbook. Arceuss or Lunars and 96 magic required.');

        TmpRunes += ['Law rune', 'Soul rune', 'Earth rune'];
        NeedsSBS := SpellBook = ERSSpellBook.LUNAR;
      end;

      ETravelMethod.HOUSE_TELEPORT:
      begin
        if not ((SpellBook = ERSSpellBook.STANDARD) or CanSBS) then
          TerminateScript('Cannot use House teleport with your current spellbook. Standard or Lunars and 96 magic required.');

        TmpRunes += ['Law rune', 'Air rune', 'Earth rune'];
        NeedsSBS := SpellBook = ERSSpellBook.LUNAR;
      end;
    end;
  end;

  if NeedsSBS then
    TmpRunes += ['Astral rune', 'Cosmic rune', 'Law rune'];

  Sort(TmpRunes);
  Result += TmpRunes[0];

  for i := 1 to High(TmpRunes) do
    if TmpRunes[i] <> Result[High(Result)] then
      Result += TmpRunes[i];
end;

procedure TFarmRun.TravelToGiantSeaweed();
var
  T: TCountdown;
  MyPos: TPoint;
  Attempts: int32;
  Item: TRSItem;
  B: TBox;
begin
  T.Init(ONE_MINUTE);

  while not (MyPos := ScriptWalker^.GetMyPos).InBox([1129, 5407, 1769, 5824]) and not T.IsFinished() do
  begin
    MyPos := ScriptWalker^.GetMyPos();

    if MyPos.InBox([8448, 2342, 9273, 2895]) then
    begin
      for Attempts := 1 to 3 do
      begin
        if not ScriptWalker^.AtTile([8840,2672], 16) then
          ScriptWalker^.WebWalk([8832,2672]);

        BargeAttendant.SelectOption(['Quick-Travel'], 10);

        if WaitUntil(ScriptWalker^.GetMyPos().InBox([9113, 908, 9467, 1266]), 15, 5000) then
          Break;
      end;
    end
    else
    if MyPos.InBox([9113, 908, 9467, 1266]) then
    begin
      for attempts := 1 to 3 do
      begin
        Wait(750,1000);
        BoatyShore.WalkSelectOption(['Travel '], 10);

        if WaitUntil(Chat.FindOption('Row out to sea', [CHAT_COLOR_BLACK]), 15, 5000) then
        begin
          B := ([146,431,371,435]);
          Mouse.Click(B, MOUSE_LEFT);

          if WaitUntil(ScriptWalker^.GetMyPos().InBox([9303, 530, 9657, 888]), 15, 5000) then
            Break;
        end;
      end;
    end
    else
    if MyPos.InBox([9303, 530, 9657, 888]) then
    begin
      for Attempts := 1 to 3 do
      begin
        Wait(750,1000);
        BoatyIsland.WalkSelectOption(['Dive '], 10);
        WaitUntil(Chat.FindOption('Dive and walk', [CHAT_COLOR_BLACK]) or Chat.FindOption('it would be easier', [CHAT_COLOR_BLACK]) or (MyPos := ScriptWalker^.GetMyPos()).InBox([1129, 5407, 1769, 5824]), 15, 10000);

        if Chat.FindOption('Dive and walk', [CHAT_COLOR_BLACK]) then begin
          B := ([67,399,442,403]);
          Mouse.Click(B, MOUSE_LEFT);
          WaitUntil(ScriptWalker^.GetMyPos().InBox([1129, 5407, 1769, 5824]) or Chat.FindOption('it would be easier', [CHAT_COLOR_BLACK]), 15, 10000);
        end;

        if (ScriptWalker^.GetMyPos()).InBox([1129, 5407, 1769, 5824]) then
          Break;

        if Chat.FindOption('it would be easier', [CHAT_COLOR_BLACK])then
          Chat.ClickContinue(True);

        if Chat.FindOption('dive anyway', [CHAT_COLOR_BLACK]) then
        begin
          B := ([120,412,401,421]);
          Mouse.Click(B, MOUSE_LEFT);

          if Chat.FindOption('airin', [CHAT_COLOR_BLACK])then
            Chat.ClickContinue(True);

          if WaitUntil(ScriptWalker^.GetMyPos().InBox([1129, 5407, 1769, 5824]), 15, 5000) then
            Break;
        end;
      end;
    end
    else
    begin
      Item := 'Digsite pendant (5)';
      Wait(250,500);
      if Inventory.ClickItem(Item, 'Rub') and WaitUntil(Chat.FindOption('Digsite', [CHAT_COLOR_BLACK]), 10, 10000) then
      begin
        B := ([241,396,279,406]);
        Mouse.Click(B, MOUSE_LEFT);
      end
      else
        Equipment.ClickItem(Item, 'Digsite');

      WaitUntil(ScriptWalker^.GetMyPos().InBox([8448, 2342, 9273, 2895]), 15, 10000);
    end;
  end;
end;

procedure TFarmRun.CleanGrimyHerbs();
var
  Slots: TIntegerArray;
  Slot: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if not Inventory.FindItems(GRIMY_HERBS, Slots) then
    Exit();

  for Slot in Slots do
  begin
    Mouse.Move(Inventory.GetSlotBox(slot));
    Mouse.Click(MOUSE_LEFT);

    if ('You need level' in Chat.GetMessage(7)) then
    begin
      Self.CleanHerbs := False;
      Self.LeprechaunItems.Add(GRIMY_HERBS);
      SetLength(Self.HarvestQuantities, Length(Self.LeprechaunItems));
      Exit();
    end;
  end;
end;

procedure TFarmRun.NoteItems();
var
  Slots, LepItems: TIntegerArray;
  Count, Slot, i: Int32;
  Items: TRSItemArray;
  PlayerBox: TBox;
  Item: TRSItem;
  LepPt: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if Self.CleanHerbs then
    Self.CleanGrimyHerbs();

  WriteLn('Noting items at ', Self.CurrentPatch.Data.Name);

  for i := 0 to High(LeprechaunItems) do
  begin
    if Inventory.FindItem(item := LeprechaunItems[i], slot) then
    begin
      Slots += Slot;
      Items += Item;
      LepItems += i;
    end
  end;

  if Slots.Len() < 1 then
    Exit();

  for i := 0 to High(Slots) do
  begin
    RSInterface.Close();

    if ScriptWalker^.GetMyPos = Self.CurrentPatch.Data.LeprechaunCoords then
    begin
      PlayerBox := Mainscreen.GetPlayerBox();
      PlayerBox.Y1 := PlayerBox.Y1 - Floor(PlayerBox.Height / 2);
      LepPT := PlayerBox.Middle;
    end
    else if not Self.CurrentPatch.FindLeprechaun(LepPT) then
      Exit();

    Count := Inventory.CountItem(Items[i]);
    Inventory.SetSelectedSlot(Slots[i]);

    if SRL.Dice(65) then
      Mouse.HumanMove(LepPT)
    else
      Mouse.Move(LepPT);

    if Mainscreen.IsUpText('Tool') then
      Mouse.Click(MOUSE_LEFT)
    else if not ChooseOption.Select('Tool') then
    begin
      WriteLn('Failed to choose option leprechaun.');
      Inventory.SetSelectedSlot(-1);
      Exit();
    end;

    if not Mainscreen.DidRedClick() then
    begin
      WriteLn('Failed to find red click.');
      Inventory.SetSelectedSlot(-1);
      Exit();
    end;

    if SRL.Dice(65) and (i <> High(Slots)) then
    begin
      Wait(187, 317);
      Mouse.Move(Inventory.GetSlotBox(Slots[i+1]));
    end
    else if SRL.Dice(65) then
      Mouse.RandomMovement();

    if WaitUntil((Inventory.CountItem(Items[i]) = 0), 15, 10000) then
      Self.HarvestQuantities[LepItems[i]] += Count;

    Minimap.WaitPlayerMoving();
  end;
  Inventory.SetSelectedSlot(-1);
end;

procedure TFarmRun.HandleDeadPatch(); begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if Self.ResurrectCrop then
  begin
    case Magic.GetSpellBook of
      ERSSpellBook.ARCEUUS:
        begin
          Magic.ClickSpell(ERSSpell.RESURRECT_CROPS);
          if Chat.FindMessage('to cast') then
          begin
            Self.ResurrectCrop := False;
            WriteLn('Out of runes for resurrect crop. Disabling.');
          end
        end;
    end;
  end;

  if Self.ResurrectCrop then
    Wait(100);

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)));

  if MainScreen.IsUpText('Dead') then
    Mouse.Click(MOUSE_LEFT)
  else if not ChooseOption.Select('Dead') then
  begin
    Mouse.RandomMovement();
    Exit();
  end;

  if not MainScreen.DidRedClick() then
    Exit();

  Wait(600, 800);
  Minimap.WaitPlayerMoving();
  Wait(600, 800);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if not WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue() or Self.CurrentPatch.IsEmpty), 15, 15000) then
    Exit();

  if Chat.HasContinue then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));

    if MainScreen.IsUpText('Dead') then
      Mouse.Click(MOUSE_LEFT)
    else if not ChooseOption.Select('Dead') then
    begin
      Mouse.RandomMovement();
      Exit();
    end;

    if not MainScreen.DidRedClick() then
      Exit();

    Wait(600, 800);
    Minimap.WaitPlayerMoving();
    Wait(600, 800);

    if not Self.CurrentPatch.Find(False) then
      Exit();

    WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue() or Self.CurrentPatch.IsEmpty), 15, 15000);
  end;

  Wait(250, 1000);
end;

procedure TFarmRun.HandleDiseasedPatch();
begin
  Self.CurrentPatch.Skip := True;
end;

procedure TFarmRun.WithdrawCompost();
var
  Boxes: TBoxArray := [[160, 210, 245, 245], [275, 210, 360, 245], [390, 210, 475, 245], [390, 210, 475, 245], [0, 0, 0, 0]];
  WithdrawAmt: Int32 := Round(Inventory.CountEmptySlots * 0.2) + 1;
  LeprechaunPt: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if not Self.CurrentPatch.FindLeprechaun(leprechaunPt) then
    Exit();

  Mouse.Move(leprechaunPt);

  if not ChooseOption.Select('Exchange') then
    Exit();

  if not WaitUntil(RSInterface.IsOpen(), 15, 15000) then
    Exit();

  if BankPin.IsOpen() then
    BankPin.Enter(Login.GetPlayer.Pin);

  if SRL.CountColor(CTS2(2154272, 1, 0.01, 0.01), Boxes[Self.CompostMethod]) = 0 then
  begin
    //TODO no green = no items
    //downgrade compost?
  end;

  Mouse.Move(boxes[Self.CompostMethod]);

  if WithdrawAmt = 1 then
    ChooseOption.Select('Remove-1')
  else if WithdrawAmt = 5 then
    ChooseOption.Select('Remove-5')
  else
  begin
    ChooseOption.Select('Remove-X');
    Chat.AnswerQuery('Enter amount', ToStr(WithdrawAmt), 5000);
  end;

  RSInterface.Close(True);
end;

procedure TFarmRun.DropBuckets();
var
  Tmp, Slots: TIntegerArray;
  i : Int32;
begin
  if not Inventory.FindItems(['Bucket'], Tmp) then
    Exit();

  for i := 0 to High(Tmp) do
  begin
    if SRL.CountColor(CTS2(4087132, 1, 3.61, 4.36), Inventory.GetSlotBox(Tmp[I])) > 2 then
      Continue;
    else
      Slots += Tmp[i];
  end;

  if Slots.Len < 1 then
    Exit();

  Inventory.ShiftDrop(Slots);
end;

procedure TFarmRun.CompostPatch();
var
  CompostArray: TStringArray := ['Compost', 'Supercompost', 'Ultracompost', 'Bottomless compost bucket', ''];
  CompostItem: TRSItem := CompostArray[Self.CompostMethod];
  Slot, Attempts: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) and (not Self.CompostFlowers) then
  begin
    WriteLn('Skipping compost at ' + Self.CurrentPatch.Data.Name + ' flower patch per settings.');
    Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if not Self.CurrentPatch.Find then
  begin
    WriteLn('Could not find patch to compost!');
    Exit();
  end;

  WriteLn('Composting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if (Self.CompostMethod <> ECompostMethod.FERTILE_SOIL) and (Inventory.GetSelectedSlot = -1) then
  begin
    if (not Inventory.FindItem(CompostItem, Slot)) and (Self.CompostMethod <> ECompostMethod.BOTTOMLESS) then
    begin
      WithdrawCompost();
      Inventory.FindItem(CompostItem, Slot);
      if not Self.CurrentPatch.Find then
      begin
        WriteLn('Could not find patch to compost!');
        Exit();
      end;
    end;

    if (Slot = -1) and (not (Inventory.FindItem(CompostItem, Slot))) then
      TerminateScript('Out of compost! Terminating.');
  end;

  if Self.CompostMethod = ECompostMethod.FERTILE_SOIL then
  begin
    if Magic.GetSpellBook <> ERSSpellBook.LUNAR then
    begin
      if SRL.Dice(80) then
        Antiban.LoseFocus
      else if SRL.Dice(50) then
        Antiban.RandomMouse
      else
        Magic.Open;

      Wait(130*ONE_SECOND);

      if Magic.GetSpellBook <> ERSSpellBook.LUNAR then
        TerminateScript('Not on the correct spellbook for fertilize soil!');
    end;

    Magic.ClickSpell(ERSSpell.FERTILE_SOIL);
  end else if (Inventory.GetSelectedSlot = -1) and (not Inventory.SetSelectedSlot(slot)) then
  begin
    WriteLn('Failed to select compost in inventory.');
    Exit();
  end;

  Wait(300, 500);

  for Attempts := 0 to 2 do
  begin
    if Attempts = 2 then
    begin
      WriteLn('Failed to find correct patch uptext while composting.');
      Antiban.RandomMouse();
      Wait(200, 500);
      Exit();
    end;

    if not Self.CurrentPatch.Find then
      Continue;

    if not Mainscreen.IsUpText(Self.CurrentPatch.PlantedUpText) then
    begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
      else
        Mouse.Move(Self.CurrentPatch.SearchBox);
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.PlantedUpText) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Break;
    end
    else if ChooseOption.Select(Self.CurrentPatch.PlantedUpText) then
      Break;
    Mouse.RandomMovement();
  end;

  if MainScreen.DidYellowClick then
  begin
    WriteLn('FOUND YELLOW CLICK!');
    Exit();
  end;

  if not WaitUntil((Chat.FindMessage('trea') or Chat.FindMessage('ming 2')), 50, 10000) then
  begin
    WriteLn('WaitUntil failed in composting step.');
    Exit();
  end;
  if SRL.Dice(40) and Self.CleanHerbs then
  begin
    Self.CleanGrimyHerbs();

  if SRL.Dice(80) then
    Self.NoteItems;
  end;

  Wait(600, 750);
  Self.DropBuckets;

  Wait(200, 400);
  Self.CurrentPatch.Complete := True;
end;

procedure TFarmRun.Plant();
var
  CompostArray: TStringArray := ['Compost', 'Supercompost', 'Ultracompost', 'Bottomless compost bucket', ''];
  CompostItem: TRSItem := compostArray[Self.CompostMethod];
  Slot, Attempts: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if not Self.CurrentPatch.Find() then
    Exit();

  if (Self.CurrentPatch.Data.PatchType = EPatchType.ALLOTMENT) and (Inventory.CountItemStack(Self.CurrentPatch.Seed) < 3) then
  begin
    Self.CurrentPatch.Skip := True;
    Exit();
  end;

  WriteLn('Planting ' + ToStr(Self.CurrentPatch.Seed) + ' at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.GetSelectedSlot = -1 then
  begin
    if not Inventory.FindItem(Self.CurrentPatch.Seed, Slot) then
    begin
      WriteLn('Couldn''t find seed in inventory.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;

    if not Inventory.SetSelectedSlot(Slot) then
    begin
      WriteLn('Failed to select seed in inventory.');
      Exit();
    end;
  end;

  for Attempts := 0 to 2 do
  begin
    if Attempts = 2 then
    begin
      WriteLn('Failed to find correct patch uptext or choose option while planting.');
      Inventory.SetSelectedSlot(-1);
      Antiban.RandomMouse();
      Wait(200, 400);
      Exit();
    end;

    if not Self.CurrentPatch.Find() then
      Continue;

    if not MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) or (Self.CurrentPatch.Data.PatchType = EPatchType.SEAWEED) then
    begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
      else
        Mouse.Move(Self.CurrentPatch.SearchBox);
    end;

    if (Self.CurrentPatch.Data.PatchType <> EPatchType.HERB) and (Self.CurrentPatch.PlantedUpText in MainScreen.GetUpText.After('>')) then
    begin
      if MainScreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
        Self.Harvest()
      else if (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) and (not Self.CompostFlowers) then
      begin
        WriteLn('Skipping compost at ' + Self.CurrentPatch.Data.Name + ' flower patch per settings.');
        Self.CurrentPatch.Complete := True;
      end else
        Self.CompostPatch();

      Exit();
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Break;
    end
    else if ChooseOption.Select(Self.CurrentPatch.EmptyUpText) then
      Break;

    Mouse.RandomMovement();
  end;

  if not MainScreen.DidRedClick() then
    Exit();

  if WaitUntil(Minimap.IsPlayerMoving, 17, Random(713, 809)) then
    while Minimap.IsPlayerMoving do
      Wait(75);

  if Chat.HasContinue() then
  begin
    if (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) and (not Self.CompostFlowers) then
      Self.CurrentPatch.Complete := True
    else
      Self.CompostPatch();
    Exit();
  end;

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if (Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER) or Self.CompostFlowers then
  begin
    if (Self.CompostMethod <> ECompostMethod.FERTILE_SOIL) then
    begin
      if Inventory.FindItem(CompostItem, Slot) then
        Inventory.SetSelectedSlot(Slot);

      Wait(78, 208);

      if SRL.Dice(95) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
      else
        Mouse.Move(Self.CurrentPatch.SearchBox);
    end;
  end;

  XPBar.EarnedXP();

  if WaitUntil(((not Self.CurrentPatch.IsEmpty) or XPBar.EarnedXP), 15, 10000) then
  begin
    Wait(338, 562);

    if (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) and (not Self.CompostFlowers) then
      Self.CurrentPatch.Complete := True
    else
      Self.CompostPatch();
  end;
end;

procedure TFarmRun.HarvestWait();
var
  T: TCountdown;
begin
  T.Init(300);

  if not (ScriptWalker^.GetMyPos in PatchData[EFarmPatch.PHASMATYS_HERB].MapCoords) then
  begin
    Wait(T.TimeRemaining);
    Exit();
  end;

  repeat
    if (Length(MainScreen.FindHitsplats(MainScreen.GetPlayerBox)) > 0) then
    begin
      WriteLn('Combat detected in Port Phasmatys. Running away.');
      T.Init(ONE_MINUTE);

      repeat
        ScriptWalker^.WebWalk([10030, 2320], 50);
      until (ScriptWalker^.GetMyPos.DistanceTo([10030, 2320]) <= 50) or T.IsFinished();

      Self.CurrentPatch.Skip := True;
      Break;
    end;
  until T.IsFinished();
end;

procedure TFarmRun.Harvest();
var
  HarvestTimer: TCountdown;
  Slot: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteLn('Harvesting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull or (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) then
    Self.NoteItems();

  Minimap.WaitPlayerMoving();

  if not Self.CurrentPatch.Find() then
    Exit();

  if not Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) or (Self.CurrentPatch.Data.PatchType = EPatchType.SEAWEED) then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  if Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
  begin
    Mouse.Click(MOUSE_LEFT);
  end
  else if not ChooseOption.Select(Self.CurrentPatch.HarvestUpText) then
  begin
    WriteLn('Failed to find harvest uptext or choose option.');
    Antiban.RandomRotate();
    Exit();
  end;

  if not Mainscreen.DidRedClick() then
  begin
    WriteLn('Failed to find red click.');
    Exit();
  end;

  if WaitUntil(Minimap.IsPlayerMoving, 17, Random(707, 803)) then
    while Minimap.IsPlayerMoving() do
      Wait(30);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if SRL.Dice(35) and Inventory.FindItem(Self.CurrentPatch.Seed, Slot) then
  begin
    Inventory.SetSelectedSlot(Slot);

    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  HarvestTimer.Init(4000);

  while not HarvestTimer.IsFinished() do
  begin

    if XPBar.EarnedXP() then
      HarvestTimer.Restart();

    if Inventory.IsFull() then
    begin
      Inventory.SetSelectedSlot(-1);
      Wait(532, 718);
      Self.NoteItems();
      Exit();
    end;

    if HarvestTimer.IsFinished() or Self.CurrentPatch.IsEmpty() then
    begin
      Plant();
      Exit();
    end;

    HarvestWait();

    if Self.CurrentPatch.Skip = True then
      Break;
  end;
end;

procedure TFarmRun.HarvestWhiteBerries();
var
  HarvestTimer: TCountdown;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteLn('Harvesting whiteberries at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull() then
    Self.NoteItems();

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving do
      Wait(175);

  if not Self.CurrentPatch.Find() then
    Exit();

  if not Mainscreen.IsUpText('Pick') then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  if Mainscreen.IsUpText('Clear') then
  begin
    Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if Mainscreen.IsUpText('Inspect') then
  begin
    Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if Mainscreen.IsUpText('Check-health') then
  begin
    Mouse.Click(MOUSE_LEFT);
    WaitUntil(XPBar.EarnedXP(), 15, 2600);
  end;

  if Mainscreen.IsUpText('Pick') then
    Mouse.Click(MOUSE_LEFT)
  else if not ChooseOption.Select('Pick', MOUSE_LEFT, True, False) then
  begin
    if ChooseOption.HasOption('Clear', True, False) then
      Self.CurrentPatch.Complete := True
    else
      WriteLn('Failed to find harvest uptext or choose option.');
  end;

  if not Mainscreen.DidRedClick() then
  begin
    WriteLn('Failed to find red click.');
    Exit();
  end;

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving do
      Wait(13, 199);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
  else
    Mouse.Move(Self.CurrentPatch.SearchBox);

  HarvestTimer.Init(4000);
  while not HarvestTimer.IsFinished do
  begin
    if XPBar.EarnedXP() then
      HarvestTimer.Restart();

    if Mainscreen.IsUpText('ear') then
    begin
      Self.CurrentPatch.Complete := True;
      Exit();
    end else if Inventory.IsFull then
    begin
      Inventory.SetSelectedSlot(-1);
      Self.NoteItems();
      HarvestWhiteBerries();
    end;
    Wait(300);
  end;
end;

procedure TFarmRun.HarvestCactus();
var
  HarvestTimer: TCountdown;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteLn('Harvesting cactus at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull() then
    Self.NoteItems();

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving() do
      Wait(13, 199);

  if not Self.CurrentPatch.Find() then
    Exit();

  if not Mainscreen.IsUpText('Pick') then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
  end;

  if Mainscreen.IsUpText('Clear') then
  begin
    Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if Mainscreen.IsUpText('Inspect') then
  begin
    Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if Mainscreen.IsUpText('Check-health') then
  begin
    Mouse.Click(MOUSE_LEFT);
    WaitUntil(XPBar.EarnedXP(), 15, 2600);
  end;

  if Mainscreen.IsUpText('Pick') then
    Mouse.Click(MOUSE_LEFT)
  else if MainScreen.IsUpText('Clear') then
  begin
    Self.CurrentPatch.Complete := True;
    Exit();
  end
  else if not ChooseOption.Select('Pick', MOUSE_LEFT, True, False) then
  begin
    if ChooseOption.HasOption('Clear', True, False) then
      Self.CurrentPatch.Complete := True
    else
      WriteLn('Failed to find harvest uptext or choose option.');
    Exit();
  end;

  if not Mainscreen.DidRedClick() then
  begin
    WriteLn('Failed to find red click.');
    Exit();
  end;

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving do
      Wait(13, 199);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));

  HarvestTimer.Init(4000);
  while not HarvestTimer.IsFinished do
  begin
    if XPBar.EarnedXP() then
      HarvestTimer.Restart();

    if Mainscreen.IsUpText('ear') then
    begin
      Self.CurrentPatch.Complete := True;
      Exit();
    end
    else if Inventory.IsFull() then
    begin
      Inventory.SetSelectedSlot(-1);
      Self.NoteItems();
      HarvestCactus();
    end;
    Wait(300);
  end;
end;

procedure TFarmRun.UsePOHSpiritTree(Location: String);
var
  Primary, Secondary, TPA: TPointArray;
  ATPA: T2DPointArray;
  Attempts: Int32;
begin

  if not WaitUntil(Minimap.InPOH, 15, 15000) then
  begin
    WriteLn('Not in POH!');
    Exit();
  end;

  for Attempts := 1 to 3 do
  begin
    if (SRL.FindColors(Primary, CTS2(1649718, 5, 0.15, 1.14), MainScreen.Bounds) = 0) or (SRL.FindColors(Secondary, CTS2(1720892, 10, 0.21, 1.42), MainScreen.Bounds) = 0) then
    begin
      if SRL.Dice(50) then
        MiniMap.SetCompassAngle(Random(106, 153))
      else
        MiniMap.SetCompassAngle(Random(209, 248));
      Continue;
    end;

    TPA := Primary.PointsInRangeOf(Secondary, 0, MainScreen.NormalizeDistance(38));
    TPA.Grow(MainScreen.NormalizeDistance(8));
    TPA.Erode(MainScreen.NormalizeDistance(6));

    if TPA = [] then
    begin
      if SRL.Dice(50) then
        MiniMap.SetCompassAngle(Random(106, 153))
      else
        MiniMap.SetCompassAngle(Random(209, 248));
    end;
  end;

  if TPA = [] then
  begin
    WriteLn('Failed to find spirit tree. Skipping.');
    Self.CurrentPatch.Skip := True;
    Exit();
  end;

  ATPA := TPA.Cluster(MainScreen.NormalizeDistance(18));
  ATPA.SortBySize();

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(ATPA[0].Mean, MainScreen.NormalizeDistance(20)))
  else
    Mouse.Move(SRL.RandomPoint(ATPA[0].Mean, MainScreen.NormalizeDistance(20)));

  if MainScreen.IsUpText('Spirit') then
    Mouse.Click(MOUSE_LEFT)
  else if not ChooseOption.Select('Travel') then
  begin
    WriteLn('Failed to find spirit tree uptext!');
    Self.CurrentPatch.Skip := True;
    Exit();
  end;

  if SRL.Dice(66) then
  begin
    Wait(718, 2168);
    case Location of
      'guild': KeyBoard.KeyDown(VK_B);
    end;
  end;

  if not WaitUntil(RSInterface.IsOpen(), 15, 10000) then
  begin
    WriteLn('Timed out waiting for spirit tree interface.');
    Exit();
  end;

  if not KeyBoard.IsKeyDown(VK_B) then
    KeyBoard.PressKey(VK_B);

  WaitUntil((not Minimap.InPOH), 15, 10000);
  KeyBoard.KeyUp(VK_B);
end;

procedure TFarmRun.TeleportTo(TravelMethod: ETravelMethod; ConfirmPos: Boolean);
label
  TELEPORT_COMPLETE;
var
  Spell: ERSSpell := ERSSpell.BAKE_PIE;
  Items: TRSItemArray;
  Item: TRSItem;
  B: TBox;
begin
  WriteLn('Teleporting to ' + Self.CurrentPatch.Data.Name);

  if not RSClient.IsLoggedIn() then
    Exit();

  Inventory.SetSelectedSlot(-1);

  if Minimap.InPOH then
  begin
    case TravelMethod of
      ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD,
      ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD,
      ETravelMethod.CON_CAPE_SPIRIT_TREE_GUILD:
        begin
          Self.UsePOHSpiritTree('guild');
          goto TELEPORT_COMPLETE;
        end;
    end;
  end;

  if ScriptWalker^.GetMyPos in Self.CurrentPatch.Data.MapCoords then
    Exit();

  case TravelMethod of
    ETravelMethod.ICY_BASALT:
      begin
        Item := 'Icy basalt';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Weiss');
      end;
    ETravelMethod.STONY_BASALT:
      begin
        Item := 'Stony basalt';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Stronghold');
      end;
    ETravelMethod.CATHERBY_TABLET:
      begin
        Item := 'Catherby teleport';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Break');
      end;
    ETravelMethod.CATHERBY_TELEPORT:
      begin
        Spell := ERSSpell.CATHERBY_TELEPORT;
        Wait(250,500);
        Magic.CastSpell(Spell, 'Cast');
      end;
    ETravelMethod.CAMELOT_TELEPORT:
      begin
        Spell := ERSSpell.CAMELOT_TELEPORT;
        Wait(250,500);
        Magic.CastSpell(Spell, 'Cast');
      end;
    ETravelMethod.CAMELOT_TABLET:
      begin
        Item := 'Camelot teleport';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Break');
      end;
    ETravelMethod.FENKENSTRAIN_TELEPORT:
      begin
        Spell := ERSSpell.FENKENSTRAINS_CASTLE_TELEPORT;
        Wait(250,500);
        Magic.ClickSpell(Spell);
      end;
    ETravelMethod.ECTOPHIAL:
      begin
        Item := 'Ectophial';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Empty');
        Wait(4000,5000);
      end;
    ETravelMethod.XERICS_TALISMAN:
      begin
        Item := 'Xeric''s talisman';
        Wait(250,500);
        if Inventory.ContainsItem('Xeric''s talisman') then
        begin
          Inventory.ClickItem(Item, 'Rub');
          WaitUntil(RSInterface.IsOpen(), 10, 5000);
          B := ([219,92,293,101]);
          Mouse.Click(B, MOUSE_LEFT);
        end
        else
          Equipment.ClickItem(Item, 'Xeric''s Glade');
      end;
    ETravelMethod.HOSIDIOUS_TABLET:
      begin
        Item := 'Hosidius teleport';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Break');
      end;
    ETravelMethod.HOUSE_TELEPORT:
      begin
        Item := 'Teleport to house';
        Wait(250,500);
        if Inventory.ContainsItem('Teleport to house') then
        begin
          Inventory.ClickItem(Item, 'Outside');
        end
        else
          Magic.CastSpell(ERSSpell.TELEPORT_TO_HOUSE, 'Outside');
      end;
     ETravelMethod.CON_CAPE_HOSIDIUS:
    begin
        Items := (['Construct. cape', 'Construct. cape(t)']);
        for Item in Items do
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Teleport') then
          Equipment.ClickItem(Item, 'Teleport');
        WaitUntil(RSInterface.IsOpen(), 10, 5000);
        B := ([235,144,278,148]);
        Mouse.Click(B, MOUSE_LEFT);
      end;
    ETravelMethod.FARMING_CAPE:
      begin
        Items := (['Farming cape', 'Farming cape(t)']);
        for Item in Items do
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Teleport') then
          Equipment.ClickItem(Item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_2:
      begin
        Item := 'Explorer''s ring 2';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Teleport') then
          Equipment.ClickItem(Item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_3:
      begin
        Item := 'Explorer''s ring 3';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Teleport') then
          Equipment.ClickItem(Item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_4:
      begin
        Item := 'Explorer''s ring 4';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Teleport') then
          Equipment.ClickItem(Item, 'Teleport');
      end;
    ETravelMethod.ARDY_CLOAK_1_BUSH:
      begin
        Item := 'Ardougne cloak 1';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Monastery Teleport') then
          Equipment.ClickItem(Item, 'Kandarin Monastery');
      end;
    ETravelMethod.ARDY_CLOAK_2:
      begin
        Item := 'Ardougne cloak 2';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Farm Teleport') then
          Equipment.ClickItem(Item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_2_BUSH:
      begin
        Item := 'Ardougne cloak 2';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Monastery Teleport') then
          Equipment.ClickItem(Item, 'Kandarin Monastery');
      end;
    ETravelMethod.ARDY_CLOAK_3:
      begin
        Item := 'Ardougne cloak 3';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Farm Teleport') then
          Equipment.ClickItem(Item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_3_BUSH:
      begin
        Item := 'Ardougne cloak 3';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Monastery Teleport') then
          Equipment.ClickItem(Item, 'Kandarin Monastery');
      end;
    ETravelMethod.ARDY_CLOAK_4:
      begin
        Item := 'Ardougne cloak 4';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Farm Teleport') then
          Equipment.ClickItem(Item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_4_BUSH:
      begin
        Item := 'Ardougne cloak 4';
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Monastery Teleport') then
          Equipment.ClickItem(Item, 'Kandarin Monastery');
      end;
    ETravelMethod.SKILLS_NECKLACE:
      begin
        Item := 'Skills necklace(6)';
        Wait(250,500);
        if Inventory.ContainsItem(item) then
        begin
          Inventory.ClickItem(Item, 'Rub');
          WaitUntil(RSInterface.IsOpen(), 10, 5000);
          B := ([219,155,295,165]);
          Mouse.Click(B, MOUSE_LEFT);
        end
        else
          Equipment.ClickItem(Item, 'Farming Guild');
      end;
    ETravelMethod.DIGSITE_TO_SEAWEED:
      begin
          Self.TravelToGiantSeaweed();
          Exit();
      end;
    ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD:
      begin
        Item := 'Teleport to house';
        Wait(250,500);
        Inventory.ClickItem(Item, 'Break');
      end;
    ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD:
      begin
        Spell := ERSSpell.TELEPORT_TO_HOUSE;
        Wait(250,500);
        Magic.CastSpell(Spell);
      end;
     ETravelMethod.CON_CAPE_SPIRIT_TREE_GUILD:
      begin
        Items := (['Construct. cape', 'Construct. cape(t)']);
        Wait(250,500);
        if not Inventory.ClickItem(Item, 'Tele to POH') then
          Equipment.ClickItem(Item, 'Tele to POH');
      end;
  end;

  Wait(800, 1000);

  if ('Ardougne' in Item) then
  begin
    if Chat.FindMessage('cape has recharged') then
    begin
      WriteLn('Out of ardy cape charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;
  end
  else if ('Explorer' in Item) then
  begin
    if Chat.FindMessage('ring recharges') then
    begin
      WriteLn('Out of explorer''s ring charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;
  end
  else if TravelMethod = ETravelMethod.XERICS_TALISMAN then
  begin
    if Equipment.ContainsItem('Xeric''s talisman (inert)') then
    begin
      WriteLn('Out of xeric''s talisman charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end
    else if ((not Equipment.ContainsItem('Xeric''s talisman')) and (not Inventory.ContainsItem('Xeric''s talisman'))) then
    begin
      WriteLn('No xeric''s talisman equipped. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;
  end
  else if spell <> ERSSpell.BAKE_PIE then
  begin
    if Chat.FindMessage('to cast') then
    begin
      WriteLn('Out of runes for ' + ToStr(spell) + '. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;
  end;

  if (TravelMethod = ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD) or (TravelMethod = ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD) or (TravelMethod = ETravelMethod.CON_CAPE_SPIRIT_TREE_GUILD) then
    Self.UsePOHSpiritTree('guild');

  TELEPORT_COMPLETE:
  if not ConfirmPos then
    Exit();

  if not WaitUntil((ScriptWalker^.GetMyPos in Self.CurrentPatch.Data.MapCoords), 10, 10000) then
    Exit();

  if Inventory.IsFull() then
    Self.NoteItems;
end;

procedure TFarmRun.Report();
begin
  WriteLn('Thanks to XJ and Student, we finished another farm run!');
  if not Self.CompostFlowers then
    WriteLn('Flower composting skipped per settings.');
end;

operator in(Left: TBox; Right: TBoxArray): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Right) do
    if Left = Right[i] then
      Exit(True);
end;

procedure TFarmRun.Init(StartWithRun: Boolean = False);
var
  RSW: TRSWalker;
  Tmp: TBoxArray;
  i: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  for i := 0 to High(Self.Patches) do
    if not (Self.Patches[i].Data.MapCoords in Tmp) then
      Tmp += Self.Patches[i].Data.MapCoords;

  LeprechaunItems := ['Guam leaf', 'Marrentill', 'Tarromin', 'Harralander', 'Ranarr weed', 'Toadflax',
                      'Irit leaf', 'Avantoe', 'Kwuarm', 'Snapdragon', 'Cadantine', 'Lantadyme',
                      'Dwarf weed', 'Torstol', 'Limpwurt root', 'Potato', 'Onion', 'Cabbage', 'Tomato', 'Sweetcorn',
                      'Strawberry', 'Watermelon', 'Snape grass', 'White berries', 'Potato cactus', 'Cactus spine', 'Giant seaweed'];

  if not Self.CleanHerbs then
    LeprechaunItems.Add(GRIMY_HERBS);

  if ScriptWalker = nil then
  begin
    RSW.SetupRegions(Tmp);
    RSW.AdaptiveWalk := True;
  end
  else
    ScriptWalker^.AddRegions(tmp);

  BoatyShore.SetupCoordinates([[9294,1075]]);
  BoatyShore.SetupUpText(['ravel']);
  BoatyShore.Finder.Colors += CTS2(6124929, 5, 0.15, 0.13);

  BoatyIsland.SetupCoordinates([[9463,704]]);
  BoatyIsland.SetupUpText(['ravel']);
  BoatyIsland.Finder.Colors += CTS2(5401465, 20, 0.02, 0.23);

  BargeAttendant.ShapeArray += [[2, 2, 7], 0];
  BargeAttendant.SetupCoordinates([[8840, 2663]]);
  BargeAttendant.SetupUpText(['uard']);
  BargeAttendant.Finder.Colors += CTS2(1911645, 6, 0.08, 0.27);

  Self.InactivityTimer.Init(6 * ONE_MINUTE);

  if StartWithRun then
    Self.ReadyTimer.Init(0)
  else
    Self.ReadyTimer.Init(Self.GetNextTime());

  SetLength(Self.HarvestQuantities, Length(LeprechaunItems));
end;

procedure UpdateSystemUpdateHud(const Message: String);
begin
  if SystemUpdateHudMessage = Message then
    Exit;

  SystemUpdateHudMessage := Message;

  if AgilityHud.Enabled then
    AgilityStatusHud_Update(AgilityHud);
end;

function IsPlayerBusyForSystemUpdate(): Boolean;
var
  PlayerBox: TBox;
begin
  Result := False;

  if FarmRunActive or BirdhouseRunActive then
    Exit(True);

  if not RSClient.IsLoggedIn() then
    Exit(False);

  if Minimap.IsPlayerMoving() then
    Exit(True);

  PlayerBox := Mainscreen.GetPlayerBox();
  Result := SRL.IsAnimating(PlayerBox, Mainscreen.NormalizeDistance(450), 350, 2);
end;

procedure SendSystemUpdateWebhook(const Message: String);
begin
  {$IF DECLARED(Discord)}
    {$IF DECLARED(ENABLEWEBHOOKS)}
    if ENABLEWEBHOOKS then
    begin
      try
        Discord.Webhook.Content := Message;
        Discord.Send();
      except
        WriteLn('[Discord] Failed to send system update notification.');
      end;
    end;
    {$ENDIF}
  {$ENDIF}
end;

procedure HandlePendingSystemUpdate();
var
  Reason: String;
  LogoutSucceeded: Boolean;
  RuntimeText: String;
  ThresholdText: String;
begin
  if not PendingSystemUpdateLogout then
    Exit;

  if not RSClient.IsLoggedIn() then
  begin
    TerminateScript('System update detected - safe logout completed');
    Exit;
  end;

  if SystemUpdateThresholdMinutes > 0 then
    ThresholdText := 'System update <= ' + IntToStr(SystemUpdateThresholdMinutes) + 'm'
  else
    ThresholdText := 'System update';

  if IsPlayerBusyForSystemUpdate() then
  begin
    if not SystemUpdateLogoutDelayedLogged then
    begin
      WriteLn('System update detected but player is busy. Waiting to logout safely once idle.');
      UpdateSystemUpdateHud(ThresholdText + ' - waiting for idle');
      SystemUpdateLogoutDelayedLogged := True;
    end;
    Exit;
  end;

  RuntimeText := SRL.MsToTime(GetTimeRunning(), Time_Short);
  Reason := 'System update detected - safe logout completed';

  UpdateSystemUpdateHud(ThresholdText + ' - logging out safely');
  WriteLn('System update detected while idle - logging out safely.');
  SendSystemUpdateWebhook('**SYSTEM UPDATE** Logging out safely (' + ThresholdText + '). Runtime: ' + RuntimeText);

  Logout.ClickLogout();
  LogoutSucceeded := WaitUntil(not RSClient.IsLoggedIn(), 250, 7500);

  PendingSystemUpdateLogout := False;

  if not LogoutSucceeded then
  begin
    WriteLn('Warning: attempted logout for system update but logout confirmation was not detected.');
    TerminateScript('System update detected - attempted logout (manual verification recommended)');
  end else
    TerminateScript(Reason);
end;

procedure CheckSystemUpdate();
const
  SYSTEM_UPDATE_CHECK_INTERVAL = 30000;
  SYSTEM_UPDATE_THRESHOLD_MINUTES = 15;
var
  Threshold: Int32;
  WarningText: String;
begin
  HandlePendingSystemUpdate();

  if not RSClient.IsLoggedIn() then
    Exit;

  if SystemUpdateCheckTimer.Length = 0 then
    SystemUpdateCheckTimer.Init(0);

  if not SystemUpdateCheckTimer.IsFinished() then
    Exit;

  SystemUpdateCheckTimer.Init(SYSTEM_UPDATE_CHECK_INTERVAL);

  Threshold := SYSTEM_UPDATE_THRESHOLD_MINUTES;

  if Chat.CheckSystemUpdate(Threshold) then
  begin
    SystemUpdateThresholdMinutes := Threshold;
    WarningText := 'System update in <= ' + IntToStr(Threshold) + 'm';

    if not SystemUpdateWarningShown then
    begin
      WriteLn('SYSTEM UPDATE WARNING: ' + WarningText + '! Preparing safe logout.');
      SystemUpdateWarningShown := True;
    end;

    UpdateSystemUpdateHud(WarningText + ' - preparing safe logout');
    PendingSystemUpdateLogout := True;
    SystemUpdateLogoutDelayedLogged := False;

    HandlePendingSystemUpdate();
  end
  else if not PendingSystemUpdateLogout then
  begin
    SystemUpdateWarningShown := False;
    SystemUpdateThresholdMinutes := 0;
    SystemUpdateLogoutDelayedLogged := False;
    UpdateSystemUpdateHud('');
  end;
end;

function RandomUIntRange(MinValue, MaxValue: UInt64): UInt64;
var
  Span: UInt64;
begin
  if MaxValue <= MinValue then
    Exit(MinValue);

  Span := MaxValue - MinValue;
  if Span >= UInt64(High(Int32)) then
    Span := UInt64(High(Int32) - 1);

  Result := MinValue + UInt64(Random(Int32(Span) + 1));
end;

function RandomIntRange(MinValue, MaxValue: Int32): Int32;
var
  Span: Int32;
begin
  if MaxValue <= MinValue then
    Exit(MinValue);

  Span := MaxValue - MinValue;
  Result := MinValue + Random(Span + 1);
end;

procedure ScheduleNextMiniBreak();
var
  MinGap, MaxGap: UInt64;
begin
  MinGap := MiniGapMinMs;
  MaxGap := MiniGapMaxMs;

  if MinGap = 0 then
    MinGap := MINI_GAP_MIN_MS_DEFAULT;

  if MaxGap < MinGap then
    MaxGap := MinGap;

  NextMiniBreakAt := GetTimeRunning() + RandomUIntRange(MinGap, MaxGap);
end;

procedure ScheduleNextPlannedBreak();
var
  BaseMs, Jitter: Int64;
  JitterPct: Int32;
begin
  if (not PlannedBreaksEnabled) or (BreakAfter <= 0) then
  begin
    NextPlannedBreakAt := 0;
    Exit;
  end;

  BaseMs := Int64(BreakAfter) * ONE_MINUTE;
  JitterPct := RandomIntRange(-PlannedCadenceJitterPct, PlannedCadenceJitterPct);
  Jitter := (BaseMs * JitterPct) div 100;
  BaseMs := BaseMs + Jitter;

  if BaseMs < Int64(ONE_MINUTE) then
    BaseMs := Int64(ONE_MINUTE);

  NextPlannedBreakAt := GetTimeRunning() + UInt64(BaseMs);
end;

procedure SendBreakWebhook(const Message: String);
begin
  if (Message = '') or (not WebhookEnabled) then
    Exit;

  {$IF DECLARED(Discord)}
    {$IF DECLARED(ENABLEWEBHOOKS)}
    if ENABLEWEBHOOKS and (Discord.HTTP <> 0) then
    begin
      try
        Discord.Webhook.ClearAll();
        Discord.Webhook.Content := Message;
        Discord.Send();
      except
        WriteLn('[Discord] Failed to send break notification: ' + GetExceptionMessage);
      end;
    end;
    {$ENDIF}
  {$ENDIF}
end;

procedure StartBreakEvent(const Kind: String; DurationMs: UInt64);
var
  DurationText, Message: String;
begin
  DurationText := SRL.MsToTime(DurationMs, Time_Short);
  LastBreakEventSummary := Kind + ' (' + DurationText + ')';
  LastBreakInProgress := True;
  LastBreakEventAt := GetTimeRunning();

  Message := 'Starting ' + Kind + ' break for ' + DurationText + '.';
  WriteLn(SRL.TimeStamp(), ':[Breaks]: ' + Message);
  SendBreakWebhook('**' + Kind + ' break** for ' + DurationText + '.');

  if AgilityHud.Enabled then
    AgilityStatusHud_Update(AgilityHud);
end;

procedure FinishBreakEvent(const Kind: String);
begin
  LastBreakInProgress := False;
  LastBreakEventAt := GetTimeRunning();
  WriteLn(SRL.TimeStamp(), ':[Breaks]: ' + Kind + ' break finished.');

  if AgilityHud.Enabled then
    AgilityStatusHud_Update(AgilityHud);
end;

function SafeToTakeBreak(): Boolean;
var
  PlayerBox: TBox;
begin
  if FarmRunActive or BirdhouseRunActive then
    Exit(False);

  if not RSClient.IsLoggedIn() then
    Exit(False);

  if Minimap.IsPlayerMoving() then
    Exit(False);

  PlayerBox := Mainscreen.GetPlayerBox();
  Result := not SRL.IsAnimating(PlayerBox, Mainscreen.NormalizeDistance(450), 350, 2);
end;

procedure PauseBreakTimers();
var
  NowMs: UInt64;
begin
  NowMs := GetTimeRunning();

  if not MiniBreakPaused then
  begin
    if (NextMiniBreakAt > NowMs) and (NextMiniBreakAt <> 0) then
      MiniBreakRemainingMs := NextMiniBreakAt - NowMs
    else
      MiniBreakRemainingMs := 0;
    MiniBreakPaused := True;
  end;

  if not PlannedBreakPaused then
  begin
    if (NextPlannedBreakAt > NowMs) and (NextPlannedBreakAt <> 0) then
      PlannedBreakRemainingMs := NextPlannedBreakAt - NowMs
    else
      PlannedBreakRemainingMs := 0;
    PlannedBreakPaused := True;
  end;
end;

procedure ResumeBreakTimers();
var
  NowMs: UInt64;
begin
  NowMs := GetTimeRunning();

  if MiniBreakPaused then
  begin
    if NextMiniBreakAt <> 0 then
    begin
      if MiniBreakRemainingMs > 0 then
        NextMiniBreakAt := NowMs + MiniBreakRemainingMs
      else
        NextMiniBreakAt := NowMs + UInt64(PLANNED_BREAK_RESUME_FUZZ_MS);
    end else
      ScheduleNextMiniBreak();

    MiniBreakPaused := False;
  end;

  if PlannedBreakPaused then
  begin
    if PlannedBreaksEnabled and (BreakAfter > 0) then
    begin
      if PlannedBreakRemainingMs > 0 then
        NextPlannedBreakAt := NowMs + PlannedBreakRemainingMs
      else
        NextPlannedBreakAt := NowMs + UInt64(PLANNED_BREAK_RESUME_FUZZ_MS);
    end else
      NextPlannedBreakAt := 0;

    PlannedBreakPaused := False;
  end;
end;

procedure MaybeDoMiniBreak();
var
  LenMs: UInt64;
begin
  if MiniBreakPaused or (NextMiniBreakAt = 0) then
    Exit;

  if GetTimeRunning() < NextMiniBreakAt then
    Exit;

  ScheduleNextMiniBreak();

  if (MiniBreakChancePct <= 0) or (Random(100) >= MiniBreakChancePct) then
    Exit;

  if not SafeToTakeBreak() then
    Exit;

  if MiniLenMinMs = 0 then
    MiniLenMinMs := MINI_LEN_MIN_MS_DEFAULT;
  if MiniLenMaxMs = 0 then
    MiniLenMaxMs := MINI_LEN_MAX_MS_DEFAULT;

  LenMs := RandomUIntRange(MiniLenMinMs, MiniLenMaxMs);
  if LenMs = 0 then
    Exit;

  StartBreakEvent('Mini', LenMs);
  InactivityTimer.Pause();
  try
    Wait(UInt32(LenMs));
    if Random(100) < 30 then
      Minimap.RotateWithinAngles(-15, 15);
  finally
    InactivityTimer.Resume();
  end;
  FinishBreakEvent('Mini');
end;

procedure MaybeDoPlannedBreak();
var
  LenMs: Int64;
  Jitter: Int64;
begin
  if (not PlannedBreaksEnabled) or PlannedBreakPaused then
    Exit;

  if (BreakAfter <= 0) or (BreakFor <= 0) then
  begin
    NextPlannedBreakAt := 0;
    Exit;
  end;

  if (NextPlannedBreakAt = 0) or (GetTimeRunning() < NextPlannedBreakAt) then
    Exit;

  if not SafeToTakeBreak() then
    Exit;

  LenMs := Int64(BreakFor) * ONE_MINUTE;
  Jitter := (LenMs * RandomIntRange(-PlannedLengthJitterPct, PlannedLengthJitterPct)) div 100;
  LenMs := LenMs + Jitter;

  if LenMs < Int64(ONE_MINUTE) then
    LenMs := Int64(ONE_MINUTE)
  else if LenMs > Int64(120 * ONE_MINUTE) then
    LenMs := Int64(120 * ONE_MINUTE);

  StartBreakEvent('Planned', UInt64(LenMs));
  InactivityTimer.Pause();
  try
    Logout.ClickLogout();
    Wait(UInt32(LenMs));
    if not Login.LoginPlayer() then
      TerminateScript('Failed to log in after planned break');
  finally
    InactivityTimer.Resume();
  end;
  FinishBreakEvent('Planned');

  ScheduleNextPlannedBreak();
end;

procedure MaybeHandleScheduledBreaks();
begin
  MaybeDoPlannedBreak();
  MaybeDoMiniBreak();
end;

procedure TFarmRun.Run();
var
  AntibanMinZ, AntibanMaxZ: Int32;
  State: EPatchState;
  FailedCount: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  FarmRunActive := True;
  PauseBreakTimers();
  try
    Antiban.DebugLn('Starting farm run.');
    Self.Runtime.Start();

    AntibanMinZ := Antiban.MinZoom;
    AntibanMaxZ := Antiban.MaxZoom;
    Antiban.MinZoom := 17;
    Antiban.MaxZoom := 23;
    Mainscreen.SetHighestPitch;
    Options.SetZoomLevel(Random(17, 23));

    Self.OnStart();

    Self.LastXPRead := XPBar.Read();
    Self.InactivityTimer.Restart();

    if not RSClient.IsLoggedIn() then
      Login.LoginPlayer();

    for Self.CurrentPatch in Self.Patches do
    begin
      if not RSClient.IsLoggedIn() then
        Login.LoginPlayer();

      repeat
        CheckSystemUpdate();

        State := Self.CurrentPatch.GetState();

        if FailedCount = 8 then
          State := EPatchState.SKIP;

        if State <> EPatchState.FAILED then
          FailedCount := 0;

        case State of
          EPatchState.HARVEST_WHITEBERRIES: Self.HarvestWhiteBerries;
          EPatchState.HARVEST_CACTUS: Self.HarvestCactus;
          EPatchState.HARVEST: Self.Harvest;
          EPatchState.PLANT: Self.Plant;
          EPatchState.COMPOST:
          begin
            if (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) and (not Self.CompostFlowers) then
            begin
              WriteLn('Skipping compost at ' + Self.CurrentPatch.Data.Name + ' flower patch per settings.');
              Self.CurrentPatch.Complete := True;
            end else
              Self.CompostPatch();
          end;
          EPatchState.DISEASED: Self.HandleDiseasedPatch;
          EPatchState.DEAD: Self.HandleDeadPatch;
          EPatchState.TELEPORT_TO: Self.TeleportTo(Self.CurrentPatch.TravelMethod, True);
          EPatchState.NOTE_ITEMS: Self.NoteItems;
          EPatchState.FAILED: Inc(failedCount);
          EPatchState.COMPLETE:
          begin
            WriteLn('Patch complete.');
            Inc(Self.PatchesCompleted);
            Break;
          end;
          EPatchState.SKIP:
          begin
            WriteLn('Skipping patch.');
            Inc(Self.PatchesSkipped);
            Break;
          end;
        end;

        if XPBar.EarnedXP() then
          InactivityTimer.Restart();

      until InactivityTimer.IsFinished();

      Self.CurrentPatch.Skip := Self.CurrentPatch.Complete := False;

      if Self.DoReport then
        Self.Report();
    end;

    if InactivityTimer.IsFinished() then
      TerminateScript('Terminating due to inactivity.');

    Inc(Self.RunsComplete);

    Antiban.MinZoom := AntibanMinZ;
    Antiban.MaxZoom := AntibanMaxZ;

    Self.OnComplete();

    Self.Runtime.Pause();

    Self.XPGained += XPBar.Read() - Self.LastXPRead;
    Self.Report();
  finally
    FarmRunActive := False;
    ResumeBreakTimers();
    CheckSystemUpdate();
  end;
end;

procedure ReleaseRealInput();
begin
  AgilityStatusHud_Clear();

  if RealInputBlocked then
  begin
    WriteDebug('Re-enabling real input.');
    RSClient.RemoteInput.EnableRealInput();
    WLSettings.RemoteInput.BlockInput := False;
    RealInputBlocked := False;
  end;
end;

procedure CleanupScript();
begin
  if ScriptCleanedUp then
    Exit;

  ScriptCleanedUp := True;

  try
    SendSessionSummary();
  except
    WriteDebug('Failed to send session summary during cleanup: ' + GetExceptionMessage);
  end;

  if Discord.HTTP <> 0 then
  begin
    try
      Discord.Free();
    except
      WriteDebug('Failed to free Discord client during cleanup: ' + GetExceptionMessage);
    end;
  end;

  ReleaseRealInput();
end;

procedure TerminateScript(Reason: String); override;
begin
  WriteLn(Reason);
  CleanupScript();
  inherited TerminateScript(Reason);
end;

procedure TFarmRun.DoFarmRun();
begin
  if not ReadyTimer.IsFinished() then
    Exit();

  Self.Run();

  ReadyTimer.Init(Self.GetNextTime());
end;

procedure AgilityGUI_OnBirdhouseRunCheckboxChanged(Sender: TObject);
var
  CheckBox: TCheckbox;
begin
  CheckBox := Sender;
  GUI.Form.GetTab('Birdhouse Settings').SetTabVisible(CheckBox.IsChecked());
end;

procedure AgilityGUI_OnFarmRunCheckboxChanged(Sender: TObject);
var
  CheckBox: TCheckbox;
begin
  CheckBox := Sender;
  GUI.Form.GetTab('Farm Run Settings').SetTabVisible(CheckBox.IsChecked());
end;

function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height:Double=0; Offx,Offy:Double=0): TRectangle; override;
var
  angle: Double;
  vec: Vector3;
begin
  Loc   := Minimap.Center + (Loc - Me);
  angle := Minimap.GetCompassAngle(False);
  vec   := Vec3(Loc.X,loc.Y).RotateXY(angle, Minimap.Center.X, Minimap.Center.Y);

  Result := Minimap.VectorToMSRect(vec + [-offx, -offy, height], 1, 1, angle);
end;

function AgilityGUI_CreateFarmRunSettings(): TTabSheet;
var
  Info: TLabel;
  HerbIdx, FlowerIdx: Int32;
begin
  GUI.Form.AddTab('Farm Run Settings');
  Result := GUI.Form.GetTab('Farm Run Settings');
  Result.SetToolTip('');

  with Info do
  begin
    Create(Result);
    SetLeft(30);
    SetTop(30);
    SetHeight(80);
    SetWidth(600);
    SetFontSize(10);
    SetToolTip('');
    SetCaption('If you have problems with the settings, check the script page for instructions.');
  end;

  with GUI.HosidiusHerbCheckbox do
  begin
    Create(Result);
    SetCaption('Hosidius Herb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(130));
  end;

  with GUI.HosidiusFlowerCheckbox do
  begin
    Create(Result);
    SetCaption('Hosidius Flower');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(110));
  end;

  with GUI.CatherbyHerbCheckbox do
  begin
    Create(Result);
    SetCaption('Catherby Herb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(90));
  end;

  with GUI.CatherbyFlowerCheckbox do
  begin
    Create(Result);
    SetCaption('Catherby Flower');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(70));
  end;

  with GUI.MagicSecateursCheckbox do
  begin
    Create(Result);
    SetCaption('Use Magic Secateurs');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(160));
  end;

  with GUI.RunePouchCheckbox do
  begin
    Create(Result);
    SetCaption('Use Rune Pouch');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(185));
  end;

  with GUI.BarbarianDibberCheckbox do
  begin
    Create(Result);
    SetCaption('Barbarian Seed Dibber unlocked');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(210));
  end;

  with GUI.FarmRunNowCheckbox do
  begin
    Create(Result);
    SetCaption('Start with a farm run');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(235));
  end;

  with GUI.CompostFlowersCheckbox do
  begin
    Create(Result);
    SetCaption('Compost flower patches');
    SetTooltip('When unchecked, flower patches will be planted without compost.');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(260));
  end;

  with GUI.CompostInput do
  begin
    Create(Result);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(70));
    AddItemArray(["Ultracompost", "Bottomless Compost"]);
    SetCaption('Compost:');
    HerbIdx := Ord(CompostMethod) - 2;
    if HerbIdx < 0 then
      HerbIdx := 0
    else if HerbIdx > 1 then
      HerbIdx := 1;
    SetItemIndex(HerbIdx);
  end;

  with GUI.HerbSeedCombo do
  begin
    Create(Result);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(110));
    SetCaption('Herb Seed:');
    SetStyle(csDropDownList);
    AddItemArray(HERB_SEEDS);
    HerbIdx := GetSeedIndex(HERB_SEEDS, SavedHerbSeedName);
    if HerbIdx < 0 then
      HerbIdx := GetSeedIndex(HERB_SEEDS, 'Ranarr seed');
    if HerbIdx < 0 then
      HerbIdx := 0;
    SetItemIndex(HerbIdx);
  end;

  with GUI.FlowerSeedCombo do
  begin
    Create(Result);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(150));
    SetCaption('Flower Seed:');
    SetStyle(csDropDownList);
    AddItemArray(FLOWER_SEEDS);
    FlowerIdx := GetSeedIndex(FLOWER_SEEDS, SavedFlowerSeedName);
    if FlowerIdx < 0 then
      FlowerIdx := GetSeedIndex(FLOWER_SEEDS, 'Limpwurt seed');
    if FlowerIdx < 0 then
      FlowerIdx := 0;
    SetItemIndex(FlowerIdx);
  end;
end;

procedure AgilityGUI_LoadSettings();
var
  Username: String;
  CourseIdx, CompostIdx: Int32;
begin
  SavedHerbSeedName := 'Ranarr seed';
  SavedFlowerSeedName := 'Limpwurt seed';
  if BankTab < 0 then
    BankTab := 0
  else if BankTab > 9 then
    BankTab := 9;
  Course := DRAYNOR_ROOF;
  CompostMethod := ULTRA;

  Username := AgilityGUI_GetActiveUsername();
  if Username = '' then
  begin
    WriteDebug('[Agility GUI] No active login username; using default GUI settings.');
    Exit;
  end;

  try
    BankTab := StrToIntDef(ReadINI(Username + ' AgilityWithBH', 'BankTab', AGILITY_INI_FILE), BankTab);
    if BankTab < 0 then
      BankTab := 0
    else if BankTab > 9 then
      BankTab := 9;

    CourseIdx := StrToIntDef(ReadINI(Username + ' AgilityWithBH', 'Course', AGILITY_INI_FILE), Ord(Course));
    if CourseIdx < 0 then
      CourseIdx := 0
    else if CourseIdx > Ord(High(ECourse)) then
      CourseIdx := Ord(High(ECourse));
    Course := ECourse(CourseIdx);

    DoBirdhouseRuns := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'DoBirdhouseRuns', AGILITY_INI_FILE), DoBirdhouseRuns);
    DoFarmRuns := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'DoFarmRuns', AGILITY_INI_FILE), DoFarmRuns);
    FarmRunNow := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'FarmRunNow', AGILITY_INI_FILE), FarmRunNow);
    CompostFlowers := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'CompostFlowers', AGILITY_INI_FILE), CompostFlowers);

    SavedHerbSeedName := ReadINI(Username + ' AgilityWithBH', 'HerbSeed', AGILITY_INI_FILE);
    if SavedHerbSeedName = '' then
      SavedHerbSeedName := 'Ranarr seed';

    SavedFlowerSeedName := ReadINI(Username + ' AgilityWithBH', 'FlowerSeed', AGILITY_INI_FILE);
    if SavedFlowerSeedName = '' then
      SavedFlowerSeedName := 'Limpwurt seed';

    CompostIdx := StrToIntDef(ReadINI(Username + ' AgilityWithBH', 'CompostIndex', AGILITY_INI_FILE), Ord(CompostMethod) - 2);
    if CompostIdx < 0 then
      CompostIdx := 0
    else if CompostIdx > 1 then
      CompostIdx := 1;
    CompostMethod := ECompostMethod(CompostIdx + 2);

    WebhookURL := ReadINI(Username + ' AgilityWithBH', 'WebhookURL', AGILITY_INI_FILE);
    SendHourlyReports := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'SendHourlyReports', AGILITY_INI_FILE), SendHourlyReports);
    SendSessionSummaryReports := StrToBoolDef(ReadINI(Username + ' AgilityWithBH', 'SendSessionSummaryReports', AGILITY_INI_FILE), SendSessionSummaryReports);
  except
    on E: Exception do
      WriteDebug('[Agility GUI] Failed to load saved settings: ' + E.Message);
  end;
end;

function AgilityGUI_GetActiveUsername(): String;
var
  Player: TRSLoginPlayer;
begin
  Result := '';

  try
    if (Login.PlayerIndex >= 0) and (Login.PlayerIndex <= High(Login.Players)) then
      Result := Login.Players[Login.PlayerIndex].User;

    if Result = '' then
    begin
      Player := Login.GetPlayer();
      Result := Player.User;
    end;
  except
    Result := '';
  end;

  if Result = '' then
    Exit;
end;

procedure AgilityGUI_SaveSettingsToIni();
var
  Username, HerbSeedName, FlowerSeedName, SavedWebhook: String;
  CourseIdx, CompostIdx, SavedBankTab: Int32;
  SavedBirdhouseRuns, SavedFarmRuns, SavedFarmRunNow, SavedCompostFlowers,
  SavedHourlyReports, SavedSessionSummary: Boolean;
begin
  Username := AgilityGUI_GetActiveUsername();
  if Username = '' then
  begin
    WriteDebug('[Agility GUI] No active login username; skipping INI save.');
    Exit;
  end;

  try
    if GUI.BankTabInput.Edit <> nil then
      SavedBankTab := GUI.BankTabInput.GetText().ExtractInteger()
    else
      SavedBankTab := BankTab;

    if SavedBankTab < 0 then
      SavedBankTab := 0
    else if SavedBankTab > 9 then
      SavedBankTab := 9;

    if GUI.CourseInput.ComboBox <> nil then
      CourseIdx := GUI.CourseInput.GetItemIndex()
    else
      CourseIdx := Ord(Course);
    if CourseIdx < 0 then
      CourseIdx := 0
    else if CourseIdx > Ord(High(ECourse)) then
      CourseIdx := Ord(High(ECourse));

    if GUI.CompostInput.ComboBox <> nil then
      CompostIdx := GUI.CompostInput.GetItemIndex()
    else
      CompostIdx := Ord(CompostMethod) - 2;
    if CompostIdx < 0 then
      CompostIdx := 0
    else if CompostIdx > 1 then
      CompostIdx := 1;

    if GUI.HerbSeedCombo.ComboBox <> nil then
      HerbSeedName := GUI.HerbSeedCombo.GetText()
    else
      HerbSeedName := SavedHerbSeedName;
    if HerbSeedName = '' then
      HerbSeedName := 'Ranarr seed';

    if GUI.FlowerSeedCombo.ComboBox <> nil then
      FlowerSeedName := GUI.FlowerSeedCombo.GetText()
    else
      FlowerSeedName := SavedFlowerSeedName;
    if FlowerSeedName = '' then
      FlowerSeedName := 'Limpwurt seed';

    if GUI.WebhookInput.Edit <> nil then
      SavedWebhook := GUI.WebhookInput.GetText()
    else
      SavedWebhook := WebhookURL;

    if GUI.BirdhouseCheckbox.CheckBox <> nil then
      SavedBirdhouseRuns := GUI.BirdhouseCheckbox.IsChecked()
    else
      SavedBirdhouseRuns := DoBirdhouseRuns;

    if GUI.FarmCheckbox.CheckBox <> nil then
      SavedFarmRuns := GUI.FarmCheckbox.IsChecked()
    else
      SavedFarmRuns := DoFarmRuns;

    if GUI.FarmRunNowCheckbox.CheckBox <> nil then
      SavedFarmRunNow := GUI.FarmRunNowCheckbox.IsChecked()
    else
      SavedFarmRunNow := FarmRunNow;

    if GUI.CompostFlowersCheckbox.CheckBox <> nil then
      SavedCompostFlowers := GUI.CompostFlowersCheckbox.IsChecked()
    else
      SavedCompostFlowers := CompostFlowers;

    if GUI.HourlyReportCheckbox.CheckBox <> nil then
      SavedHourlyReports := GUI.HourlyReportCheckbox.IsChecked()
    else
      SavedHourlyReports := SendHourlyReports;

    if GUI.SessionSummaryCheckbox.CheckBox <> nil then
      SavedSessionSummary := GUI.SessionSummaryCheckbox.IsChecked()
    else
      SavedSessionSummary := SendSessionSummaryReports;

    WriteINI(Username + ' AgilityWithBH', 'BankTab', IntToStr(SavedBankTab), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'Course', IntToStr(CourseIdx), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'DoBirdhouseRuns', BoolToStr(SavedBirdhouseRuns, 'true', 'false'), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'DoFarmRuns', BoolToStr(SavedFarmRuns, 'true', 'false'), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'FarmRunNow', BoolToStr(SavedFarmRunNow, 'true', 'false'), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'CompostFlowers', BoolToStr(SavedCompostFlowers, 'true', 'false'), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'HerbSeed', HerbSeedName, AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'FlowerSeed', FlowerSeedName, AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'CompostIndex', IntToStr(CompostIdx), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'WebhookURL', SavedWebhook, AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'SendHourlyReports', BoolToStr(SavedHourlyReports, 'true', 'false'), AGILITY_INI_FILE);
    WriteINI(Username + ' AgilityWithBH', 'SendSessionSummaryReports', BoolToStr(SavedSessionSummary, 'true', 'false'), AGILITY_INI_FILE);

    BankTab := SavedBankTab;
    Course := ECourse(CourseIdx);
    CompostMethod := ECompostMethod(CompostIdx + 2);
    WebhookURL := SavedWebhook;
    DoBirdhouseRuns := SavedBirdhouseRuns;
    DoFarmRuns := SavedFarmRuns;
    FarmRunNow := SavedFarmRunNow;
    CompostFlowers := SavedCompostFlowers;
    SendHourlyReports := SavedHourlyReports;
    SendSessionSummaryReports := SavedSessionSummary;
    SavedHerbSeedName := HerbSeedName;
    SavedFlowerSeedName := FlowerSeedName;
  except
    on E: Exception do
      WriteDebug('[Agility GUI] Failed to save settings: ' + E.Message);
  end;
end;

procedure AgilityGUI_FormCloseHandler(Sender: TObject; var CloseAction: TCloseAction);
begin
  AgilityGUI_SaveSettingsToIni();
  TerminateScript('GUI closed by user.');
end;

procedure AgilityGUI_Run();
var
  Tab: TTabSheet;
begin
  GUI.Form.Setup('Agility', Point(800, 500), False);
  GUI.Form.Form.SetOnClose(@AgilityGUI_FormCloseHandler);
  GUI.Form.Start.SetOnClick(@AgilityGUI_StartScript);
  GUI.Form.AddTab('Settings');

  Tab := GUI.Form.GetTab('Settings');
  Tab.SetTooltip('');

  if BreakAfter <= 0 then
    BreakAfter := 90;

  if BreakFor <= 0 then
    BreakFor := 15;

  with GUI.BankTabInput do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(110));
    SetCaption('Bank tab:');
    SetText(ToStr(BankTab));
  end;

  with GUI.PlannedBreaksCheckbox do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(135));
    SetCaption('Enable planned breaks');
    SetChecked(PlannedBreaksEnabled);
    SetToolTip('Takes a logout break every X minutes for Y minutes.');
  end;

  with GUI.BreakAfterInput do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(160));
    SetCaption('Planned break every (min):');
    SetText(ToStr(BreakAfter));
    SetToolTip('Minutes between planned breaks when enabled.');
  end;

  with GUI.BreakForInput do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(210));
    SetCaption('Planned break length (min):');
    SetText(ToStr(BreakFor));
    SetToolTip('Approximate duration of each planned break.');
  end;

  with GUI.AntibanNote do
  begin
    Create(Tab);
    SetCaption('Always-on antiban: slower reaction times, ambient waits, and micro-breaks are built in.');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(270));
    SetWidth(TControl.AdjustToDPI(320));
    SetWordWrap(True);
  end;

  with GUI.BirdhouseCheckbox do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(270));
    SetCaption('Do birdhouse runs');
    SetToolTip('');
    SetChecked(DoBirdhouseRuns);
    CheckBox.SetOnChange(@AgilityGUI_OnBirdhouseRunCheckboxChanged);
  end;

  with GUI.FarmCheckbox do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(295));
    SetCaption('Do farm runs');
    SetToolTip('');
    SetChecked(DoFarmRuns);
    CheckBox.SetOnChange(@AgilityGUI_OnFarmRunCheckboxChanged);
  end;

  with GUI.FoodInput do
  begin
    Create(Tab);
    SetCaption('Food:');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(210));
    AddItemArray(["Salmon", "Tuna", "Lobster", "Bass", "Shark", "Manta ray"]);
  end;

  with GUI.ScriptTitle do
  begin
    Create(Tab);
    SetFontSize(11);
    SetCaption('Script page and instructions:');
    SetLeft(380);
    SetTop(TControl.AdjustToDPI(410));
    SetWidth(200);
  end;

  with GUI.ScriptInfo do
  begin
    Create(Tab);
    SetCaption('https://waspscripts.com/scripts/agility-with-bh-and-farm-runs-by-nll');
    SetFontColor($FF0000);
    SetLeft(380);
    SetTop(TControl.AdjustToDPI(435));
    SetWidth(200);
    setOnClick(@OpenLink);
    setCursor(crHandPoint);
  end;

  with GUI.CourseInput do
  begin
    Create(Tab);
    SetCaption('Course:');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(160));
    AddItemArray(["Draynor Village", "Varrock", "Falador", "Seers' Village", "Ardougne"]);
    SetItemIndex(Ord(Course));
  end;

  with GUI.SleepCheckbox do
  begin
    Create(Tab);
    SetCaption('Take sleeps');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(295));
    SetToolTip('Will go to sleep at approximately 12PM your local time for 6 hours.');
    SetChecked(TakeSleeps);
  end;

  with GUI.BlockInputCheckbox do
  begin
    Create(Tab);
    SetCaption('Block Real Input');
    SetToolTip('If this is checked, you can not manually interact with the client');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(320));
    SetChecked(True);
  end;

  with GUI.WebhookInput do
  begin
    Create(Tab);
    SetCaption('Discord webhook:');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(350));
    SetWidth(TControl.AdjustToDPI(320));
    SetToolTip('Optional: paste a Discord webhook URL to enable hourly and session reports.');
    SetText(WebhookURL);
  end;

  with GUI.HourlyReportCheckbox do
  begin
    Create(Tab);
    SetCaption('Send hourly report');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(320));
    SetChecked(SendHourlyReports);
    SetToolTip('Posts an hourly progress embed when a webhook is configured.');
  end;

  with GUI.SessionSummaryCheckbox do
  begin
    Create(Tab);
    SetCaption('Send session summary');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(345));
    SetChecked(SendSessionSummaryReports);
    SetToolTip('Posts a summary with screenshot when the script stops.');
  end;

  GUI.Form.CreateAccountManager(Tab);
  GUI.Form.CreateBirdhouseRunSettings();
  AgilityGUI_CreateFarmRunSettings();

  if GUI.BirdhouseCheckbox.CheckBox <> nil then
    AgilityGUI_OnBirdhouseRunCheckboxChanged(GUI.BirdhouseCheckbox.CheckBox);
  if GUI.FarmCheckbox.CheckBox <> nil then
    AgilityGUI_OnFarmRunCheckboxChanged(GUI.FarmCheckbox.CheckBox);

  GUI.Form.Run();
end;

procedure OnSleepStart(Task: PSleepTask);
var
  T: PSleepTask;
begin
  InactivityTimer.Pause();
  PauseBreakTimers();
  T := Task;
end;

procedure OnSleepEnd(Task: PSleepTask);
var
  T: PSleepTask;
begin
  ResumeBreakTimers();
  InactivityTimer.Resume();
  T := Task;
end;

function TRSLogin.LoginPlayer(): Boolean; override;
var
  attempts, world: Int32;
  timeout: UInt64;
  player: TRSLoginPlayer;
  isLauncher: Boolean;
  lobbyTimeout : TCountdown;
begin
  lobbyTimeout.Init(5000);
  while Self.FindText('CLICK HERE TO PLAY') do begin
    if Self.ClickText('CLICK HERE TO PLAY') then
      Exit(RSClient.IsLoggedIn(5000));

    Mouse.Move(Box(Mouse.Position(), 10, 10), True);

    if lobbyTimeout.IsFinished then
      Exit;
  end;

  if Self.ClickText('CLICK HERE TO PLAY') then
    Exit(RSClient.IsLoggedIn(5000));

  Self.DebugLn('Logging in player');

  timeout := GetTickCount() + 40000;
  while not Self.IsReady() do
  begin
    if Self.HandleDialogs() then
      Wait(500);

    if GetTickCount() > timeout then
    begin
      Self.DebugLn('Timed out waiting for the loginscreen to be ready.');
      Exit;
    end;
  end;

  isLauncher := Self.UsingLauncher();

  if isLauncher then
    Self.DebugLn('Jagex Launcher login detected.')
  else
  begin
    Self.DebugLn('Legacy login detected.');
    player := Self.GetPlayer();
    if (player.User = '') or (player.Password = '') then
      Self.Fatal('Player has no username or password');
  end;

  while Self.IsOpen() and (attempts < 10) do
  begin
    Self.DebugLn('Attempt ' + ToString(attempts + 1));

    if player.Worlds <> [] then
      if not (Self.GetCurrentWorld() in player.Worlds) or SRL.Dice(30) then
      begin
        world := Player.Worlds[Random(Length(Player.Worlds))];
        if (not Self.SwitchToWorld(world)) then
          Exit;
      end;

    if Self.HandleDialogs() then
      Wait(500);

    if Self.DoLogin(player, isLauncher) and not Self.WaitLoginMessage() then
      Exit;

    Inc(attempts);
  end;

  Result := Self.EnterGame();
end;

procedure AgilityGUI_StartScript(Sender: TObject);
var
  HerbIdx, FlowerIdx: Int32;
begin
  DoBirdhouseRuns := GUI.BirdhouseCheckbox.IsChecked();
  TakeSleeps := GUI.SleepCheckbox.IsChecked();
  DoFarmRuns := GUI.FarmCheckbox.IsChecked();
  if GUI.BlockInputCheckbox <> nil then
    BlockInput := GUI.BlockInputCheckbox.IsChecked()
  else
    BlockInput := True;
  WebhookURL := GUI.WebhookInput.GetText();
  SendHourlyReports := GUI.HourlyReportCheckbox.IsChecked();
  SendSessionSummaryReports := GUI.SessionSummaryCheckbox.IsChecked();
  PlannedBreaksEnabled := GUI.PlannedBreaksCheckbox.IsChecked();
  BreakFor := GUI.BreakForInput.GetText().ExtractInteger();
  if BreakFor <= 0 then
  begin
    BreakFor := 15;
    GUI.BreakForInput.SetText(ToStr(BreakFor));
  end;
  BreakAfter := GUI.BreakAfterInput.GetText().ExtractInteger();
  if BreakAfter <= 0 then
  begin
    BreakAfter := 90;
    GUI.BreakAfterInput.SetText(ToStr(BreakAfter));
  end;
  PlannedBreaksEnabled := PlannedBreaksEnabled and (BreakAfter > 0) and (BreakFor > 0);
  BankTab := GUI.BankTabInput.GetText().ExtractInteger();
  if BankTab < 0 then
    BankTab := 0
  else if BankTab > 9 then
    BankTab := 9;
  GUI.BankTabInput.SetText(ToStr(BankTab));
  Food := GUI.FoodInput.GetText();
  Course := ECourse(GUI.CourseInput.GetItemIndex());

  if DoFarmRuns then
  begin
    CompostMethod := ECompostMethod(GUI.CompostInput.GetItemIndex() + 2);
    CatherbyHerb := GUI.CatherbyHerbCheckbox.IsChecked();
    CatherbyFlower := GUI.CatherbyFlowerCheckbox.IsChecked();
    HosidiusHerb := GUI.HosidiusHerbCheckbox.IsChecked();
    HosidiusFlower := GUI.HosidiusFlowerCheckbox.IsChecked();
    UseMagicSecateurs := GUI.MagicSecateursCheckbox.IsChecked();
    UseRunePouch := GUI.RunePouchCheckbox.IsChecked();
    BarbarianDibber := GUI.BarbarianDibberCheckbox.IsChecked();
    FarmRunNow := GUI.FarmRunNowCheckbox.IsChecked();
    CompostFlowers := GUI.CompostFlowersCheckbox.IsChecked();
    Seed := EnsureSeedInList(HERB_SEEDS, GUI.HerbSeedCombo.GetText(), 'Ranarr seed');
    FlowerSeed := EnsureSeedInList(FLOWER_SEEDS, GUI.FlowerSeedCombo.GetText(), 'Limpwurt seed');

    HerbIdx := GetSeedIndex(HERB_SEEDS, Seed);
    if HerbIdx < 0 then
      HerbIdx := 0;
    GUI.HerbSeedCombo.SetItemIndex(HerbIdx);

    FlowerIdx := GetSeedIndex(FLOWER_SEEDS, FlowerSeed);
    if FlowerIdx < 0 then
      FlowerIdx := 0;
    GUI.FlowerSeedCombo.SetItemIndex(FlowerIdx);
  end;

  AgilityGUI_SaveSettingsToIni();

  GUI.Form.StartScript(Sender);
end;

procedure SetGameSettings();
begin
  if not InRange(Options.GetZoomLevel(), 0, 6) then
    Options.SetZoomLevel(Random(0, 6));

  if ChatButtons.GetActive() <> ERSChatButton.ALL_CHAT then
    ChatButtons.Open(ERSChatButton.ALL_CHAT);

  if not Inventory.IsOpen() then
    Inventory.Open();
end;

procedure PauseTimer(Task: PBreakTask);
var
  T: PBreakTask;
begin
  InactivityTimer.Pause();
  T := Task;
end;

procedure ResumeTimer(Task: PBreakTask);
var
  T: PBreakTask;
begin
  InactivityTimer.Resume();
  T := Task;
end;

procedure RandomWait();
begin
  if SRL.Dice(10) then
    WaitEx(4000, 3850)
  else
    WaitEx(1000, 850);
end;

procedure AB_Reaction(minMS, maxMS: Int32);
begin
  Wait(SRL.NormalRange(minMS, maxMS));
end;

procedure AB_MicroIdle();
begin
  // Fire one tiny behavior at low probability (no zoom fiddling to avoid breaking loops)
  if SRL.Dice(AB_ROTATE_CHANCE) then
    Antiban.RandomRotate()
  else if SRL.Dice(AB_RIGHTCLICK_CHANCE) then
    Antiban.RandomRightClick()
  else if SRL.Dice(AB_KEYBOARD_CHANCE) then
    Antiban.RandomKeyboard()
  else if SRL.Dice(AB_LOSEFOCUS_CHANCE) then
    Antiban.LoseFocus(SRL.NormalRange(600, 1800));
end;

procedure NP_MarkProgress();
begin
  NP_LastProgressTime := GetTickCount();
end;

procedure NP_CheckAndRecover();
var
  dt: UInt64;
begin
  if NP_LastProgressTime = 0 then Exit;

  dt := GetTickCount() - NP_LastProgressTime;
  if dt >= (NP_MINUTES_NO_PROGRESS * ONE_MINUTE) then
  begin
    if (GetTickCount() - NP_LastLog) > NP_LOG_EVERY then
    begin
      WriteLn('[Failsafe] No progress for ', dt div 1000, 's. Soft reset.');
      NP_LastLog := GetTickCount();
    end;

    Antiban.RandomRotate();
    Antiban.LoseFocus(SRL.NormalRange(600, 1800));
    Wait(SRL.NormalRange(NP_SHORT_BREAK_MIN, NP_SHORT_BREAK_MAX));
    try RSClient.Image.Clear(); except end;

    InactivityTimer.Reset();
    NP_LastProgressTime := GetTickCount();
  end;
end;

procedure AB_InitProfile();
begin
  ABMouseSpeed   := SRL.NormalRange(16, 22);
  ABMouseGravity := SRL.NormalRange(10, 18);
  ABMouseWind    := SRL.NormalRange(2, 5);
  ABMouseMiss    := SRL.NormalRange(6, 12);

  Mouse.Speed := ABMouseSpeed;
  Mouse.Gravity := ABMouseGravity;
  Mouse.Wind := ABMouseWind;
  Mouse.MissChance := ABMouseMiss;

  ABNextCamJitterAt := GetTickCount() + SRL.NormalRange(25000, 45000);
  ABNextBreakletAt  := GetTickCount() + SRL.NormalRange(480000, 840000);
end;

procedure AB_MaybeAmbient();
var
  now: UInt64;
begin
  now := GetTickCount();

  if now >= ABNextCamJitterAt then
  begin
    Antiban.RandomRotate();
    ABNextCamJitterAt := now + SRL.NormalRange(25000, 45000);
  end;

  if now >= ABNextBreakletAt then
  begin
    Antiban.RandomRightClick();
    Antiban.RandomKeyboard();
    WaitEx(1000, 400);
    ABNextBreakletAt := now + SRL.NormalRange(480000, 840000);
  end;
end;

function HasGainedXP(): Boolean;
var
  TempValue: Int32;
begin
  if RSClient.IsLoggedIn() then
    CurrentXP := XPBar.Read();

  TempValue := GainedXP;
  GainedXP  := CurrentXP - StartXP;
  Result := GainedXP > TempValue;

  if Result then
    NP_MarkProgress();
end;

procedure WriteDebug(Message: String);
begin
  WriteLn(SRL.TimeStamp(), ':[Script]: ', Message);
end;

procedure PrintProgress();
var
  Hours: Double;
  Total, Hourly: String;
begin
  Hours := GetTimeRunning()/3600000;
  Total := ToStr(Round((GainedXP/1000), 0), ' k ');
  Hourly := ToStr('(', Round((GainedXP/(Hours*1000)), 1), ' k / hr)');
  WriteLn(SRL.TimeStamp(), ':[Experience]: ', Total, Hourly);
  ReportTimer.Reset();
end;

procedure ConfigureDiscord();
begin
  WebhookEnabled := False;

  if WebhookURL = '' then
  begin
    if SendHourlyReports or SendSessionSummaryReports then
      WriteLn('[Discord] Webhook URL is empty; Discord reports disabled.');
    Exit;
  end;

  try
    Discord.Setup();
  except
    on E: Exception do
    begin
      WriteLn('[Discord] Failed to initialize Discord client: ' + E.Message);
      Exit;
    end;
  end;

  if not Discord.SetWebhook(WebhookURL) then
  begin
    WriteLn('[Discord] Failed to validate webhook: ' + Discord.LastError);
    Exit;
  end;

  Discord.SetUsername('Agility with BH');
  Discord.Webhook.ClearAll();
  WebhookEnabled := True;
  WriteLn('[Discord] Webhook configured successfully.');
end;

procedure SendHourlyReport();
var
  runtimeMs: UInt64;
  runtimeHours, xpPerHour, lapsPerHour: Double;
  embedIdx: Int32;
  sent: Boolean;
begin
  if not (WebhookEnabled and SendHourlyReports) then
    Exit;

  runtimeMs := RuntimeTimer.ElapsedTime();

  if RSClient.IsLoggedIn() then
    CurrentXP := XPBar.Read();

  GainedXP := CurrentXP - StartXP;

  if runtimeMs = 0 then
    runtimeHours := 0
  else
    runtimeHours := runtimeMs / 3600000.0;

  if runtimeHours > 0 then
  begin
    xpPerHour := GainedXP / runtimeHours;
    lapsPerHour := LapsCompleted / runtimeHours;
  end else
  begin
    xpPerHour := 0;
    lapsPerHour := 0;
  end;

  try
    Discord.Webhook.ClearAll();
    Discord.Webhook.Content := '**Hourly Progress Report** :chart_with_upwards_trend:';
    embedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[embedIdx].Title := 'Agility with BH - Hourly Report';
    Discord.Webhook.Embeds[embedIdx].Color := $1E90FF;
    Discord.Webhook.Embeds[embedIdx].Description :=
      'Runtime: ' + SRL.MsToTime(runtimeMs, Time_Short) + LineEnding +
      'XP gained: ' + SRL.FormatNumber(GainedXP, 0) + ' (' + SRL.FormatNumber(xpPerHour, 1) + '/h)' + LineEnding +
      'Laps: ' + SRL.FormatNumber(LapsCompleted, 0) + ' (' + SRL.FormatNumber(lapsPerHour, 1) + '/h)' + LineEnding +
      'Farm runs: ' + IntToStr(FarmRuns) + LineEnding +
      'Birdhouse runs: ' + IntToStr(BirdhouseRuns) + LineEnding +
      'Marks of grace: ' + IntToStr(Marks);

    sent := Discord.Send();

    if sent then
      WriteLn('[Discord] Hourly report sent.')
    else
      WriteLn('[Discord] Failed to send hourly report: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending hourly report: ' + GetExceptionMessage);
  end;
end;

procedure CheckHourlyReport();
begin
  if not (WebhookEnabled and SendHourlyReports) then
    Exit;

  if HourlyReportTimer.ElapsedTime() >= 3600000 then
  begin
    SendHourlyReport();
    HourlyReportTimer.Reset();
    HourlyReportTimer.Start();
  end;
end;

procedure SendSessionSummary();
var
  runtimeMs: UInt64;
  runtimeHours, xpPerHour, lapsPerHour: Double;
  embedIdx: Int32;
  sent: Boolean;
begin
  if SessionSummarySent then
    Exit;

  SessionSummarySent := True;

  if not (WebhookEnabled and SendSessionSummaryReports) then
    Exit;

  runtimeMs := RuntimeTimer.ElapsedTime();

  if RSClient.IsLoggedIn() then
    CurrentXP := XPBar.Read();

  GainedXP := CurrentXP - StartXP;

  if runtimeMs = 0 then
    runtimeHours := 0
  else
    runtimeHours := runtimeMs / 3600000.0;

  if runtimeHours > 0 then
  begin
    xpPerHour := GainedXP / runtimeHours;
    lapsPerHour := LapsCompleted / runtimeHours;
  end else
  begin
    xpPerHour := 0;
    lapsPerHour := 0;
  end;

  try
    Discord.Webhook.ClearAll();
    Discord.Webhook.Content := '**Session Complete!** :checkered_flag:';
    embedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[embedIdx].Title := 'Agility with BH - Session Summary';
    Discord.Webhook.Embeds[embedIdx].Color := $32CD32;
    Discord.Webhook.Embeds[embedIdx].Description :=
      'Runtime: ' + SRL.MsToTime(runtimeMs, Time_Short) + LineEnding +
      'XP gained: ' + SRL.FormatNumber(GainedXP, 0) + ' (' + SRL.FormatNumber(xpPerHour, 1) + '/h)' + LineEnding +
      'Laps: ' + SRL.FormatNumber(LapsCompleted, 0) + ' (' + SRL.FormatNumber(lapsPerHour, 1) + '/h)' + LineEnding +
      'Farm runs: ' + IntToStr(FarmRuns) + LineEnding +
      'Birdhouse runs: ' + IntToStr(BirdhouseRuns) + LineEnding +
      'Marks of grace: ' + IntToStr(Marks);
    Discord.Webhook.Embeds[embedIdx].Footer := 'Bird nests looted: ' + IntToStr(BirdHouseRunner.NestsLooted);

    sent := Discord.SendScreenshot(False);

    if sent then
      WriteLn('[Discord] Session summary sent.')
    else
      WriteLn('[Discord] Failed to send session summary: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending session summary: ' + GetExceptionMessage);
  end;
end;

function GetCurrentObstacleName(): String;
var
  upText: TStringArray;
begin
  if Step < 0 then
    Exit('Recovering');

  if Length(Obstacles) = 0 then
    Exit('Setting up');

  if Step > High(Obstacles) then
    Exit('Traversing');

  if Step < Low(Obstacles) then
    Exit('Starting');

  upText := Obstacles[Step].UpText;

  if Length(upText) > 0 then
    Exit(upText[0]);

  Result := 'Obstacle #' + IntToStr(Step);
end;

function GetFarmRunHudText(): String;
begin
  if not DoFarmRuns then
    Exit('Disabled');

  if Farm.ReadyTimer.Length = 0 then
    Exit('Configuring');

  if Farm.ReadyTimer.IsFinished() then
    Exit('Ready');

  Result := SRL.MsToTime(Farm.ReadyTimer.TimeRemaining(), Time_Short);
end;

function GetBirdhouseHudText(): String;
begin
  if not DoBirdhouseRuns then
    Exit('Disabled');

  if BirdHouseRunner.ScriptIntervalTimer.Length = 0 then
    Exit('Configuring');

  if BirdHouseRunner.ScriptIntervalTimer.IsFinished() then
    Exit('Ready');

  Result := SRL.MsToTime(BirdHouseRunner.ScriptIntervalTimer.TimeRemaining(), Time_Short);
end;

procedure AgilityStatusHud_Init(var Display: TAgilityStatusHud);
begin
  Display.Enabled := EnableStatusHud;
  Display.FontSize := 11;
  Display.BackgroundColor := $2D2D30;
  Display.BorderColor := $000000;
  Display.TextColor := $FFFFFF;
  Display.Position := Point(14, 70);
  Display.Padding := 6;
  Display.Width := 235;
  Display.Runtime := Default(TStopWatch);
  Display.Runtime.Start();
end;

procedure AgilityStatusHud_Update(var Display: TAgilityStatusHud);
var
  runtimeMs, elapsedSinceBreak: UInt64;
  xpPerHour: Int32;
  headerSpacing, lineSpacing, height, y: Int32;
  lines: TStringArray;
  xpLine, farmLine, birdLine: String;
  lootLine, breakLine: String;
  box: TBox;
  i: Int32;
begin
  if not Display.Enabled then
    Exit;

  if not RSClient.IsLoggedIn() then
    Exit;

  runtimeMs := Display.Runtime.ElapsedTime();

  if runtimeMs = 0 then
    xpPerHour := 0
  else
    xpPerHour := Round(GainedXP / (runtimeMs / 3600000));

  xpLine := ToStr('XP: ', GainedXP, ' (', xpPerHour, '/h)');
  farmLine := 'Farm: ' + GetFarmRunHudText();
  birdLine := 'Birdhouse: ' + GetBirdhouseHudText();
  lootLine := 'Loot: Marks ' + IntToStr(Marks);

  if DoBirdhouseRuns then
    lootLine += ' | Nests ' + IntToStr(BirdHouseRunner.NestsLooted);

  lines := [];

  lines += 'Agility with BH';
  lines += 'Runtime: ' + SRL.MsToTime(runtimeMs, Time_Short);
  lines += xpLine;
  lines += 'Obstacle: ' + GetCurrentObstacleName();
  lines += farmLine;
  lines += birdLine;
  lines += lootLine;

  elapsedSinceBreak := 0;
  breakLine := '';

  if LastBreakEventSummary <> '' then
  begin
    if LastBreakInProgress then
      breakLine := 'Break: ' + LastBreakEventSummary + ' (in progress)'
    else
    begin
      if GetTimeRunning() >= LastBreakEventAt then
        elapsedSinceBreak := GetTimeRunning() - LastBreakEventAt
      else
        elapsedSinceBreak := 0;
      breakLine := 'Last break: ' + LastBreakEventSummary + ' (' +
        SRL.MsToTime(elapsedSinceBreak, Time_Short) + ' ago)';
    end;
  end;

  if breakLine <> '' then
    lines += breakLine;

  if SystemUpdateHudMessage <> '' then
    lines += '⚠ ' + SystemUpdateHudMessage;

  lineSpacing := Display.FontSize + 4;
  headerSpacing := Display.FontSize + 6;
  height := (Display.Padding * 2) + headerSpacing + (lineSpacing * (Length(lines) - 1));
  box := Box(Display.Position.X, Display.Position.Y, Display.Position.X + Display.Width, Display.Position.Y + height);

  with RSClient.Image() do
  begin
    DrawBoxFilled(box.Expand(1), False, Display.BorderColor);
    DrawBoxFilled(box, False, Display.BackgroundColor);
    SetFontName('Arial');

    y := box.Y1 + Display.Padding;

    SetFontSize(Display.FontSize + 1);
    DrawText(lines[0], Point(box.X1 + Display.Padding, y), Display.TextColor);
    y += headerSpacing;

    SetFontSize(Display.FontSize);

    for i := 1 to High(lines) do
    begin
      DrawText(lines[i], Point(box.X1 + Display.Padding, y), Display.TextColor);
      y += lineSpacing;
    end;
  end;
end;

procedure AgilityStatusHud_Clear();
begin
  try
    RSClient.Image().Clear();
  except
  end;
end;

procedure PrintInfo();
var
  Info: String;
begin
  if BirdhouseRuns > 0 then
    Info += ToStr('Birdhouse: ', BirdhouseRuns);

  if (BirdhouseRuns > 0) and (FarmRuns > 0) then
    Info += ToStr(' | ');

  if FarmRuns > 0 then
    Info += ToStr('Farm: ', FarmRuns);

  WriteLn(SRL.TimeStamp(), ':[Runs]: ', Info);

  InfoTimer.Reset();
end;

procedure TAntiban.DoLoseFocus();
begin
  Self.LoseFocus(SRL.NormalRange(250, 1900));
end;

procedure TAntiban.HandleFinishTask(Task: PAntibanTask);
begin
  if Task = nil then
    Exit;
end;

procedure TAntiban.Setup(); override;
begin
  inherited;

  Self.AddTask(ONE_MINUTE * 2, @Self.RandomMouse, 1);
  Self.AddTask(ONE_MINUTE * 9, @Self.HoverMSPlayers, 1);
  Self.AddTask(ONE_MINUTE * 5, @Self.DoLoseFocus, 1);
  Self.AddTask(ONE_MINUTE * 6, @Self.RandomRotate, 1);
  Self.AddTask(ONE_MINUTE * 9, @Self.RandomRightClick, 1);

  Self.Breaks := [];

  MiniBreakChancePct := MINI_BREAK_CHANCE_PCT_DEFAULT;
  MiniGapMinMs := MINI_GAP_MIN_MS_DEFAULT;
  MiniGapMaxMs := MINI_GAP_MAX_MS_DEFAULT;
  MiniLenMinMs := MINI_LEN_MIN_MS_DEFAULT;
  MiniLenMaxMs := MINI_LEN_MAX_MS_DEFAULT;

  PlannedCadenceJitterPct := PLANNED_CADENCE_JITTER_PCT_DEFAULT;
  PlannedLengthJitterPct := PLANNED_LENGTH_JITTER_PCT_DEFAULT;

  MiniBreakPaused := False;
  PlannedBreakPaused := False;
  MiniBreakRemainingMs := 0;
  PlannedBreakRemainingMs := 0;
  NextMiniBreakAt := 0;
  NextPlannedBreakAt := 0;
  LastBreakEventSummary := '';
  LastBreakEventAt := 0;
  LastBreakInProgress := False;

  ScheduleNextMiniBreak();

  if PlannedBreaksEnabled and (BreakAfter > 0) and (BreakFor > 0) then
    ScheduleNextPlannedBreak()
  else
    NextPlannedBreakAt := 0;

  if TakeSleeps then
  begin
    Self.OnStartSleep := @OnSleepStart;
    Self.OnFinishSleep := @OnSleepEnd;
    Self.AddSleep('00:00:00', 6 * ONE_HOUR, 0.1, 1);
  end
  else
  begin
    Self.OnStartSleep := nil;
    Self.OnFinishSleep := nil;
  end;
  Self.OnStartBreak := @PauseTimer;
  Self.OnFinishBreak := @ResumeTimer;
  Self.OnFinishTask := @Self.HandleFinishTask;
end;

procedure AddObstacle(i: Int32; Tile, WalkTile: TPoint; UpText: TStringArray; Area: TBox; Height, Wait: Int32);
begin
  SetLength(Obstacles, i + 1);

  Obstacles[i].Tile := Tile;
  Obstacles[i].UpText := UpText;
  Obstacles[i].Area := Area;

  if WalkTile <> Default(TPoint) then
    Obstacles[i].WalkTile := WalkTile;

  if Height <> 0 then
    Obstacles[i].Height := Height;

  if Wait <> 0 then
    Obstacles[i].Wait := Wait;
end;

procedure SetupDraynor();
begin
  AddObstacle(0, [7804, 3332], [7808, 3336], ['Rough', 'wall'], [7500, 3200, 8564, 3721], 2, 0);
  AddObstacle(1, [276, 4322], Default(TPoint), ['Cross', 'ight'], [270, 4302, 300, 4326], 0, 720);
  AddObstacle(2, [252, 4326], Default(TPoint), ['Cross', 'ight'], [222, 4309, 270, 4346], 0, 720);
  AddObstacle(3, [240, 4374], Default(TPoint), ['Balance'], [236, 4354, 267, 4375], -2, 0);
  AddObstacle(4, [236, 4408], Default(TPoint), ['ump'], [228, 4382, 241, 4408], 2, 0);
  AddObstacle(5, [264, 4410], Default(TPoint), ['Jump'], [229, 4406, 265, 4413], 0, 0);
  AddObstacle(6, [292, 4386], Default(TPoint), ['down'], [264, 4381, 300, 4415], 0, 0);

  BankBooth.Setup(6, [[7756, 3468]]);
  BankBooth.Finder.Colors += CTS2(3822977, 15, 0.45, 2.38);
  ReturnItems := ['Law rune', 'Earth rune', 'Air rune'];
  ReturnItemAmounts := [Random(30, 120), Random(30, 120), Random(30, 120)];
  ReturnSpell := ERSSpell.LUMBRIDGE_TELEPORT;
end;

procedure SetupArdougne();
begin
  AddObstacle(0, [6084, 3256], [6080, 3260], ['p Wo', 'den Be', 'Wooden', 'Beams'], [5600, 3000, 6500, 3500], 0, 0);
  AddObstacle(1, [718, 5118], Default(TPoint), ['ump', 'Gap'], [715, 5113, 734, 5170], 0, 0);
  AddObstacle(2, [681, 5087], Default(TPoint), ['lk-on', 'Plan'], [677, 5080, 709, 5097], 0, 0);
  AddObstacle(3, [648, 5088], Default(TPoint), ['ump', 'Gap'], [648, 5080, 675, 5096], 0, 0);
  AddObstacle(4, [648, 5122], Default(TPoint), ['ump', 'Gap'], [643, 5100, 656, 5123], 0, 0);
  AddObstacle(5, [652, 5159], Default(TPoint), ['Balance', 'ce-ac', 'Steep', 'eep ro'], [636, 5120, 664, 5164], 0, 0);
  AddObstacle(6, [662, 5174], Default(TPoint), ['ump', 'Gap'], [647, 5168, 673, 5181], 0, 0);


  BankBooth.Setup(6, [[6016, 3304]]);
  BankBooth.Finder.Colors += CTS2(6251367, 1, 1.67, 1.48);
  ReturnItems := ['Law rune', 'Water rune'];
  ReturnItemAmounts := [Random(30, 120), Random(30, 120)];
  ReturnSpell := ERSSpell.ARDOUGNE_TELEPORT;
end;

procedure SetupVarrock();
begin
  AddObstacle(0, [8276, 2792], [8276, 2792], ['Climb R', 'ough'], [7900, 2300, 9000, 3000], 2, 0);
  AddObstacle(1, [305, 4910], Default(TPoint), ['Cross', 'othe'], [302, 4882, 346, 4931], 0, 0);
  AddObstacle(2, [254, 4900], Default(TPoint), ['Leap', 'eap G'], [253, 4877, 291, 4913], 0, 0);
  AddObstacle(3, [582, 4906], Default(TPoint), ['Balance W', 'ce W'], [578, 4894, 620, 4924], 0, 0);
  AddObstacle(4, [238, 4964], Default(TPoint), ['Leap', 'Gap'], [212, 4932, 254, 4961], 0, 0);
  AddObstacle(5, [290, 4964], Default(TPoint), ['Leap', 'Gap'], [165, 4951, 300, 5069], 0, 0);
  AddObstacle(6, [386, 4956], Default(TPoint), ['eap', 'Gap'], [301, 4935, 395, 5020], 0, 0);
  AddObstacle(7, [406, 4928], Default(TPoint), ['Hurdle', 'edge'], [390, 4932, 426, 5000], 2, 0);
  AddObstacle(8, [402, 4900], Default(TPoint), ['ump-', 'Edge'], [386, 4891, 435, 4929], 0, 0);

  BankBooth.Setup(6, [[8136, 2704]]);
  BankBooth.Finder.Colors += CTS2(4880003, 11, 0.03, 1.38);
  ReturnItems := ['Law rune', 'Fire rune', 'Air rune'];
  ReturnItemAmounts := [Random(30, 120), Random(30, 120), Random(30, 120)];
  ReturnSpell := ERSSpell.VARROCK_TELEPORT;
end;

procedure SetupFalador();
begin
  AddObstacle(0, [7536, 3082], [7536, 3082], ['Rough', 'wall'], [7000, 2800, 7700, 3300], 2, 0);
  AddObstacle(1, [860, 4779], Default(TPoint), ['Cross', 'ight'], [832, 4769, 866, 4792], 0, 720);
  AddObstacle(2, [900, 4747], Default(TPoint), ['Cross', 'Hand'], [871, 4747, 920, 4799], 2, 0);
  AddObstacle(3, [892, 4715], Default(TPoint), ['ump', 'Gap'], [886, 4714, 908, 4734], 0, 0);
  AddObstacle(4, [876, 4703], Default(TPoint), ['ump', 'Gap'], [873, 4676, 901, 4713], 0, 0);
  AddObstacle(5, [836, 4705], Default(TPoint), ['Cross', 'ight'], [831, 4690, 869, 4713], 0, 720);
  AddObstacle(6, [804, 4739], Default(TPoint), ['Cross', 'ight'], [799, 4725, 823, 4749], 0, 720);
  AddObstacle(7, [772, 4743], Default(TPoint), ['Jump', 'Gap'], [730, 4713, 791, 4739], 0, 0);
  AddObstacle(8, [760, 4771], Default(TPoint), ['ump', 'Ledge'], [762, 4753, 797, 4785], 0, 0);
  AddObstacle(9, [752, 4779], Default(TPoint), ['ump', 'Ledge'], [737, 4759, 760, 4776], 2, 0);
  AddObstacle(10, [748, 4815], Default(TPoint), ['ump', 'Ledge'], [735, 4782, 760, 4812], 0, 0);
  AddObstacle(11, [772, 4819], Default(TPoint), ['ump', 'Ledge'], [729, 4806, 769, 4837], 0, 0);
  AddObstacle(12, [796, 4819], Default(TPoint), ['Jump', 'Edge'], [769, 4803, 850, 4848], 0, 0);

  BankBooth.Setup(6, [[7444, 3032]]);
  BankBooth.Finder.Colors += CTS2(5929360, 10, 0.03, 0.93);
  ReturnItems := ['Law rune', 'Water rune', 'Air rune'];
  ReturnItemAmounts := [Random(30, 120), Random(30, 120), Random(30, 120)];
  ReturnSpell := ERSSpell.FALADOR_TELEPORT;
end;

procedure SetupSeersVillage();
begin
  AddObstacle(0, [6308, 2490], [6308, 2510], ['Wall'], [6000, 2300, 6900, 2800], 2, 250);
  AddObstacle(1, [534, 5346], Default(TPoint), ['Jump', 'Gap'], [531, 5325, 590, 5373], 0, 0);
  AddObstacle(2, [762, 5370], Default(TPoint), ['Cross', 'Tight'], [720, 5329, 800, 5382], 0, 750);
  AddObstacle(3, [766, 5420], Default(TPoint), ['ump', 'Gap'], [750, 5388, 800, 5433], 0, 0);
  AddObstacle(4, [876, 4703], Default(TPoint), ['ump', 'Gap'], [873, 4676, 901, 4713], 0, 0);
  AddObstacle(5, [466, 5448], Default(TPoint), ['ump', 'Gap'], [440, 5400, 555, 5467], 0, 0);
  AddObstacle(6, [734, 5468], Default(TPoint), ['ump', 'Edge'], [666, 5452, 760, 5511], 0, 0);

  BankBooth.Setup(6, [[6288, 2471]]);
  BankBooth.Finder.Colors += CTS2(6980239, 12, 0.03, 0.78);
  ReturnItems := ['Law rune', 'Air rune'];
  ReturnItemAmounts := [Random(30, 120), Random(30, 120)];
  ReturnSpell := ERSSpell.CAMELOT_TELEPORT;
end;

procedure Initiate();
var
  Ultracomposts: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  AB_InitProfile();

  if WaitUntil(RSClient.IsLoggedIn(), 250, 12000) then
  begin
    StartXP := XPBar.Read();
    CurrentXP := StartXP;
    GainedXP := 0;
  end;

  if StartXP < 1024 then
    TerminateScript('Failed to read XP, make sure XPBar is set up!');

  NP_MarkProgress();

  LapsCompleted := 0;
  SessionSummarySent := False;

  RuntimeTimer := Default(TStopWatch);
  RuntimeTimer.Start();

  ConfigureDiscord();

  HourlyReportTimer := Default(TStopWatch);
  if WebhookEnabled and SendHourlyReports then
    HourlyReportTimer.Start();

  AgilityStatusHud_Init(AgilityHud);

  if Options.GetNPCAttackOption() <> ERSAttackOption.HIDDEN then
    Options.SetNPCAttackOption(ERSAttackOption.HIDDEN);

  MM2MS.SetupZoom();
  SetGameSettings();

  if DoBirdhouseRuns then
    BirdHouseRunner.Init();

  if DoFarmRuns then
  begin
    Farm.CompostMethod := CompostMethod;
    Farm.CompostFlowers := CompostFlowers;

    if HosidiusHerb then
    begin
      Farm.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.HOUSE_TELEPORT, Seed);
      Inc(UltraComposts);
    end;

    if HosidiusFlower then
      Farm.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.HOUSE_TELEPORT, FlowerSeed);

    if CatherbyHerb then
    begin
      Farm.AddPatch(EFarmPatch.CATHERBY_HERB, ETravelMethod.CAMELOT_TELEPORT, Seed);
      Inc(Ultracomposts);
    end;

    if CatherbyFlower then
      Farm.AddPatch(EFarmPatch.CATHERBY_FLOWER, ETravelMethod.CAMELOT_TELEPORT, FlowerSeed);

    case CompostMethod of
      ECompostMethod.BOTTOMLESS:
      begin
        FarmItems += 'Bottomless compost bucket';
        FarmItemAmounts += 1;
      end;

      ECompostMethod.ULTRA:
      begin
        FarmItems += 'Ultracompost';
        FarmItemAmounts += UltraComposts;
      end;
    end;

    FarmItems += 'Spade';
    FarmItemAmounts += 1;

    if UseMagicSecateurs then
    begin
      FarmItems += 'Magic secateurs';
      FarmItemAmounts += 1;
    end;

    if HosidiusFlower or CatherbyFlower then
    begin
      FarmItems += FlowerSeed;
      FarmItemAmounts += 2;
    end;

    if HosidiusHerb or CatherbyHerb then
    begin
      FarmItems += Seed;
      FarmItemAmounts += 2;
    end;

    if not BarbarianDibber then
    begin
      FarmItems += 'Seed dibber';
      FarmItemAmounts += 1;
    end;

    if not UseRunePouch then
    begin
      FarmItems.Add(['Law rune', 'Air rune', 'Earth rune']);
      FarmItemAmounts.Extend([100, 150, 150]);
    end;

    Farm.Init(FarmRunNow);
    WriteDebug(ToStr('Farm runs enabled.'));
    WriteDebug(ToStr('Patches length: ', Length(Farm.Patches)));
    WriteDebug(ToStr('Herb Seed: ', Seed));
    WriteDebug(ToStr('Flower Seed: ', FlowerSeed));
    WriteDebug(ToStr('Hosidius Flower / Herb: ', HosidiusFlower, ' / ', HosidiusHerb));
    WriteDebug(ToStr('Catherby Flower / Herb: ', CatherbyFlower, ' / ', CatherbyHerb));
    WriteDebug(ToStr('Farm Run Timer: ', Farm.ReadyTimer.TimeRemaining()));
    if not CompostFlowers then
      WriteDebug(ToStr('Flower composting disabled; ', FlowerSeed, ' patches will be skipped for compost.'));
  end;

  if BirdhouseRuns or FarmRuns then
    InfoTimer.Start();

  AgilityRSW.SetupRegions([[0, 4000, 1500, 5700], [2142, 1984, 2705, 2650], [5228, 2000, 8600, 4000], [8710, 558, 10236, 1758]]);
  BankBooth.SetupUpText(['nk boo','Bank booth']);

  case Course of
    ARDOUGNE_ROOF: SetupArdougne();
    FALADOR_ROOF: SetupFalador();
    SEERS_ROOF: SetupSeersVillage();
    VARROCK_ROOF: SetupVarrock();
    DRAYNOR_ROOF: SetupDraynor();
  end;

  WaitTime := 775;
  WriteDebug('Always-on antiban profile active (slower reactions and micro-breaks).');

  WaitRand := (WaitTime - 10);
  AgilityRSW.AdaptiveWalk := True;

  Mouse.Speed := Random(11, 15);

  if BlockInput then
  begin
    WriteDebug('Blocking real input (default). Uncheck "Block Real Input" before starting to allow manual control.');
    WLSettings.RemoteInput.BlockInput := True;
    RSClient.RemoteInput.DisableRealInput();
    RealInputBlocked := True;
  end else
  begin
    WriteDebug('Real input enabled; "Block Real Input" was unchecked.');
    WLSettings.RemoteInput.BlockInput := False;
    RSClient.RemoteInput.EnableRealInput();
    RealInputBlocked := False;
  end;

  if UseRunePouch then
  begin
    ReturnItems := ['Rune pouch'];
    ReturnItemAmounts := [1];
  end;

  if Food <> '' then
  begin
    ReturnItems += Food;
    ReturnItemAmounts += 2;
  end;

  InactivityTimer.Start();
  ReportTimer.Start();

  SystemUpdateCheckTimer.Init(0);
  SystemUpdateWarningShown := False;
  PendingSystemUpdateLogout := False;
  SystemUpdateHudMessage := '';
  SystemUpdateThresholdMinutes := 0;
  SystemUpdateLogoutDelayedLogged := False;
  FarmRunActive := False;
  BirdhouseRunActive := False;

  AgilityStatusHud_Update(AgilityHud);
end;

function GetStep(): Int32;
var
  Pos: TPoint := AgilityRSW.GetMyPos();
  i: Int32;
begin
  for i := 0 to High(Obstacles) do
    if Obstacles[i].Area.Contains(Pos) then
      Exit(i);

  Exit(-1);
end;

function HoverPoint(Pt: TPoint; UpText: TStringArray): Boolean;
begin
  if not Mainscreen.Bounds.Contains(Pt) then
    Exit(False)
  else
    Mouse.HumanMove(Pt);

  if SRL.Dice(15) then
    RandomWait();

  Result := Mainscreen.IsUpText(UpText, WaitTime);
end;

function FindObstacle(Obs: TObstacle): Boolean;
var
  MSRect: TRectangle;
  TPA: TPointArray;
  Pt: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  MSRect := AgilityRSW.GetTileMS(Obs.Tile, Obs.Height);

  if SRL.Dice(33) then
    MSRect := MSRect.Expand(Random(-4, 0));

  if not Mainscreen.Bounds.Contains(MSRect) then
    Exit(False);

  RSClient.Image.DrawRect(MSRect, clAqua);

  if SRL.Dice(85) then
    if HoverPoint(MSRect.Mean(), Obs.UpText) then
      Exit(True);

  TPA := MSRect.ToTPA();
  TPA := TPA.Sorted(Mouse.Position());

  for Pt in TPA do
  begin
    if SRL.Dice(25) then
      Continue;

    if HoverPoint(Pt, Obs.UpText) then
      Exit(True);
  end;
end;

procedure GroundStep();
var
  Pos, StartTile: TPoint;
  Experience: Int32;
  Found: Boolean;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if DoFarmRuns then
    if Farm.ReadyTimer.IsFinished() then
      Farm.DoFarmRun();

  if DoBirdhouseRuns then
    if BirdHouseRunner.CanDoBirdHouseRun() then
      if AgilityRSW.GetMyPos.InBox(Obstacles[0].Area) then
        BirdHouseRunner.DoBirdHouseRun();

  MaybeHandleScheduledBreaks();

  Found := FindObstacle(Obstacles[0]);
  RSClient.Image.Clear();

  if Found then
  begin
    Experience := XPBar.Read();
    Mouse.Click(MOUSE_LEFT);
    WaitUntil(Experience < XPBar.Read(), 250, 12775);
  end else
  begin
    Pos := AgilityRSW.GetMyPos();
    StartTile := Obstacles[0].WalkTile;

    if not Pos.InBox(Obstacles[0].Area) then
      Exit();

    if Pos.DistanceTo(StartTile) > 128 then
      AgilityRSW.WebWalk(StartTile)
    else if Pos.DistanceTo(StartTile) > 32 then
      AgilityRSW.WalkBlind(StartTile)
    else
    begin
      Inc(gfc);
      WriteDebug(ToStr('Failed at groundstep, gfc: ', gfc));
      Antiban.RandomRotate();
    end;
  end;
end;

function PickMarks(Step: Int32): Boolean;
var
  MTPA, Dots: TPointArray;
  MarkRect: TRectangle;
  MarkBounds: TBox;
  Dot: TPoint;
  MoG: Int32;
begin
  Minimap.WaitFlag();
  Dots := Minimap.GetDots(ERSMinimapdot.ITEM);

  if Dots.Len() = 0 then
    Exit();

  Dot := AgilityRSW.MMToWorld(Dots[0].Offset(2, 2));

  if Obstacles[Step].Area.Contains(Dot) then
  begin
    MarkRect := AgilityRSW.GetTileMS(Dot).Expand(24);
    MarkBounds := MarkRect.Bounds();
    MarkBounds.LimitTo(Mainscreen.Bounds);
    SRL.FindColors(MTPA, CTS2(2141119, 1, 0.01, 0.01), MarkBounds);

    if MTPA.Len() = 0 then
      Exit(False);

    MoG := Inventory.CountItemStack('Mark of grace');
    Mouse.HumanMove(MTPA.Mean());

    if not Mainscreen.IsUpText(['Take M', 'ark of g'], 195) then
      Exit(False);

    Mouse.Click(MOUSE_LEFT);

    if WaitUntil(MoG < Inventory.CountItemStack('Mark of grace'), 250, 7500) then
    begin
      Inc(Marks);
      Exit(True);
    end;
  end;
end;

procedure NormalStep(Step: Int32);
var
  Health, Experience, NewXP: Int32;
  Found: Boolean;
  Pos: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  Health := Minimap.GetHPLevel();
  Experience := XPBar.Read();

  if PickMarks(Step) then
    RandomWait();

  Found := FindObstacle(Obstacles[Step]);
  RSClient.Image.Clear();

  if Found then
  begin
    Mouse.Click(MOUSE_LEFT);
    WaitUntil((Experience < XPBar.Read()) or (Health > Minimap.GetHPLevel()), 300, 12775);
    if (Length(Obstacles) > 0) and (Step = High(Obstacles)) then
    begin
      NewXP := XPBar.Read();
      if NewXP > Experience then
        Inc(LapsCompleted);
    end;
    Wait(Obstacles[Step].Wait);
  end else
  begin
    Pos := AgilityRSW.GetMyPos();

    if not Pos.InBox(Obstacles[Step].Area) then
      Exit();

    if Pos.DistanceTo(Obstacles[Step].Tile) > 32 then
      AgilityRSW.WalkBlind(Obstacles[Step].Tile)
    else
    begin
      Inc(fc);
      WriteDebug(ToStr('Failed at normalstep, fc: ', fc));
      Antiban.RandomRotate();
    end;
  end;
end;

procedure RecoverFromLost();
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteDebug('Lost!');

  if InactivityTimer.ElapsedTime() < 30000 then
    Exit();

  Magic.CastSpell(ReturnSpell);

  WaitEx(5775, 555);
end;

procedure Loop();
begin
  CheckSystemUpdate();

  if HasGainedXP() then
    InactivityTimer.Reset();

  NP_CheckAndRecover();

  if InactivityTimer.ElapsedTime() > 900000 then
    TerminateScript('No Gained XP in 15 mins, stopping!');

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if RSInterface.IsOpen() then
    RSInterface.Close(50);

  if Minimap.GetHPPercent() < 40 then
    if not Inventory.ClickItem(Food) then
      TerminateScript('Could not eat food, possible out of it?');

  if DoBirdhouseruns or DoFarmruns then
    if InfoTimer.ElapsedTime() > 360000 then
      PrintInfo();

  if ReportTimer.ElapsedTime() > 120000 then
    PrintProgress();

  CheckHourlyReport();

  Step := GetStep();

  case Step of
    -1: RecoverFromLost();
     0: GroundStep();
  else
    NormalStep(Step);
  end;

  AgilityStatusHud_Update(AgilityHud);

  MaybeHandleScheduledBreaks();

  AB_MaybeAmbient();
  Antiban.DoBreak();
  Antiban.DoAntiban(False);
  AB_MicroIdle();

  WaitEx(WaitTime, WaitRand);
end;

procedure OpenConfiguredBankTab();
var
  desiredTab: Int32;
begin
  if not Bank.IsOpen() then
    Exit;

  desiredTab := BankTab;

  if desiredTab < 0 then
    desiredTab := 0;

  if desiredTab = 0 then
  begin
    BankTab := 0;
    Bank.OpenTab(0);
    Exit;
  end;

  if Bank.GetTabBox(desiredTab) = [] then
  begin
    WriteDebug('Configured bank tab ' + ToStr(desiredTab) + ' is unavailable, defaulting to all items.');
    BankTab := 0;
    Bank.OpenTab(0);
    Exit;
  end;

  if not Bank.OpenTab(desiredTab) then
  begin
    WriteDebug('Failed to open bank tab ' + ToStr(desiredTab) + ', defaulting to all items.');
    BankTab := 0;
    Bank.OpenTab(0);
    Exit;
  end;

  BankTab := desiredTab;
end;

function WithdrawReturnItems(): Boolean;
var
  Item: TRSBankItem;
  i: Int32;
begin
  if not Bank.IsOpen() then
    Exit(False);

  for i := 0 to High(ReturnItems) do
  begin
    Item := TRSBankItem.Setup(ReturnItems[i], ReturnItemAmounts[i], False);
    Bank.WithdrawItem(Item, False);
    WaitEx(500, 450);
  end;

  Result := WaitUntil(Inventory.ContainsAll(ReturnItems), 250, 2750);

  if (not Result) and (Bank.GetCurrentTab() <> 0) then
  begin
    WriteDebug('Failed to withdraw return items on tab ' + ToStr(Bank.GetCurrentTab()) + '; retrying with all items tab.');
    Bank.OpenTab(0);
  end;
end;

function WithdrawFarmRun(): Boolean;
var
  B: TRSBankItem;
  i: Int32;
begin
  if not Bank.IsOpen() then
    Exit(False);

  for i := 0 to High(FarmItems) do
  begin
    B := TRSBankItem.Setup(FarmItems[i], FarmItemAmounts[i], False);
    Bank.WithdrawItem(B, False);
    WaitEx(500, 450);
  end;

  Result := WaitUntil(Inventory.ContainsAll(FarmItems), 250, 2750);

  if (not Result) and (Bank.GetCurrentTab() <> 0) then
  begin
    WriteDebug('Failed to withdraw all farm items on tab ' + ToStr(Bank.GetCurrentTab()) + '; retrying with all items tab.');
    Bank.OpenTab(0);
  end;
end;

procedure Farm.OnStart(); override;
var
  BankTimeout: TCountdown;
  i, tries: Int32
begin
  WriteDebug("Starting a farm run.");

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Pause();

  BankTimeout.Init(97000);

  while not BankTimeout.IsFinished() and not Bank.IsOpen() do
  begin
    if not Obstacles[0].Area.Contains(AgilityRSW.GetMyPos()) then
      if Magic.CastSpell(ReturnSpell) then
        WaitEx(4500, 500);

    if BankBooth.WalkClick() then
      WaitUntil(Bank.IsOpen(), 250, 7500);
  end;

  if not Bank.IsOpen() then
    Exit();

  OpenConfiguredBankTab();

  for tries := 0 to 4 do
  begin
    if Inventory.CountEmptySlots() < 28 then
      Bank.DepositAll();

    WaitUntil(Inventory.CountEmptySlots() > 25, 150, 2000);

    if not WithdrawFarmRun() then
      Continue;

    if WithdrawReturnItems() then
      Break;
  end;

  WaitEx(850, 250);
  Bank.Close(60);
end;

procedure Farm.OnComplete(); override;
var
  i: Int32;
begin
  Inc(FarmRuns);

  if Magic.CastSpell(ReturnSpell) then
    WaitEx(6969, 420)
  else
    WriteDebug('Failed to cast returnspell after a farm run!');

  if RSClient.IsLoggedIn() then
    SetGameSettings();

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Resume();
end;

function TBirdHouseInclude.OnStart(): Boolean; override;
var
  BankTimeout: TCountdown;
  i, tries: Int32;
begin
  WriteDebug("Birdhouse Include OnStart");

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Pause();

  BankTimeout.Init(95000);

  while not BankTimeout.IsFinished() and not Bank.IsOpen() do
  begin
    if not Obstacles[0].Area.Contains(AgilityRSW.GetMyPos()) then
    begin
      Magic.CastSpell(ReturnSpell);
      WaitEx(4500, 500);
    end;

    if BankBooth.WalkClick() then
      WaitUntil(Bank.IsOpen(), 250, 7500);
  end;

  if not Bank.IsOpen() then
  begin
    Self.DebugLn('Failed to get to bank');
    Exit(False);
  end;

  OpenConfiguredBankTab();

  for tries := 0 to 4 do
  begin
    if Inventory.CountEmptySlots() < 28 then
      Bank.DepositAll();

    WaitUntil(Inventory.CountEmptySlots() > 25, 150, 2000);

    if not Self.WithdrawNextRun() then
      Continue;

    if WithdrawReturnItems() then
      Break;
  end;

  WaitEx(850, 250);

  Result := Bank.Close(60);
end;

procedure TBirdHouseInclude.OnComplete(); override;
var
  i: Int32;
begin
  WriteDebug("Birdhouse Include OnComplete");

  if Magic.CastSpell(ReturnSpell) then
    WaitEx(6969, 420);

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Resume();

  Inc(BirdhouseRuns);
  SetGameSettings();
end;

begin
  try
    AgilityGUI_LoadSettings();
    AgilityGUI_Run();
    Initiate();

    repeat
      Loop();
    until false;
  finally
    CleanupScript();
  end;
end.
