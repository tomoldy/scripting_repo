{$DEFINE SCRIPT_ID := '4a0ed125-d2f4-4394-8db3-3db10c7a2d0a'}
{$DEFINE SCRIPT_REVISION := '15'}
program mta;
{$I WaspLib/osr.simba}
{$I WaspLib/optional/handlers/discord.simba}

type
  EAzimuth = (N, E, S, W);
  EMode    = (TELEKINETIC, ALCHEMY, ENCHANT, GRAVEYARD);
  EState   = (IDLE, GATHER_BONES, DEPOSIT_FRUIT, CAST_BONES, PLAY_TELEKINETIC, CAST_ALCHEMY,
              GATHER_SHAPES, DEPOSIT_ORBS, CAST_ENCHANT, DEPOSIT_COINS, GATHER_ALCHES,
              EXIT_TELEKINETIC, EXIT_ALCHEMY, EXIT_ENCHANT, EXIT_GRAVEYARD, JOIN);

  TTheatre = record
    Index: Int32;
    Area: TBox;
    Maze: TBox;
    Steps: Array of EAzimuth;
  end;

  TMTAGUI = record (TScriptForm)
    edit_BreakFor, edit_BreakAfter, edit_StopAfter: TLabeledEdit;
    // NEW: reporting/runtime/webhook controls
    edit_MaxRuntime, edit_ReportEvery, edit_WebhookURL: TLabeledEdit;
    label_Info, label_Title, label_PtsTitle, label_Pts: TLabel;
    cb_BlockInput: TLabeledCheckbox;
    combo_Mode: TLabeledCombobox;
  end;

var
  AlchemyExit, GraveyardExit, EnchantExit, Deposit, Pile, Statue: TRSObject;
  Chambers, Lobby, Graveyards, Playgrounds: TBox;
  InactivityTimer, ReportTimer: TStopwatch;
  Guardianer, Cupboarder: TRSObjectFinder;
  StartXP, GainedXP, StopAfter, C: Int32;
  Theatres: Array [0..9] of TTheatre;
  State, Previous: EState;
  Alches: TRSItemArray;
  Spell: ERSSpell;
  RSW: TRSWalker;
  Fruit: TRSItem;
  GUI: TMTAGUI;
  Mode: EMode;
  Discord: TDiscordClient;
  // Login guard timestamp (prevents spam-logging)
  LastLoginAttempt: UInt64;

  // === NEW: runtime & reporting ===
  StartTimeMS, LastReportMS: Int64;
  MaxRuntimeMin: Int32;         // minutes; 0 = no limit
  MaxRuntimeMS: Int64;
  ReportEveryMin: Int32 = 10;   // minutes; 0 = off
  ReportEveryMS: Int64;
  WebhookURL: string;           // Discord webhook URL (blank = disabled)
  StartMagicXP, StartPoints: Int32;

// Forward declare link opener used by GUI label
procedure OpenLink(Sender: TObject); forward;

procedure TMTAGUI.StartScript(Sender: TObject); override;
var
  bf, ba: Int32;
begin
  bf := Self.edit_BreakFor.GetText().ExtractInteger();
  ba := Self.edit_BreakAfter.GetText().ExtractInteger();

  if (bf > 0) and (ba > 0) then
    Antiban.AddBreak(ba * ONE_MINUTE, bf * ONE_MINUTE, 0.3, 1);

  if Self.cb_BlockInput.IsChecked() then
  begin
    // WLSettings is Simba 2.0; on 1.4 we only toggle RSClient's RemoteInput
    RSClient.RemoteInput.DisableRealInput();
  end else
  begin
    // WLSettings is Simba 2.0; on 1.4 we only toggle RSClient's RemoteInput
    RSClient.RemoteInput.EnableRealInput();
  end;

  StopAfter := Self.edit_StopAfter.GetText().ExtractInteger(0);
  Mode := EMode(Self.combo_Mode.GetItemIndex());

  // NEW: read GUI inputs for runtime/reporting/webhook
  MaxRuntimeMin  := Self.edit_MaxRuntime.GetText().ExtractInteger(0);
  ReportEveryMin := Self.edit_ReportEvery.GetText().ExtractInteger(10);
  WebhookURL     := Trim(Self.edit_WebhookURL.GetText());

  // Setup Discord client if URL provided (GemCrab style)
  if WebhookURL <> '' then
  begin
    Discord.SetWebhook(WebhookURL);
    Discord.SetUsername('MTA');
  end;

  inherited;
end;

procedure TMTAGUI.Run(); override;
var
  Font, Bold: TFont;
  Tab: TTabSheet;
begin
  Self.Setup('MTA', Point(800, 500), False);
  Self.Start.SetOnClick(@Self.StartScript);
  Self.AddTab('Settings');

  Font.Init();
  Font.setName('Segoe UI Semibold');
  Font.SetQuality(fqCleartype);
  Self.Form.setFont(Font);
  Self.PageControl.SetFont(Font);
  Font.Free();

  Bold.Init();
  Bold.setName('Segoe UI Bold');
  Bold.SetQuality(fqCleartype);

  Tab := Self.GetTab('Settings');
  Tab.SetTooltip('');

  with Self.edit_BreakAfter do
  begin
    Create(Tab);
    SetToolTip('Time to play before a break (minutes)');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(160));
    SetCaption('Break after:');
    SetWidth(80);
    SetText('45');
  end;

  with Self.edit_BreakFor do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(120));
    SetTop(TControl.AdjustToDPI(160));
    SetToolTip('Break time (minutes)');
    SetCaption('Break for:');
    SetWidth(80);
    SetText('5');
  end;

  with Self.combo_Mode do
  begin
    Create(Tab);
    SetCaption('Mode:');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(210));
    SetWidth(80);
    AddItemArray(['Telekinetic', 'Alchemy', 'Enchant', 'Graveyard']);
    SetItemIndex(Ord(EMode.TELEKINETIC));
  end;

  with Self.edit_StopAfter do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(120));
    SetTop(TControl.AdjustToDPI(210));
    SetWidth(80);
    SetToolTip('Stop after reaching x points in current room. (empty = unlimited)');
    SetCaption('Point limit:');
  end;

  // NEW: runtime cap + periodic reporting + webhook URL
  with Self.edit_MaxRuntime do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(300));
    SetWidth(80);
    SetToolTip('Hard stop after X minutes (0 = none)');
    SetCaption('Max runtime:');
    SetText('0');
  end;

  with Self.edit_ReportEvery do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(120));
    SetTop(TControl.AdjustToDPI(300));
    SetWidth(80);
    SetToolTip('Send Discord updates every X minutes (0 = off)');
    SetCaption('Report every:');
    SetText('10');
  end;

  with Self.edit_WebhookURL do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(340));
    SetWidth(TControl.AdjustToDPI(260));
    SetToolTip('Discord webhook URL; leave blank to disable webhooks');
    SetCaption('Webhook URL:');
    SetText('');
  end;

  with Self.cb_BlockInput do
  begin
    Create(Tab);
    SetCaption('Block input');
    SetToolTip('If this is checked, you can not manually interact with the client');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(260));
  end;

  with Self.label_Title do
  begin
    Create(Tab);
    SetFont(Bold);
    SetCaption('Script page and instructions:');
    SetLeft(240);
    SetTop(160);
  end;

  with Self.label_Info do
  begin
    Create(Tab);
    SetCaption('https://waspscripts.com/scripts/mage-training-arena-by-nll');
    SetFontColor($FF0000);
    SetLeft(240);
    SetTop(180);
    SetWidth(200);
    setOnClick(@OpenLink);
    setCursor(crHandPoint);
  end;

  with Self.label_PtsTitle do
  begin
    Create(Tab);
    SetFont(Bold);
    SetCaption('Points for green log:');
    SetLeft(240);
    SetTop(210);
  end;

  with Self.label_Pts do
  begin
    Create(Tab);
    SetLeft(TControl.AdjustToDPI(240));
    SetTop(TControl.AdjustToDPI(230));
    SetCaption('Telekinetic:   2675' + #10 + 'Graveyard:    2675' + #10 +
               'Alchemist:    3075' + #10 + 'Enchant:     27500' );
  end;

  Bold.Free();
  Self.CreateAccountManager(Tab);
  inherited;
end;

function HasGainedXP(): Boolean;
var
  t: Int32 := XPBar.Read() - StartXP;
begin
  if t > 0 then
  begin
    Result := t > GainedXP;

    if Result then
      GainedXP := t;
  end;
end;

function ClickHelper(Pt: TPoint; UpTexts: TStringArray): Boolean;
begin
  Mouse.HumanMove(Pt);

  if Mainscreen.IsUpText(UpTexts, SRL.NormalRange(300, 650)) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Exit(True);
  end;

  if SRL.Dice(15) then
    WaitEx(1000, 250);

  if not Mainscreen.GetUpText().Contains('Walk') then
    if ChooseOption.Open() then
      Result := ChooseOption.Select(UpTexts);
end;

// Helper: returns True only if the string is non-empty and all characters are digits 0-9.
// Why: Simba 1.4 may not expose TryStrToInt everywhere; this provides a fast parse check
// without exceptions and lets OCR fallbacks kick in deterministically.
function IsDigits(const S: string): Boolean;
var
  i: Int32;
begin
  Result := Length(S) > 0;
  if not Result then Exit;
  for i := 1 to Length(S) do
    if not (S[i] in ['0'..'9']) then
      Exit(False);
end;

function GetCurrentPoints(): Int32;
var
  Scanned, Digits: String;
  i: Int32;
  Bounds: TBox;
begin
  // Primary OCR pass (strict color): fast & accurate when the HUD color is stable.
  Bounds := [445, 50, 510, 100];
  Scanned := OCR.Recognize(Bounds, TOCRColorFilter.Create([C]), RS_FONT_PLAIN_11);
  Scanned := Scanned.Replace(',', '');

  // Fallback #1: if parse fails, retry with a slightly expanded box & looser color tolerance.
  if (Scanned = '') or (not IsDigits(Scanned)) then
  begin
    // Why: chat logs show small shifts in font position/antialias; a bigger box + tolerance helps.
    Bounds := Bounds.Expand(6);
    Scanned := OCR.Recognize(Bounds, TOCRColorFilter.Create([C], [35]), RS_FONT_PLAIN_11);
    Scanned := Scanned.Replace(',', '');
  end;

  // Fallback #2: keep only digits in case stray glyphs creep in (e.g., spaces, periods).
  if (Scanned <> '') then
  begin
    Digits := '';
    for i := 1 to Length(Scanned) do
      if Scanned[i] in ['0'..'9'] then
        Digits += Scanned[i];
    if Digits <> '' then
      Scanned := Digits;
  end;

  // Final parse; return -1 if still not readable so callers can decide how to behave.
  try
    Result := StrToInt(Scanned);
  except
    Result := -1;
  end;
end;

// Discord via WaspLib handler (GemCrab-style). We use TDiscordClient from
// {$I WaspLib/optional/handlers/discord.simba} to send embeds/screenshots.

// --- Login guard helpers (Simba 1.4 safe) ---
// Why: RSClient.IsLoggedIn() can briefly flicker false during UI changes. We throttle
// Login.LoginPlayer() so we don't spam the login routine mid-room and stall the script.
function IsActuallyInGame(): Boolean;
begin
  // Keep it simple for 1.4: rely on RSClient.IsLoggedIn only
  Result := RSClient.IsLoggedIn();
end;

procedure TryAutoLoginGuarded();
var
  nowMS: UInt64;
begin
  if IsActuallyInGame() then
    Exit;

  nowMS := GetTickCount();
  // 30s back-off between login attempts
  if (LastLoginAttempt <> 0) and (nowMS - LastLoginAttempt < 30000) then
    Exit;

  LastLoginAttempt := nowMS;
  WriteLn(SRL.TimeStamp(), ':[Login]: Guarded auto-login attempt');
  Login.LoginPlayer();
  // Short wait so we don't hammer the loop immediately after invoking login
  WaitEx(800, 200);
end;

// === NEW: runtime & reporting helpers ===
procedure InitRuntimeAndTracking();
begin
  StartTimeMS   := GetTimeRunning();
  LastReportMS  := StartTimeMS;
  MaxRuntimeMS  := Int64(MaxRuntimeMin) * 60 * 1000;
  ReportEveryMS := Int64(ReportEveryMin) * 60 * 1000;

  StartMagicXP := XPBar.Read();
  StartPoints  := GetCurrentPoints();
end;

function HitTimeLimit(): Boolean;
begin
  if (MaxRuntimeMS <= 0) then
    Exit(False);
  Result := (GetTimeRunning() - StartTimeMS) >= MaxRuntimeMS;
end;

procedure MaybeReport(const Force: Boolean = False);
var
  nowMS: Int64;
  curXP, curPts, xpGain, ptsGain: Int32;
  roomName, runtimeStr, title: string;
  idx: Int32;
begin
  if (WebhookURL = '') then Exit;

  nowMS := GetTimeRunning();
  if (not Force) and (ReportEveryMS > 0) and ((nowMS - LastReportMS) < ReportEveryMS) then
    Exit;

  curXP   := XPBar.Read();
  curPts  := GetCurrentPoints();
  xpGain  := Max(0, curXP  - StartMagicXP);
  ptsGain := Max(0, curPts - StartPoints);

  case Mode of
    TELEKINETIC: roomName := 'Telekinetic';
    ALCHEMY:     roomName := 'Alchemy';
    ENCHANT:     roomName := 'Enchant';
    GRAVEYARD:   roomName := 'Graveyard';
  else
    roomName := 'Lobby/Unknown';
  end;

  runtimeStr := Format('%0.1f min', [(nowMS - StartTimeMS) / 60000.0]);
  title      := 'MTA update (' + roomName + ')';

  // BigAussie/GemCrab style: use TDiscordClient embeds (no cURL/COM)
  try
    Discord.Webhook.Content := '**Session stats**';
    idx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[idx].Title := title;
    Discord.Webhook.Embeds[idx].Color := $00AAFF;
    Discord.Webhook.Embeds[idx].Description :=
      'Runtime: ' + runtimeStr + LineEnding +
      'Magic XP gained: ' + IntToStr(xpGain) + LineEnding +
      'Pizazz gained: '   + IntToStr(ptsGain);

    if Force then
      Discord.SendScreenshot(False)
    else
      Discord.Send();
  except
    WriteLn('[Discord] Failed to send update');
  end;

  LastReportMS := nowMS;
end;

function Await(): Boolean;
begin
  Result := Antiban.DoAntiban(False, False) and False;
end;

procedure PrintProgress();
var
  Hours: Double;
  Total, Hourly: String;
begin
  Hours := GetTimeRunning() / 3600000;
  Total := ToStr(Round((GainedXP / 1000), 0), ' k ');
  Hourly := ToStr('(', Round(GainedXP / (Hours * 1000), 1), ' k / hr)');

  WriteLn(SRL.TimeStamp(), ':[Experience]: ', Total, Hourly);

  ReportTimer.Reset();
end;

procedure PauseTimer(Task: PBreakTask);
var
  T: PBreakTask;
begin
  InactivityTimer.Pause();
  T := Task;
end;

procedure ResumeTimer(Task: PBreakTask);
var
  T: PBreakTask;
begin
  InactivityTimer.Resume();
  T := Task;
end;

procedure WriteDebug(Message: String);
begin
  WriteLn(SRL.TimeStamp(), ':[Script]: ', Message);
end;

procedure TAntiban.DoLoseFocus();
var
  t: Int32 := SRL.NormalRange(750, 3250);
begin
  Self.DebugLn(ToStr('Losing focus for ', t, ' ms'));
  Self.LoseFocus(t);
end;

function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height:Double=0; Offx,Offy:Double=0): TRectangle; override;
var
  angle: Double;
  vec: Vector3;
begin
  Loc   := Minimap.Center + (Loc - Me);
  angle := Minimap.GetCompassAngle(False);
  vec   := Vec3(Loc.X, Loc.Y, 0).RotateXY(angle, Minimap.Center.X, Minimap.Center.Y);
  Result := Minimap.VectorToMSRect(vec + [-offx, -offy, height], 1, 1, angle);
end;

function GetTheatre(): Int32;
var
  i: Int32;
begin
  for i := 0 to High(Theatres) do
    if Theatres[i].Area.Contains(RSW.GetMyPos()) then
      Exit(i);

  Exit(-1);
end;

procedure SetupTheatres();
begin
  with Theatres[0] do
  begin
    SetLength(Steps, 10);
    Index := 0;
    Maze := [103, 111, 139, 149];
    Steps := [N, W, N, E, N, W, S, W, N, E];
    Area := [30, 30, 215, 193];
  end;

  with Theatres[1] do
  begin
    SetLength(Steps, 7);
    Index := 1;
    Maze := [343, 101, 379, 137];
    Steps := [E, S, W, N, W, N, E];
    Area := [297, 41, 448, 174];
  end;

  with Theatres[2] do
  begin
    SetLength(Steps, 9);
    Index := 2;
    Maze := [553, 93 , 587, 129];
    Steps := [S, W, S, E, S, E, N, W, N];
    Area := [471, 39, 707, 202];
  end;

  with Theatres[3] do
  begin
    SetLength(Steps, 8);
    Index := 3;
    Maze := [817, 115, 853, 151];
    Steps := [N, W, S, E, N, W, S, E];
    Area := [732, 50, 914, 226];
  end;

  with Theatres[4] do
  begin
    SetLength(Steps, 7);
    Index := 4;
    Maze := [1047, 137, 1083, 173];
    Steps := [N, E, S, E, N, E, S];
    Area := [1011, 110, 1128, 224];
  end;

  with Theatres[5] do
  begin
    SetLength(Steps, 8);
    Index := 5;
    Maze := [105, 413, 141, 449];
    Steps := [S, W, N, W, S, W, S, W];
    Area := [42, 359, 231, 471];
  end;

  with Theatres[6] do
  begin
    SetLength(Steps, 10);
    Index := 6;
    Maze := [327, 421, 361, 459];
    Steps := [N, E, S, E, S, W, N, E, N, W];
    Area := [275, 323, 425, 506];
  end;

  with Theatres[7] do
  begin
    SetLength(Steps, 8);
    Index := 7;
    Maze := [533, 405, 569, 441];
    Steps := [N, E, N, W, N, E, N, W];
    Area := [492, 364, 644, 491];
  end;

  with Theatres[8] do
  begin
    SetLength(Steps, 9);
    Index := 8;
    Maze := [753, 403, 789, 439];
    Steps := [N, W, S, W, N, W, S, W, N];
    Area := [699, 338, 920, 499];
  end;

  with Theatres[9] do
  begin
    SetLength(Steps, 7);
    Index := 9;
    Maze := [1057, 401, 1093, 437];
    Steps := [S, E, N, W, S, E, N];
    Area := [1000, 322, 1128, 501];
  end;
end;

function CountBones(): Int32;
begin
  Result := Inventory.CountItem('Animals' + #39 + ' Bones');
end;

function InLobby(): Boolean;
begin
  Result := RSW.GetMyPos().InBox(Lobby);
end;

function ShouldDepositCoins(): Boolean;
var
  Coins: Int32 := Inventory.CountItemStack('Coins');
begin
  if Coins > 10000 then
    Exit(True);

  if Coins > 6000 then
    if SRL.Dice(5) then
      Exit(True);

  Exit(False);
end;

function GetTelekineticState(Pos: TPoint): EState;
begin
  if Pos.InBox(Lobby) then
    Exit(JOIN);

  if GetTheatre() > -1 then
    Exit(PLAY_TELEKINETIC);

  if Pos.InBox(Graveyards) then
    Exit(EXIT_GRAVEYARD);

  if Pos.InBox(Playgrounds) then
    Exit(EXIT_ALCHEMY);

  if Pos.InBox(Chambers) then
    Exit(EXIT_ENCHANT);
end;

function GetGraveyardState(Pos: TPoint): EState;
begin
  if Pos.InBox(Lobby) then
    Exit(JOIN);

  if Pos.InBox(Graveyards) then
  begin
    if Inventory.ContainsItem(Fruit) then
      Exit(DEPOSIT_FRUIT);

    if CountBones() > Random(5, 8) then
      Exit(CAST_BONES);

    Exit(GATHER_BONES);
  end;

  if GetTheatre() <> -1 then
    Exit(EXIT_TELEKINETIC);

  if Pos.InBox(Playgrounds) then
    Exit(EXIT_ALCHEMY);

  if Pos.InBox(Chambers) then
    Exit(EXIT_ENCHANT);
end;

function GetEnchantState(Pos: TPoint): EState;
begin
  if Pos.InBox(Lobby) then
    Exit(JOIN);

  if Pos.InBox(Chambers) then
  begin
    if not Inventory.IsFull() then
      Exit(GATHER_SHAPES);

    if Inventory.ContainsAny(['Cube', 'Dragonstone']) then
      Exit(CAST_ENCHANT);

    Exit(DEPOSIT_ORBS);
  end;

  if Pos.InBox(Graveyards) then
    Exit(EXIT_GRAVEYARD);

  if Pos.InBox(Playgrounds) then
    Exit(EXIT_ALCHEMY);

  if GetTheatre() > -1 then
    Exit(EXIT_TELEKINETIC);
end;

function ShouldStop(): Boolean;
begin
  // Hard runtime cap
  if HitTimeLimit() then
  begin
    WriteDebug('Hit max runtime, terminating.');
    Exit(True);
  end;

  if HasGainedXP() then
    InactivityTimer.Reset();

  if InactivityTimer.ElapsedTime() > 300000 then
  begin
    WriteDebug('We have not gained XP in 5 minutes, terminating.');
    Exit(True);
  end;

  if (StopAfter <> 0) and (GetCurrentPoints() >= StopAfter) then
  begin
    WriteDebug(ToStr('We have reached ', StopAfter, ' points, terminating.'));
    Exit(True);
  end;

  Result := False;
end;

function GetAlchemyState(Pos: TPoint): EState;
begin
  if Pos.InBox(Lobby) then
    Exit(JOIN);

  if Pos.InBox(Playgrounds) then
  begin
    if ShouldDepositCoins() then
      Exit(DEPOSIT_COINS);

    if Inventory.CountEmptySlots() < Random(6, 12) then
      Exit(CAST_ALCHEMY);

    Exit(GATHER_ALCHES);
  end;

  if Pos.InBox(Graveyards) then
    Exit(EXIT_GRAVEYARD);

  if Pos.InBox(Chambers) then
    Exit(EXIT_ENCHANT);

  if GetTheatre() > -1 then
    Exit(EXIT_TELEKINETIC);
end;

procedure SetupStatue(Coords: TPointArray; Text: TStringArray);
begin
  with Statue do
  begin
    Finder.Colors += CTS2(8490379, 16, 0.25, 0.13);
    Setup(0, Coords);
    SetupUpText(Text);
  end;
end;

function GetState(): EState;
begin
  if RSClient.IsLoggedIn() = False then
    Exit(IDLE);

  case Mode of
    TELEKINETIC: Exit(GetTelekineticState(RSW.GetMyPos()));
    GRAVEYARD: Exit(GetGraveyardState(RSW.GetMyPos()));
    ENCHANT: Exit(GetEnchantState(RSW.GetMyPos()));
    ALCHEMY: Exit(GetAlchemyState(RSW.GetMyPos()));
  end;
end;

procedure StepMazeTile(Maze: TBox; Step: EAzimuth);
var
  Pos: TPoint := RSW.GetMyPos();
  Dest: TPointArray;
  Rect: TRectangle;
  i: Int32;
begin
  case Step of
    W: Dest := [[Maze.X1, Round((Maze.Y1+Maze.Y2)/2)], [Maze.X1-4, Round((Maze.Y1+Maze.Y2)/2)]];
    E: Dest := [[Maze.X2, Round((Maze.Y1+Maze.Y2)/2)], [Maze.X2+4, Round((Maze.Y1+Maze.Y2)/2)]];
    S: Dest := [[Round((Maze.X1+Maze.X2)/2), Maze.Y2], [Round((Maze.X1+Maze.X2)/2), Maze.Y2+4]];
    N: Dest := [[Round((Maze.X1+Maze.X2)/2), Maze.Y1], [Round((Maze.X1+Maze.X2)/2), Maze.Y1-4]];
  end;

  if Magic.IsSelected(Spell) then
    Magic.DeSelect();

  if Pos.DistanceTo(Dest[1]) > 52 then
    RSW.WalkBlind(Dest[1]);

  if Minimap.IsRunEnabled() = False then
    if Minimap.GetRunEnergy() > 70 then
      Minimap.EnableRun();

  if RSW.AtTile(Dest[1]) then
    Exit();

  for i := 0 to 5 do
  begin
    Rect := RSW.GetTileMS(Dest[Random(0, 1)]);

    if Mainscreen.Bounds.Contains(Rect) then
    begin
      Mouse.HumanMove(Rect.Mean());

      if Mainscreen.IsUpText('Walk', 195) = False then
      begin
        Mouse.Click(MOUSE_RIGHT);
        ChooseOption.Select('Walk here');
      end else
        Mouse.Click(MOUSE_LEFT);

      WaitUntil(RSW.AtTile(Dest[1]), 750, 10750);

      if RSW.AtTile(Dest[1]) then
        Exit();
    end;
    Antiban.RandomRotate();
  end;
end;

procedure SetupTelekinetic();
begin
  with Guardianer do
  begin
    ColorClusters += [CTS2(8682362, 7, 0.26, 0.12), CTS2(10724270, 6, 6.54, 0.26), 10];
    ClusterDistance := 100;
    Grow := 4;
  end;

  SetupStatue([[1004, 688]], ['Telekinetic']);
  Spell := ERSSpell.TELEKINETIC_GRAB;

  if not InRange(Options.GetZoomLevel(), 0, 10) then
    Options.SetZoomLevel(Random(0, 4));

  C := 16764006;
end;

procedure SetupAlchemy();
begin
  with Deposit do
  begin
    Finder.Colors += CTS2(10463656, 7, 0.50, 0.30);
    Setup(2, [[700, 628]]);
    SetupUpText(['Deposit']);
  end;

  with Cupboarder do
  begin
    Colorclusters += [CTS2(8819344, 19, 0.24, 0.13), CTS2(4609635, 8, 0.08, 0.17), 30];
    Colorclusters += [CTS2(8819344, 19, 0.24, 0.13), CTS2(7845056, 13, 0.03, 1.13), 30];
    Colorclusters += [CTS2(8819344, 19, 0.24, 0.13), CTS2(7242890, 4, 0.57, 1.18), 30];
    ClusterDistance := 45;
  end;

  Alches := ['Leather boots', 'Adamant kiteshield', 'Adamant med helm', 'Emerald', 'Rune longsword'];
  SetupStatue([[1004, 664]], ['Alche']);

  if not Magic.IsOpen() then
    Magic.Open();

  if Magic.CanActivate(ERSSpell.HIGH_LEVEL_ALCHEMY) then
    Spell := ERSSpell.HIGH_LEVEL_ALCHEMY
  else if Magic.CanActivate(ERSSpell.LOW_LEVEL_ALCHEMY) then
    Spell := ERSSpell.LOW_LEVEL_ALCHEMY
  else
    TerminateScript('Can not cast an alchemy spell');

  if not InRange(Options.GetZoomLevel(), 10, 20) then
    Options.SetZoomLevel(Random(10, 20));

  C := 52275;
end;

procedure SetupGraveyard();
begin
  SetupStatue([[1016, 676]], ['Graveyard']);

  if not Magic.IsOpen() then
    Magic.Open();

  if Magic.CanActivate(ERSSpell.BONES_TO_PEACHES) then
  begin
    WriteDebug('We are able to cast B2P, setting the spell.');
    Spell := ERSSpell.BONES_TO_PEACHES;
    Fruit := 'Peach';
  end else
  begin
    WriteDebug('We are NOT able to cast B2P, setting the spell.');
    Spell := ERSSpell.BONES_TO_BANANAS;
    Fruit := 'Banana';
  end;

  with Deposit do
  begin
    Setup(4, [[106, 638]]);
    SetupUpText(['hute']);
    Filter.Finder := False;
  end;

  with Pile do
  begin
    Finder.Colors += CTS2(8297361, 27, 0.47, 0.38);
    Setup(2, [[96, 646]]);
    SetupUpText(['ones']);
  end;

  if not InRange(Options.GetZoomLevel(), 20, 30) then
    Options.SetZoomLevel(Random(20, 30));

  C := 13421772;
end;

procedure SetupEnchant();
const
  Spells: Array of ERSSpell := [
    ERSSpell.LVL1_ENCHANT, ERSSpell.LVL2_ENCHANT,
    ERSSpell.LVL3_ENCHANT, ERSSpell.LVL4_ENCHANT,
    ERSSpell.LVL5_ENCHANT, ERSSpell.LVL6_ENCHANT,
    ERSSpell.LVL7_ENCHANT
  ];
var
  Temp: ERSSpell;
  i: Int32;
begin
  if not Magic.IsOpen() then
    Magic.Open();

  for i := 0 to Length(Spells) - 1 do
  begin
    Temp := Spells[i];

    if Magic.CanActivate(Temp) then
      Spell := Temp;
  end;

  with Deposit do
  begin
    Finder.ColorClusters += [CTS2(1776416, 1, 0.01, 0.01), CTS2(10002594, 11, 0.48, 0.19), 15];
    Setup(4, [[420, 654]]);
    SetupUpText(['Deposit']);
  end;

  with Pile do
  begin
    Finder.Colors += CTS2(2992063, 4, 0.26, 3.03);
    Setup(2, [[376, 598]]);
    SetupUpText(['Cube']);
  end;

  SetupStatue([[992, 676]], ['Enchant']);

  WriteDebug(ToStr('Chose enchant spell: ', Spell));

  if not InRange(Options.GetZoomLevel(), 10, 20) then
    Options.SetZoomLevel(Random(10, 20));

  C := 26316;
end;


// === Missing action & navigation procedures (restored) ===
// These power the state machine branches like JOIN/EXIT/CAST_* and room navigation.

// Open the script page when the label is clicked (GUI helper)
procedure OpenLink(Sender: TObject);
begin
  OpenWebPage('https://waspscripts.com/scripts/mage-training-arena-by-nll');
end;

function FindMazePoint(out Location: TPoint): Boolean;
var
  Dots: TPointArray := Minimap.GetDots(ERSMinimapDot.NPC);
  MazeRect: TRectangle;
  Theatre, i: Int32;
  Angle: Double;
  Pos: TPoint;
  Area: TBox;
begin
  if Length(Dots) = 0 then
    Exit(False);

  Theatre := GetTheatre();
  if Theatre = -1 then
    Exit(False);

  Angle := Minimap.GetCompassAngle(False);
  Area := Theatres[Theatre].Maze;
  Pos := RSW.GetMyPos();

  MazeRect := [RSW.WorldToMM(Pos, [Area.X1, Area.Y1], Angle),
               RSW.WorldToMM(Pos, [Area.X2, Area.Y1], Angle),
               RSW.WorldToMM(Pos, [Area.X2, Area.Y2], Angle),
               RSW.WorldToMM(Pos, [Area.X1, Area.Y2], Angle)];
  MazeRect := MazeRect.Expand(6);

  for i := 0 to Dots.Len() - 1 do
    if MazeRect.Contains(Dots[i]) then
    begin
      Location := RSW.MMToWorld(Dots[i]);
      Exit(True);
    end;
end;

procedure WaitGuardian();
var
  F: TPoint;
begin
  WaitUntil(FindMazePoint(F), 250, 2775);
end;

function FindGuardian(UpText: String): Boolean;
var
  GuardianWorldPoint: TPoint;
  ATPA: T2DPointArray;
  TPA: TPointArray;
  Bds: TBox;
begin
  if FindMazePoint(GuardianWorldPoint) then
  begin
    Bds := RSW.GetTileMS(GuardianWorldPoint).Expand(4).Bounds();
    Bds.LimitTo(Mainscreen.Bounds);
    ATPA := Mainscreen.FindObject(Guardianer, Bds);
  end;

  if ATPA.Len() = 0 then
  begin
    WriteDebug('Force searching Guardian.');
    Bds := Mainscreen.Bounds;
    Bds.X2 := Bds.X2 - 65;
    ATPA := Mainscreen.FindObject(Guardianer, Bds);
  end;

  if ATPA.Len() = 0 then
    Exit(False);

  ATPA.SortByMiddle(Mainscreen.Center);

  for TPA in ATPA do
  begin
    Mouse.HumanMove(TPA.Mean());
    if Mainscreen.IsUpText(UpText, 195) then
      Exit(True);
  end;
end;

procedure GrabGuardian();
var
  Experience: Int32;
  i: Int32;
begin
  Experience := XPBar.Read();
  for i := 0 to 7 do
  begin
    if Magic.IsSelected(Spell) = False then
      Magic.CastSpell(Spell);

    WaitGuardian();

    if FindGuardian('> Maze G') then
    begin
      WaitEx(100, 20);
      Mouse.Click(MOUSE_LEFT);
      if WaitUntil(Experience < XPBar.Read(), 665, 4000) then
        Exit();
    end
    else
      Antiban.RandomRotate();
  end;

  WriteDebug('Failed to grab Guardian!');
end;

function FinishTheatre(): Boolean;
var
  SolvedTheatre: Int32;
  i: Int32;
begin
  if Magic.IsSelected(Spell) then
    Magic.DeSelect();

  SolvedTheatre := GetTheatre();
  for i := 0 to 4 do
  begin
    if not FindGuardian('New') then
      Continue;

    Mouse.Click(MOUSE_LEFT);
    WaitUntil(SolvedTheatre <> GetTheatre(), 250, 8750);
    Exit(True);
  end;

  WriteDebug(ToStr('Failed to Finish Theatre!'));
end;

procedure ResetMaze();
var
  i: Int32;
begin
  for i := 0 to 3 do
  begin
    WriteDebug('Something went wrong, trying to reset maze.');
    if not FindGuardian('Observe') then
      Continue;

    if ChooseOption.Open() then
      if ChooseOption.Select('Reset') then
        Exit();
  end;

  WriteDebug('Failed to reset Maze, relogging to hard-reset');
  Logout.ClickLogout();
end;

procedure PlayTelekinetic();
var
  Theatre, i, xp: Int32;
begin
  Theatre := GetTheatre();
  if Theatre = -1 then Exit();

  WriteDebug(ToStr('Starting to solve Theatre: ', Theatre));

  for i := 0 to High(Theatres[Theatre].Steps) do
  begin
    if i = High(Theatres[Theatre].Steps) then
      xp := XPBar.Read();

    StepMazeTile(Theatres[Theatre].Maze, Theatres[Theatre].Steps[i]);
    GrabGuardian();

    // Let antiban breathe between pushes
    Antiban.DoAntiban(False, False);
  end;

  // Wait for the final XP tick to confirm success
  if WaitUntil(XPBar.Read() > xp + 200, 250, 7500) then
  begin
    if FinishTheatre() then
      WriteDebug(ToStr('Successfully solved Theatre: ', Theatre))
    else
      ResetMaze();
  end
  else
    ResetMaze();
end;

procedure DepositFruit();
begin
  if Deposit.Click() then
    WaitUntil(Inventory.ContainsAny(['Banana', 'Peach']) = False, 250, 3500)
  else
    RSW.WalkBlind(Deposit.Coordinates[0]);
end;

procedure GatherBones();
var
  Bones: Int32 := CountBones();
begin
  if Pile.Click() then
    WaitUntil(Bones < CountBones(), 400, 4800)
  else
    RSW.WalkBlind(Pile.Coordinates[0]);
end;

procedure CastBones();
begin
  if Magic.CastSpell(Spell) then
    WaitEx(650, 300);

  if Minimap.GetHPPercent() < Random (50, 75) then
    if Inventory.ContainsItem(Fruit) then
      if Inventory.ClickItem(Fruit) then
        WaitEx(650, 300);
end;

procedure CastEnchant();
var
  Item: TRSItem := 'Cube';
begin
  if Inventory.ContainsItem('Dragonstone') then
    Item := 'Dragonstone';

  if Inventory.ContainsItem(Item) then
  begin
    if Magic.CastSpell(Spell) then
      WaitEx(750, 250);

    if Inventory.ClickItem(Item, '>') then
    begin
      WaitEx(750, 250);
      WaitUntil(Await() or (Inventory.ContainsItem(Item) = False), 750, 120000);
    end;
  end;
end;

procedure DepositOrbs();
var
  Pos, Mid, Dest: TPoint;
begin
  Pos := RSW.GetMyPos();
  Dest := Deposit.Coordinates[0];

  if Box(Point(408,642), Point(432,666)).Contains(Pos) then
    Deposit.Setup(0, [Dest])
  else
    Deposit.Setup(12, [Dest]);

  if Pos.DistanceTo(Pile.Coordinates[0]) < Pos.DistanceTo(Dest) then
  begin
    Mid := [Round((Pos.X + Dest.X) / 2), Round((Pos.Y + Dest.Y) / 2)];
    RSW.WalkBlind(Mid.RandomBetween(Dest));
  end else
    if Deposit.Click() then
      WaitUntil(Await() or (Inventory.ContainsItem('Orb') = False), 500, 7500)
    else
      RSW.WalkBlind(Dest);
end;

(* Credit: Slacky ~ https://pastebin.com/Ut2NkjRT *)
function GetItemPrices(): TIntegerArray;
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  Scanned: String;
  SearchBox: TBox;
  i, n: Int32;
begin
  SRL.FindColors(TPA, CTS2(45620, 6, 0.14, 0.01), [490, 98, 517, 211]);
  ATPA := TPA.Cluster(20, 2);

  if ATPA.Len() = 0 then
    Exit();

  ATPA.SortByX(True);
  ATPA.SortByY(True);

  for i := 0 to High(ATPA) do
  begin
    SearchBox := ATPA[i].Bounds().Expand(2);
    Scanned := OCR.Recognize(SearchBox, TOCRColorFilter.Create([45620], [30]), RS_FONT_PLAIN_11);

    try
      n := StrToInt(Scanned);
    except
      n := 0;
    end;

    Result += n;
  end;
end;

function GetHighestValueSlot(): Int32;
const
  Values = [30, 15, 8, 5, 1];
var
  CurrentValues: TIntegerArray;
  i, j, f: Int32;
begin
  CurrentValues := GetItemPrices();

  if CurrentValues.Len() <> 5 then
    Exit(1);

  for i := 0 to High(Values) do
    for j := 0 to High(CurrentValues) do
      if Values[i] = CurrentValues[j] then
        if Inventory.FindItem(Alches[j], f) then
          Exit(f);
end;

procedure GatherShapes();
var
  Pos, Mid, Dest: TPoint;
  EmptySlots: Int32;
begin
  if Inventory.IsFull() then
    Exit();

  Pos := RSW.GetMyPos();
  Dest := Pile.Coordinates[0];
  EmptySlots := Inventory.CountEmptySlots();

  if Box(Point(408,642), Point(432,666)).Contains(Pos) then
    Pile.Setup(-4, [[376, 598]])
  else
    Pile.Setup(2, [[376, 598]]);

  if Pos.DistanceTo(Deposit.Coordinates[0]) < Pos.DistanceTo(Dest) then
  begin
    Mid := [Round((Pos.X + Dest.X) / 2), Round((Pos.Y + Dest.Y) / 2)];
    RSW.WalkBlind(Mid.RandomBetween(Dest));
  end else
    if Pile.Click() then
      WaitUntil(EmptySlots > Inventory.CountEmptySlots(), 300, 6000)
    else
      RSW.WalkBlind(Dest);
end;

procedure ExitRoom(Room: EMode);
var
  ExitStatue: TRSObject;
begin
  case Room of
    ALCHEMY: ExitStatue := AlchemyExit;
    ENCHANT: ExitStatue := EnchantExit;
    GRAVEYARD: ExitStatue := GraveyardExit;
  end;

  if ExitStatue.Click() then
    WaitUntil(InLobby(), 250, 10000)
  else
    RSW.WalkBlind(ExitStatue.Coordinates[0]);
end;

procedure EnterRoom();
begin
  if InLobby() = False then
    Exit();

  if Statue.WalkClick() then
    WaitUntil(InLobby() = False, 250, 8775)
  else
    RSW.WalkBlind(Statue.Coordinates[0]);
end;

procedure DepositCoins();
begin
  if RSW.GetMyPos().InBox(Playgrounds) then
    if Deposit.WalkClick() then
      WaitUntil(Inventory.ContainsItem('Coins') = False, 500, 8500);
end;

procedure CastAlchemy();
var
  Slots: TIntegerArray;
  i: Int32;
  spellText: string;
  slotIdx: Int32;
begin
  if Spell = ERSSpell.HIGH_LEVEL_ALCHEMY then
    spellText := 'Cast High'
  else
    spellText := 'Cast Low';

  if Inventory.FindItems(Alches, Slots) = False then
    Exit;

  for i := 0 to SRL.NormalRange(1, Slots.Len()) do
  begin
    if Magic.MouseSpell(Spell) = False then
      Continue;

    WaitEx(300, 50);

    if Mainscreen.IsUpText(spellText) = False then
      Continue;

    Mouse.Click(MOUSE_LEFT);

    if WaitUntil(Inventory.IsOpen(), 240, 2300) = False then
      Continue;

    WaitEx(425, 80);

    slotIdx := GetHighestValueSlot();
    if (slotIdx > 0) and Inventory.MouseSlot(slotIdx) then
    begin
      Mouse.Click(MOUSE_LEFT);
      WaitEx(2275, 300);
    end;

    Antiban.DoAntiban(False, False);
  end;
end;

function TakeFromCupboard(Tile: TPoint): Boolean;
var
  ATPA: T2DPointArray;
  Slots: Int32;
  Pt: TPoint;
  Area: TBox;
begin
  if Inventory.CountEmptySlots() < 4 then
    Exit(False);

  if not InRange(RSW.GetMyPos().X, 709, 723) then
    Area := RSW.GetTileMS(Tile, 4).Bounds().Expand(10)
  else
    Area := RSW.GetTileMS(Tile, 0).Bounds().Expand(10);

  Area.LimitTo(Mainscreen.Bounds);
  Slots := Inventory.CountEmptySlots();
  ATPA := Mainscreen.FindObject(Cupboarder, Area);

  if Length(ATPA) > 0 then
  begin
    RSClient.Image.DrawTPA(ATPA.Merge(), clAqua);
    Pt := ATPA.Merge().Mean();

    if SRL.Dice(10) then
    begin
      Mouse.HumanMove(Pt);
      if Mainscreen.IsUpText('Cupboard', 300) = False then
        Exit(False);
      Mouse.Click(MOUSE_LEFT);
    end else
      if ClickHelper(Pt, ['Take-5']) = False then
        Exit(False);

    Result := WaitUntil(Slots > Inventory.CountEmptySlots(), 500, SRL.NormalRange(3250, 4500));
    RSClient.Image.Clear();
  end else
    RSW.WalkBlind(Tile);
end;

procedure GatherAlches();
var
  Cupboards: TPointArray := [[718, 652], [718, 668], [718, 684]];
  i, k: Int32;
begin
  Cupboards.Sort(RSW.GetMyPos());

  for i := 0 to High(Cupboards) do
    for k := 1 to Random(1, 2) do
      if TakeFromCupboard(Cupboards[i]) then
        WaitEx(750, 150);
end;

procedure Init();
begin
  WriteDebug(ToStr('Starting script in ', Mode, ' Mode.'));

  if StopAfter <> 0 then
    WriteDebug(ToStr('Stopping after ', StopAfter, ' points.'))
  else
    WriteDebug('No point limit set.');

  if RSClient.IsLoggedIn() = False then
    Login.LoginPlayer();

  if WaitUntil(RSClient.IsLoggedIn(), 250, 12000) then
    StartXP := XPBar.Read();

  if StartXP < 1024 then
    TerminateScript('Failed to read XP, make sure XPBar is set up!');

  if RSClient.Mode <> ERSClientMode.FIXED then
    TerminateScript('The script needs to be ran in fixed mode!');

  RSW.SetupFromURL('https://i.imgur.com/SKuaSrF.png', 'mta.png', 4); // Simba 1.4: procedure call

  case Mode of
    TELEKINETIC: SetupTelekinetic();
    ALCHEMY: SetupAlchemy();
    ENCHANT: SetupEnchant();
    GRAVEYARD: SetupGraveyard();
  end;

  RSW.AdaptiveWalk := True;
  RSW.OnWalkingEvent := @Antiban.WalkingTasks; // antiban while walking

  Antiban.AddTask(ONE_MINUTE * 4, @Antiban.RandomMouse, 1);
  Antiban.AddTask(ONE_MINUTE * 4, @Antiban.RandomRotate, 1);
  Antiban.AddTask(ONE_MINUTE * 7, @Antiban.RandomRightClick, 1);
  Antiban.AddTask(ONE_MINUTE * 7, @Antiban.DoLoseFocus, 1);
  Antiban.AddTask(ONE_MINUTE * 7, @Antiban.RandomKeyboard, 1);
  Antiban.AddBreak(3 * ONE_MINUTE, 5 * ONE_SECOND, 0.4, 0.01);
  Antiban.OnStartBreak := @PauseTimer;
  Antiban.OnFinishBreak := @ResumeTimer;

  Mouse.Speed := SRL.NormalRange(16, 24);
  Mouse.Gravity := SRL.NormalRange(12, 20);
  Mouse.Wind := SRL.NormalRange(2, 4);
  Mouse.MissChance := SRL.NormalRange(8, 12);

  SetupTheatres();

  with GraveyardExit do
  begin
    Finder.Colors += CTS2(8490379, 16, 0.25, 0.13);
    Setup(0, [[140, 634]]);
    SetupUpText(['Exit']);
  end;

  with AlchemyExit do
  begin
    Finder.Colors += CTS2(8490379, 16, 0.25, 0.13);
    Setup(0, [[690, 720]]);
    SetupUpText(['Exit']);
  end;

  with EnchantExit do
  begin
    Finder.Colors += CTS2(8490379, 16, 0.25, 0.13);
    Setup(0, [[380, 654]]);
    SetupUpText(['Exit']);
  end;

  Playgrounds := [608, 580, 800, 770];
  Graveyards := [30, 524, 257, 768];
  Chambers := [311, 548, 543, 767];
  Lobby := [970, 650, 1050, 770];

  MM2MS.SetupZoom();

  if Inventory.IsOpen() = False then
    Inventory.Open();

  InactivityTimer.Start();
  ReportTimer.Start();

  // runtime & reporting baselines
  InitRuntimeAndTracking();
end;

procedure Loop();
begin
  Antiban.DoAntiban();

  TryAutoLoginGuarded();

  if ReportTimer.ElapsedTime() > 120000 then
    PrintProgress();

  // Periodic Discord report (if enabled)
  MaybeReport(False);

  State := GetState();

  if State <> Previous then
    WriteDebug(ToStr(State));

  case State of
    JOIN: EnterRoom();
    IDLE: Wait(1000);

    EXIT_TELEKINETIC: Logout.ClickLogout();
    EXIT_GRAVEYARD:  ExitRoom(GRAVEYARD);
    EXIT_ALCHEMY:    ExitRoom(ALCHEMY);
    EXIT_ENCHANT:    ExitRoom(ENCHANT);

    PLAY_TELEKINETIC: PlayTelekinetic();

    DEPOSIT_FRUIT:  DepositFruit();
    GATHER_BONES:   GatherBones();
    CAST_BONES:     CastBones();

    DEPOSIT_ORBS:   DepositOrbs();
    GATHER_SHAPES:  GatherShapes();
    CAST_ENCHANT:   CastEnchant();

    DEPOSIT_COINS:  DepositCoins();
    GATHER_ALCHES:  GatherAlches();
    CAST_ALCHEMY:   CastAlchemy();
  end;

  Previous := State;

  if SRL.Dice(5) then
    WaitEx(1500, 750)
  else
    WaitEx(195, 65);
end;

begin
  GUI.Run();
  Init();

  repeat
    Loop();
  until ShouldStop() or HitTimeLimit();

  // NEW: final Discord summary (if enabled)
  MaybeReport(True);
end.

